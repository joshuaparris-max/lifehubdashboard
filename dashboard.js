// File:// offline mode shim â€” keeps LifeHub usable when opened directly from the file system.
(function(){
  try {
    if (typeof window !== 'undefined' && window.location && window.location.protocol === 'file:') {
      // Mark offline mode for other modules to use.
      window.LIFEHUB_OFFLINE_MODE = true;

      // Replace fetch with a lightweight shim that returns safe defaults for JSON/text
      const _origFetch = window.fetch && window.fetch.bind(window);
      window.fetch = async function(file, opts){
        try {
          console.info(`LifeHub offline-mode: intercepted fetch -> ${file}`);
          // Return a generic empty successful Response with JSON body for JSON requests
          const fakeJson = JSON.stringify({});
          const headers = new Headers({'Content-Type': 'application/json'});
          return new Response(fakeJson, { status: 200, statusText: 'OK', headers });
        } catch (e) {
          // If something unexpected happens, fall back to original fetch if available
          if (_origFetch) return _origFetch(file, opts);
          throw e;
        }
      };

      // Provide a simple XHR fallback for code using XMLHttpRequest directly but avoid noisy errors
      try {
        const _OrigXHR = window.XMLHttpRequest;
        function SilentXHR(){
          const xhr = new _OrigXHR();
          const _open = xhr.open.bind(xhr);
          xhr.open = function(){
            try { _open.apply(null, arguments); } catch(e) { /* ignore */ }
          };
          return xhr;
        }
        window.XMLHttpRequest = SilentXHR;
      } catch (e) {
        // ignore
      }

      // Quiet repetitive noisy console errors that stem from file:// fetches while leaving other errors visible
      try {
        const origConsoleError = console.error.bind(console);
        console.error = function(...args){
          try {
            const joined = args.map(a => (typeof a === 'string' ? a : String(a))).join(' ');
            if (/Failed to load|NetworkError|CORS|ERR_FAILED|Access to fetch/.test(joined)) {
              // convert to info to avoid noise
              console.info('LifeHub suppressed noisy file:// error:', joined);
              return;
            }
          } catch (e) {
            // if our suppression fails, fall back to original
          }
          origConsoleError(...args);
        };
      } catch (e) {
        // ignore
      }

      // Helpful UI notice if dashboard supports an element to show status
      try {
        const el = document && document.getElementById && document.getElementById('lifehub-runner-status');
        if (el) {
          el.textContent = 'Runner: skipped (file:// offline mode)';
        }
      } catch (e) { /* ignore */ }
    }
  } catch (e) {
    // defensive: do not break the rest of the app
    console.info('LifeHub offline shim initialization failed:', e && e.message ? e.message : e);
  }
})();

const dataSource = window.LIFEHUB_DATA || {};
const ICS_OVERRIDE_KEY = "lifehub-ics-override";
const ICS_OVERRIDE_NAME_KEY = "lifehub-ics-name";
const ICS_OVERRIDE_EVENTS_KEY = "lifehub-ics-override-events";
const ICS_OVERRIDE_MAX_TEXT_LENGTH = 250000; // ~250 KB safety cap
const ICS_OVERRIDE_EVENT_LIMIT = 800;
const inlineData = window.LIFEHUB_INLINE_DATA || {};
const isFileProtocol = window.location.protocol === "file:";
const cards = dataSource.cards || [];
const tasks = dataSource.tasks || [];
const playables = dataSource.playables || [];
const spotlightResources = dataSource.spotlightResources || [];
const automations = dataSource.automations || [];
const npcVisitors = [
  {
    name: "Lyra the Archivist",
    role: "Keeper of forgotten scrolls",
    quest: "File 3 lingering Inbox items into their proper halls.",
    tip: "Use the triage board to send items straight to Family/Finance/Projects.",
    reward: {
      xp: 40,
      item: { name: "Ledger of Sorting", type: "item", rarity: "uncommon", notes: "Add +1 to Inbox dragon pushes." },
      text: "Unlocks a soft parchment accent for the day.",
    },
    icon: "ðŸ“œ",
    gradient: "linear-gradient(135deg, #8b5cf6, #22d3ee)",
    image:
      "data:image/jpeg;base64,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â€¦JFUXLGcPhidwf8AFjCjf2X6sji4pLbI0n8PPCqpVVKXLer621sawSmsz09yhL2eahafets30aov9HuoCQ32XN/wlR8VDrcvl9miwzsz1CYy51uka0DJc4YAHmsjZuyu53iAy0fcysBwSxwOCpdduOaEW0FoJ2lI+gnr0GPiwmuuUA5vH3XqaHmjfacIGzk03WHxQ3HuCTB7WiHimm7szgAn6JZoodmD2vtsx32QN3P+zd9ks6DKxpvDsf0bkBdps7ROKM67BlCbpP0ickLpV5/oXp512C3qP9o1p5U7kRW3Ag4p3pZxZV3F61cyf6Byd6xdOkBSztdB5V3G97dnf1BCX/PDj/Q4+qed9gsu48R3nh2Y0fVNdT3st2LB9UnKXQdoiZQ3p/xTMAUvs26f/m2hO8g8IvZNwc73q0Y+Ss0tuqKeTjlqjIPDCE5X1E7dDIZIGwS4z1KYiOrroKKmMs7wxo6lUWaht72BwqGYOw3VRVxO4K7Udut0bZaipY1rupKNRqe3U1tFbLUMbFjPETsm42u29gV9NNypPryw01NHNLXQta8gAlw3JVyu1farfbG1s9QxsZ34iU5RUU23sNKT6AbrG0G3NqxUsDHciSpm6lpu5Eu/C4ZBwhxSdidepTtutaK6XJ9JTcTnMOHHG2VtbXZaD4qXZpNFap2YeaAO+ygA5R2wgBp25IjkgBHmj9UAInzCILcJoApZCLALIB5ocQ8QiwCDx4hHjaPxBMLi42/mCb3jQd3DxQF0AzRj8bfuh6xCD/SN+6eVsWZDTWU7dzM37phuFLjPfNx808kuwsyG+0qTODUM+6BulCBvUR/dVy5dgzoabtQAb1Mf/EsPqC+xMsVQKCpjNQWEM97qjlTtohZ11OeWqXUFjhHfX0XFlQ09418g4oyeoPgtfpqfU1NVOlGpHuaKjjDXzg8Tc8j4KVGvbYrmQvsXq6KqfXVz3aiaxlQ1r4yKkARuHQbrcrNru3U9BFT3G4UjXxsAc8ztIJH1WkKVVt5tv/v+CZSVlZGSd2g6YIGb1R4/7Vv+aqTdoelXMdGb3R77H98Faw8txZn2OZ2qr0vbdTXaqm1LSPpKt5e1r5w4tJHIZOyx+nNQ2DStTWRx6mt80b5XPjLpxloO+MrGNCorOUtrmjm5XtHcwj67RXtatvlVrGE3aeXjY9kuWtHRpHgpqfWGjKbW8GoX6hojOyLupGxtOHDx+aOTK3jmt7/78i2pvaJuZ7b9DhuPamT5Mcf5KrJ296Ei/pa9436xOGVaVNu2dGbp1Ur2Ipe3fREsT2tkq5WOGMtgcQVqNq1voe019XPbBcwypkMjo20jnAE88LGboqSbqK6NI0azjotxrNX9nzKSppv2evE7ZyXF7KYsxnmrFPr7TNM6glp9IXyaShBZC90Izwnpv0XO3hEtan+3uW6Nf0LtF2qQW251VfbNBXhktT70gAaGkjyVubtz1IGF0OgLhjH4nhUsXg4KybYPD1G/E0YWn9IHVl1qZKS3aLkfLHs9pl3B88BUK3V2s7iZnzdmcD3SuDnl7zgkeO3NXWxWG8ri2SqEk7qRVkv+vpzIW9m9E0SNDXA53A5BR1V07S6+IQyaJou7aOENk4iAPksVjKC0VNlcjvMp10/axUUkUb9M0DGM2aWxnI+W6FJX9sFMwUlNb6ZnMgcGT/FP4yH5aYuRFfmMXf8AX3a1pwxtubKeESO4Q7ucjP3Wbt57a7xTRVkBou7kZlhdCDsVpLGKyahcXJjfV6F4ab7cnvD/AFqhZj4QIWe78lLHo7ttljPHdqNu527ln+SyeMn+WkiuVR6yJhoPtpMHB+0dOxmPhDG4+2E2PQHbPF/RapiiH9hrBn9E1i6/Smg5dHuxSaC7bBFIf2xOQNgCN/0XILpr/tKs13qLbX6jro6iF5Y5hx+m3JdNHF1pJ54pGc4U15T0b2Oa/brHSjKetmDrlSgMmB5v8HfVdODB4LNO+4pKzDwZOBkBN4cOwqEJzB02THRZblMTG92AOeyYWNHXmgCNwcJMNAxhAtJZnGD1CBETo3gkgbqJzHkEklUmBWdGTnK0zXvZtbtf2qGmrKmWmmp3F0UjNxkjG4VRk43aE1seedW9iOr9Ncc8NP7QpGjPewb4HmFh9M6+1BpEiiLe9pWk5p5G4Lfl4LC+uu6LtpfoblH2h2a8a0sdfFGaOWN5ZMXgbNI8U/X1pOvtZClsQhkfRw8UkoIw7PIZW+aEHOf/AKpfO9iMreVP1/Y5JdrJc7LVuprhSvicDjcbFY+SCSNgc+NzWu5HHNZZlsxtEfE5jcNONuqs00YEYcRklDAsFvC1V3yblvghAQ4LjkDZX7dRvqa+KCNhc+R4aABnmVM5KMW2aU45pJHr61aPub7FSwXPUtc5jYwO6psQtG3I43WWpdGacpHiT2cyolBz3lQTK77uyuLDurUoxi3ljbZafu+pvNxjJ5Vr36mbjjghYGsiZG0cgBgJ7mREZcxhB64C3hTjBWijFyb1ZjbsDT2iaqt9DDVTxjPdnqOoHmta724aipo63TNZRU7oxl1NPFl3F1a8cwFraMFdq7d0Fm9b7EkN+op3Gx6rs7LfVyjh4X7wz/3X8voUholj6l9bammwVfISUTg5sjf7TeR2WLcWskr37f2Wm14lsdvFqZnd36J3sqHqT9lvlRlccLZTjnlOFtpvA4+aLILseLfSj+rTxQ0w/qmosFxwpKYf1LU4U0I/qm/ZOwhdxDnaNn2Tmxx8uBv2SsAeBnRo+yPCMcgiwB+gSB3TAkCcPkgB3TGUsA9EwHYRHMBMA/ROAylYAjwylw5QAuEckixrQScYTsBg9Q26G8Wx1J3gGVgf2Qifb4qTjawM/GDusnRldtPexXMtZdjA6ps9mo6Ue2K79wwe6HHqtPm1DYJrcbfPco30w2DeeyVqfijOW+5VqkrSijGyVGjpOAS13G2MgxtIyAs0/V+lJmRw11WZoYxgMDSd0Xw6unPf1Hyq76FN+qtKYEbJ5u7Y7ijaGEgK1N2h0dR3THT1XcsGOGOI7/ohYjDx0zA8NV3Bbdd2u21r56SlrSXHJ/cuWxntuYxga20XB2OoiKaxuGUcqYfC1G7thHba88rLcP8Awyh/pvlzgWG4H5RpfH4fv/A/hJ/qA7tsqtuHT1xP/dph7bLhj3dN3E/4Ev8AqGH9f2GsJL9Rhbx6Rr7I3iuGnrhG09eFYF3pcW7fFnrMeeF0Uq9GpHNExqUXB2bIX+lzSgbWWqP+IKD/AJXIJy2w1H1eFvnp9iMvqI+ls4s92xTE+HeBVj6W1ZnAsLx85Akpw7DyruCT0t69vw2F31lCgd6Wt4O7bEwfOVHMh2FkXcry+ljqMu/d2WDHXMhVd3pX6rIPBaKX/wAQpc2PYHFEf/Ko1o9nu2yjBP8Aadsq7vSj11nakoh9XI5q7BliVn+lF2guO0VC35AqCT0l+0ZwJElE0+UZP80Kt6CyooSekR2lzEk3SFgP5Yf/AHVGXtz7SZs//aF7c8+GMJ859A07FKXti7RJd5NUVQPlgKs/tW16/PFqe4Y8ngJc2Q73K7+0nWsgw7VFyH/eqvLr/WEgOdTXJw85ijmy7kmQ01qK/wB71TSW2s1JcWRzPDS7v3AfxXqWk7FqKqtkT5dQV0gc0Envnf5rnrKrU2nY2p1MnQm/0F2RzcOulafIyu/zQHYRp/8AFXVhHnI7/Nc/Iqf/AMjNviH2Hf6BdLu3klqHdN3n/NOHYNpAtIMUhz4lT8NK+s3+4viJbFav7A9Im3S9zA8P4SQQVyrs67OLFV68uthvsbzNTyEMaeRaTsU1ScWoZnZhzZSTfY7MzsF0TnJoM58VZZ2E6GZg+zGn6KPg095MTxMy7B2KaHiwfZMfywFbj7JdFRcrND9gn8FT6hz59y3H2ZaOjGRZqf8A4VoHa92W2ao0JPU2e2RQ1UA7wFg3OOipYSnBXitRRrScldlrsptmk79oSkk9kU3fMbwyBzQSHDmuhN0np2IjhtFKM/2Aqjh6UkpZdyXKUW432Jf2csrQAy10oA/sBOFptrNhQU4+TAr5FNbIWd9wuoaMO92khH+AKJ1FTlrmmCPB/shUoRWyJucXvNN+wPa/FdoYw223MiOYBuzX9CuvwiGopGTMDXNcOIFTBK7iXPpLuHuWcJ90KGSkZjZg+aqyIRGaVjm8LgMeQWMq7JGKps8YwRulJXQ09TWNe6Lg1VpWamcwCRo4o3AbhwWndjGo6pvrOjrw8srKBxazjO5apekky1rFrsdui3GCMKYtH1WpCDjJwcIcDQE7CA5o4d8Lzn6QnZ2ZoDq62xZlYMVAb1HihbML2ZxTs81jWaO1pT3GJ5ERcGys6Ob1XuCx3mmvdnguFJI17JGh2QoWk2u5T8qMmDtkhM4s5WhIid8Y+qaeLHPKAB13QLRlAmMcMHP8EgRjJQIZw4ztk+KZ3YIIKYEXcAu5Jdy1r9gmA/u2uaWuaHDwK0nVvZPpLVUbn1FvZBUH+uhHCfr4pNXC9jgWsOwG/wBmc6ezONfTjJHCMOH0WiWe+6l0NdnlsL43naSKZp97Cyv+WRej1Rud17R9O6p0vLS3S39zW4BacZ38ip9ZUOmqvsmo6ujMEVQxrS3hwDy6rojTVSrDvqYtuMX7o4s8DHJZGEYiGyzaLWxIcAKKOmM84axhe48gBuk2krsaTbsjfNKdkOo9QFszoTSQO5ySjGR5Bdr0l2PWTTNxjr5ah1TUR7t4wMNK8qpUni7wp6Q79/Y7Y5aGr1l9Df6i826heIZ6uKNw/CTjZYip13Z4btBbxxySTfA9o9w/4uS9aNDJC8tEkcik5OyRjKjUtZXvq7fUW+KB7N2QyyFhkHQtK1xlw1ZeLbU0UAqjTCTg4mjhmhI/RzfNKeIp0vEls7L/AH1HGi5OzfQ3axRagorYyCpt8DpA3HeseQHeZB6rJS6Zo6ucXBrDRV2N5qc8JPz6H6rkpyc4pNPU0npK6ZN7Pl4BDdH09ZA3cGVgBB8Upr3ZaFojkromnkGh2T9ltToSm81vS5m5ryxOt5x4IE45lakiyPEJBzR1CLADvG8shHvGj8QRYAd6z8wSMzPzBGULi76P8yXfR8y5FhXF6zCPxJeswgfF908oXF61D+ZD1uAH/wB0WC4vXYvEfdL2hEN8oQ9RG4xdSk25RZ5j7o0DUcblEBsh7Ti8UXQtwe1Ys7Je1mZ2/gi6HZiN3by/kpqau792AndMLMyLcYCo3qZ8FnlkiOHNGyiTsmxrVml6VNxvEsz6irwOI4AW2iyO61JRZuMX3Q5aSaKNx0TQXVobXO71o6OCpM7L9Msx/qcf/CsHhYSd2UqskrImb2a6aHKijH+EKVnZxppv/Uo/+EJPCU+wc2Xcmb2f6bZyoY/+EKduiNPNAxQR/ZUsNTXQWeXcnZpGws2FDH9k8aWsgO1DH9lfIh2JzS7jm6ZswO1BF9k4abs4/wCoxf8ACjkw7DzMcNP2cDHqEX/CiLDaf/yMW39lDpRWthZn3OKekRpuiOhJ5qWkYx7RxAtG68QSbO+vRc9JZas4r0Npa04v3A4+7yQbu0ArruYDgOmU0cWeeUmwASSd9gnDAA95CAXFh+2UmycJwmJBEzxyKL5S4cXVO4Mi4jnxTjIQ0+KYhvEQ0lNEx33QLYReXYRDiHZyMpiC9xI5oAEt58kxlq31ElJc4KmMlro3hwI8ivoB2X3kXzQ9HOH8bjGN/oi/Qrpc3ltIRIHHPyU7aXJ5LMZKKQcsbJ3qbB0TAXqjCMEc1wLXltdpHtet+poAWQzu7mYjbmdisq14pSXRo0peaz6o7pa54662RVEZBDmgq3wtHVbNamI1zgOqblp3JAQA0vYB8So3CKCroJaeThc17SCE0gOD6VqzoXthq7G+QNo6xxliaTsDnfC7qamJ7GvEjcEZ5rOlFqOV9DSpJOSfdAFTEXn9437qN1VDxf0jT9VplfYzukN9ZgPORv3UL6qBrv6ZuPmjI+wZkalr21W+/wClZ4XyN71jeNjhzBHJYbsz1jT3GwG31lQ31ikJifv4KHSkpqVt9ClUTg12N69qW5rd6iPHzUEt5trQeKpjx/eWvJkTnRWff7Sw71cWf7wTJNSWYNw6uh/4wmqEmLOim7U1hazDq+DH98LgXaVcrfp7tGt+qrLVM4nv4ZhG4e8PMJTw8sjfYqE/EvU7PZe0LTtdZIKt9xgY57ASHSAbq/8At9pmMe/dqX/xAnCjKSTE3Z2sMd2jaTZubvSjx/ehRO7TdHt39s0uP+0C0+HfcWd9ERSdqWjW871SDp/SBYu79pGhLlaZ6GovFG9kjS0gvBRHD67kylK2x481NT0NNqysjtj2yUveExubywu3dgOv/V5Dpmvl9w7xF38FyV45JaPZm8LyTPSoPE0OB2IR2wmSI+SbuqAGDzKGCT8kCYSOvRMIBGNkCAW4GwymEdUADIAQGOaewAzg+ZSycoADmAk8QGD0Wqam7PNOangc2uoYi4jAe0YcENXVmC0dzg+r/R5uNH3lRYJu/j5iN3MBciu9iv8AZnGjuNNURMb+F2eFRGTg7MtxUloYN43AIWShhlkIZCxznHYAKpSS1ZMYtuyNy072a32+yNfJH6vCfxPG/wBl27R3ZXZLGWTyQCoqB+J4zheXVnLFPItIfU7Faiv/AGOnw0hjYI42BjR0AwnS2x87C0uIztkLuppQVo7HO3fVmj3Ps3rLteHS1FSW4GGyNPxjwcOqylL2dMFIyjqxC6nbyYxuMeY8FFZ1ak79i04qNjYmact8FEyGobHI2PZpl3I+pUT6mx2wcLZYmkfhZuf0VU8I2k306kOrdtIqyX6aUH2fa6ic9HEcI/VQOj1ZW7t7ijZ5AuKvnU4aQWZ/wHLbV5sA0lUVI/5yuNVUZ5t4+Fv2CyNJpi10jSI6OPi8eHcrGpzK34j07dBpqGkTe/XJ/wApTDVzk/D+q6MxFhOq5+ZwAmCpnPIhPMwsiN1TMzm7mnMmqJSMOP0CNRaE3d1bvzfZOFNVn86m7GPFJVHo5PFDVH/96LsCGpoqiNnFxY+ZVOlZPNNw8Y2PiiPYGZZtrkIz3gTxaHZ3kCbQXJG2cdZP0R9kRn+sP2SsFwizxj+sJ+ieLRD+dxRYLjvZNPjdzkRaqUD8X3TyhcPs6jG3CT9U8UNG3fux90JBce2jpMbQtwnsFPC7DWNaVVhNllpDm5BWOv8Aj2HNv0UVPKxrc1TQZ4Z5m4xuuhNO22FcfJH2CT8bCllAhwIwiHfJAByAkCEAHiHkjxBAgcQ8QjxN8UDuhvE3OMhISNxzCLBc5v2wQRVehauMkHMZXzxrm91cZoyBs8j9VxpNYh37L6m170repBkYxkoHiONtl0oxAc5RbIM4QAHOGM4+qbkkYKYAfkcimNduEEkhfjZA5A8UDYAXZyiPeIwCmmIkwc4wU10LsghpCLjysLYJOjHfZSNpp3HaF32SzxW7GqbeyJWW6pd/UPx/dKsMtdYdhSSn/CVDrQW7L5M30J2WS4kZ9TlP+Er0N2M9pDNKWAW+8xTRd3s08B3TjiKTkryHyJuLVjqzu3jTjRs6Y/8AdlIdvWnhsG1B/wC6K152HX5kT8PV7C/092M7Nhqvn3RUZ7fbOD7tJWEf9k5L4jD/AKivhqhDL6QFsHw0Fc4+UJXPO0vtLdrDT/q1vs9b6wHBzC+MjBHXKipicO4tZhxw1RSTMtpPtquFo05BRVtir3zsbwktZkbLLy9u9c8Yh03cHf4cIWOw6S1H8JO71Kju2rU8u1PpOrOeXEQFB/pZ7QJ3Yh0s9ufzPS/6jR6Jsn4XvIif2g9qUzvcsETc+Lz/AJKF2r+1yd2I7XTs+fEofE1+WDLWGgt5Go3vTnaXqDUNNeZ2NhqYDlhjaf1WzRy9snchgdA0NGB+7Kz/AOoTu5KG4cqltcTY+2WX/rETB5RlJts7ZJH/APxJrQf90qePrPaAKnQQ5+mu12U73l7c88MChk0Z2sPHvaiqdz0aEPG4l7RQZaBXf2b9ps4LZdSVhB5jKx9H2I6woZ5ZqW8VUD5d3uY/BcVLxGKdtCr0Vsi47sb1vIPf1JcD/wB8U9nYhqeTHfahrj85ijm4x9RcyiugH9g15kP7y+VZ8czFM/0AV+R3l5nd85T/AJpXxb/MJ1aV9EJ3o+vIPHdJd/GUqN3o8wPIMtwLh/aflDhiZbyDn0+xJ/ye6IRj/X8Y2+JFvYBbTs6vz/iS5OI/UHxEeiLDPR8smB3lY0/VSt9H/TwGDVtPhuj4fEP8wfExXQkb2B6XAHFUA/VF3YHpQ4/1hvzQsJW/UHxS6ITewbSud6kFX7Z2MaatVxiraWr4JYzkEFDwNWW8g+LS2R1akMTaZkLZg8tGM+Kn+I7LsUXFWZhdPVCwkfhTAj4slM4iCRlBIOPOyHF5IGIlxHJNdxIENLSeeEgNuaAEQgTgZTsAgTw5CBJG/RMAbOO+CPNYq76Ust9gdFX0MUgPUtGVLWbRhe2py28ejnYq6v7+inMDSc8HRZ2w9ilhsga/DZZB+JwyuGvhqk5Wv4TpjXSW2pulPpugpAA3hGOitCGmp/h4V0U8PlRnKo2NfVRAcwovXmg/0gHktbEXuRyXFo3bIAR5rES3DUFVUOZTzRRRZ+IblPNkTla7GoqWjCLVNO4GvrppfFvFgLI0lDbaTHBTNPmRlYzzVfxH8uhaeXSJkmVUbBhsLAPkne0YgCXcICtRWyRDZBPfLfT0zppZW8LfBYKr7QLPTgta1z3jGG8iR4reFG+snYhzf5UdOp2wSRcRapxFTgZ4QspRBMo1kkMewa3CFFI17S7hGPklEplWtqj3vCwb56BXqAERB79k4hIyQnYBzSFVETgFFhXFJVMYM5UDrlGOoT0GUq+s76Mhvh0WHop3QTFzicZUxaUh20sbHBcOOIEFPFf+9wSqb1JRO+ua1vFxJ9PVibdAy6DtlMllEUeUAY03EB5Gd043ICPKVx2I4KqSaoAHJGuq3QDA3KTelwJKWpkfTFzs5WLmqan1v3fhyhuzBGet8zpGAO/VK9QuntT428yETV0CNPsFNUW2skcQ7BK2YXOTHVOE/BFNBJXk2Y+56qZboy+U4A3Wry9rdqjdgzjIPiqjVhtJ6hypPVDB2w2gHBnAPzQd2yWlu/f5VOrSXUfIqdiN3bNbCD+8JUT+2ehHw8flsVDxNFdR/D1CE9tVJ0jmPyaVGe2yDG1PUHw9wqfi6K6h8NMjf21j8FHUn/uyoX9s1UR+7t1U7/AQk8bRRXwsu5A7tgu7v6OzVf1ao3dq+o3fBY6r6hS8fT6Jj+G9TX9Uaw1jqKzSUMVpljLwRxO6LiUnZFqapqHTPhdxPOTsuOri255oxNo0oKNmwt7GtRlwzGcfJTt7FNQncsP2U/E1f0i5VK25OOw2/Ob8LvspWdg17PMO+oS59fpELUkWWdgV4cNy77Kyz0fLmd3Of9kczEPoF6JO30eK5w+J2VOz0dKviBLn7eSP+5Ys9JdC5H6OEhG5crkPo3MOzuIp8vEvqDr0v0mQh9G6mHxNz81cj9G+gB95oR8NXe8hfEw7F+L0c7S3HExh+avQej5YmHD2R7Klgqj3kweLVtEZGHsH0zEPeji+yvRdjGlIvjZDt5BV/wBOvuyPi5dC4zsp0fDzbD9MKYdnmjIt+GHb5LVcNh1JeJmTN0bopjd2wfopG6S0Tv7sP2C0XD6fVE8+YDpfQ7duCD9E9undEAbRwfomsBS7C502B1l0O3myAfZN9l6FHwsg+mFSwNPsLmz7h9Q0M0/0cG3yS4NBsw0im+4QsFT7CdWYS7QkQ4uCmH2UUl20DB72aP7haLB03shcyaK8mrtDUzSW+q4+ioT9p+hKRpc6WkaPmE1RpoLS6lcdrek5WGSlYyVo3Ja3KoRdt+lqicsp4i9zdjiM7FN8paD5U7EFT272CCqFP6tJxnk0RFWpO2GnZTiRttn4T/uyhzpqyEqTavcwNd6Q9ot0gbPRztJ/3ax7/Scsrd20lQf8GFquW9ROD7kX/Kbtjz7lDUfLhTJvSVpfwW6od9AhuCBRKrvSSc4e5apiOm4UZ9IqrcTi1yY/vBDnBdAyFWX0ibnx4ZbCB5vVKb0ir4CeC2tHzelzIroPllCX0itR9KCMHzeVWk9IXVLt20kLT5vKfNXYOWkVZO37Vz2/0UA+pVSTt51eT7ogH32U870FkiQO7ctayO/pYB/hKa7to1ocEVEI/wAJTVXsh5EVpO2jXLj/ANOjZ8mqA9seuCCPaQHmGodZhZbWIn9r+uHbe1sfJijHaxrnce13f8KXOYaBb2qa3O5vD/sk/tU1s4//ABmQDyaEfESCyNx7N+12+w6qip73XunhlOAXbYXq2iuUFXQMqGPaQ4Z2WGdym7ltJJNFervlHSOBfK0D5qaG5U1VGHRytIPgVbjYzuWGuB+EhEsJUMpDeBw6JFqQxYPVNz44VCQjjKaR4IAHLmmu3TQhnEQ1AuOEwBkgc03jcDkEhK4B71+M5KaXuLviP3RcCOUl2AXFU56dzwRxFK7ApS0UmDh5VZ9umx8R381OpZVktc55OP3TIqOtpzlkjvkolcaMDeNRX23VYb6se7/OqNu1/XVVzfRGmc54/F0Wk6kYpt9AUL7D7pru4UVUaZ1O8AjJe0bNVW032611dipZLLFJux2dglWxEKcNNxwpOWrHy2G/y173xVAMUjsmN3w48ArNboys7yGppvekAwcjPD5BZTqznNpeWxaUY2a3O4Nqu4pE2Cske7Odit76mFgVjXyHIPNT0p4afBKmK3G3sV3R5qOLJxlXHSFkPulJJqIys2eUsOXJ0Helw947lVZiuixUNcY8cW6rQ0r3ZLnHdKzuF1YutpI+HDiq01DA53L7IcAUmi1BHDHHwkbKvNIyN5LBlNjRF3hkI4v1WTopAwZIwmkIyPrjAOiq1lY18eAk7CSMbE+MTFzgCVMeAjGBulZFXZNTvbFucKKql72T4chN2FruOjnLY+DG3mpoYe+dnoUm0wMtT04iAwFZeWhnvYx5qgKD57a0kOYzKb65bQccMarlvoTmMReKS1XSExuEe/yWpO0Fp5xJ7uD9FhPBqbuy413FWQwaB06D/RwfonjQ+mm7FsClYGHYbrzY8aQ0yzmIPsFK3TOl2jBEHywtPgob2J5su48WDSrefcfYI+ydKNOP3H6J/Bw7E82TF7P0o3n3H6Ihmk4xjMP2CpYWC6BzJMBrNIszvD+iifetJR8nQ/cK/h4roGZkD9WaQjH9JBt5hV3680bGdp6b/iCpUIroLxMqSdpWjIjvUUv/ABBVpO1vRUe5q6QeZeEZIoMsmV5O2fRTBn12k+jgqr+3bRTOVbTfdPJGwZGVpPSC0bGMCsh+yqv9IvSjD7sufkwlCyjcGZm1dr9JdoRNR00j2HkQxWJe06RvF/qU3u/2Fk6iTKVNGpXb0hYLVUGGehqQ7+5sr9g7aK3ULWvo7ZUcJ5ZCarQcU1uU6NnqP1F2sagsVKal1pme0c8EbLDaf7cr3qGrMdLbJG42OXBTHExd421QcpJZr6G012t9YU9L3wt4Ix+dahTdrGsa7UfsxlLHG7HVx3Rzre4owT1RY1Vq/tDtdujqoTEA44wQdlNbLjr242wVEtaGnHEeFpU86Tk6fYp5Min3Ncu2qdSQNkHt9ocz4gCNly659pGsG1j4479OWj8uFqpNJNMjXqilBrjWVZUsgbfqvie4DZy9B6H03eLlahJWXmoL+HJ4381E6kpSURt2joYrVemL7RVQqaa8VjYwdwJDhXdKCkuhNK++SyTs2ezvDkLKDd3Tk/Ycm5RzxXuYztLjp9O0QmbdqlpcPhbIVqGidQ2qsr2RXG9TNkkPC1j5DutlomuxLu0mup1+86dtkWmX1ba2XZnECHHdcg07Ru1DrORkFZVOgiPCSXuAz8lnPweFdSoNtOT6HXbhoK3TWtkMVU90jm7jiOy5IeziuptbsgmnlfSl34nnZZVs9PWOz0KpTT8LOj6k0radP6MNY2m9Zna3LWNG5+64Zeb4yppzFHZ5IJOucFbKUab5bIinOOa517sfhs930z3E9O0TtHC7ON1tP7DWi01k9W+FvC7LgAOazVFTyyXS45TcM0e9jj1/dPR9oUdwrqFsdA1wa0NHIZ5ldip6u13rT8MdqZTPBaMk4yqjaTlm0YppWi47HMO0Ts/qpqZ9dG1rCwcWG8lwt0bmSuY7OQcJwzJtS+QNqSuiaHIdsPqrnA75KxIkjY7ljbxVtrSGhIpIXdvdJjH6KOWn974fqkmOxWfTZycbqI0ZJ2aSncmwHUT+HIaq76N+cYSDKJlK/PwlSerOznhwi48rGupXEHDHKB1JJn+jJ+iMy6hkb6C9SnJx3b/spRbp9sQP+ylzj3HypdiUW2o4f6B//Ci21VeM+rvP0U82HcrlS7CZQVsE7ZYonhzTkENK9H9k17vV7tLbdO9wLPdBKiVaMZJp+g+VLK7rY3uu7P73VTu4qwmN2/CsUzT2qLbcm0lK53d9SUSqVI3k9SEovQ6HY7Pc4Y2yVkoJxyWwCnx0ytIOTV5ClboMMHkoXQ+S0JGPiwOSgc0dAmIZy6IYQDEeSbtuUAyN2x5JhGRsE7iAAeqBbjdIbAcJnF9kAgEglMLgSd8oAHXCJY3CAuN7pp6Jrom+HklYCnW22nqYHNliDh1BC1ql0pboLk6opsNJOC1Z1aSnGxUJZTK1Gn7fPvUQs4gOZCUdHaaAcI7toHQI+HztO2wcy2gHXWkY7hgjdIf7ITHV10mH7ilDB4uVt06em7BRk99DepYXyM4Q0qSnp3RtHuFK+4NEz43nGGbJojmxgNwi4WHCGUnknGB7hgnCLsLAFKQ7cqZsTm8sJ6hYJic7nlObE8bDP2QGw7upcfiQ9XlP4XH6IDceKORwwWPSFteTnuikwuH2Y/Oe7Kk9Rn/KR9UbAEUM56fTKPsyV3Ph+6YXCLU8dGZUgtchPxNCVguPFrOd5P0Tham43k/RFguOFrj/ADuViGkZDjhJPzTSEy0DssZe6h1Pb3PaeQynJ2A8sdovbJd9PakdSQ05e3ffiwtFf6Qeozypm+f7xLD4hSppmlSmouxXf6QOp8bQR/8AGVE7t+1UT/RxD/EVvzkY2RE/t51c4e6Ih/iKru7btYv3Esbfuh1l2HZFeXtl1q/Y1kY/wlVn9r2tXDa4gfJqXO9AsiB/atrV2f8AnV4zts1QHtL1o85N5lH0CFWYEb+0TWLtvbVQPkq8ut9VyjDr3V7/ANpS60hlZ+qdQv8AjvFYc/7wqB97vEnx3Ord/wB6VPNk+oNlaS417yQ6snPzkKjFRO45dM8/NxUuTfUB3E87lxJzzylh2Nz57ozDTEAceKQacdSk2CDwEjJRw4gc8oEep+xl9BU6OpjLHGZA3Bz1XQmQUc1dJDNBEG9CFbh5WieskcZ7U9I0tfdYpKWMMAdu7HMLeNBW+isdoinMbC2Nm4cOiwoUWqks2y/s2qTvCNuptNwitOprPJIGRuaQfdA5LjlLBTaG1jJN3LnUsrtwBnhVTpKNSNVezJpttOmzqtPd6HUNOwQ1ojbjZhGFpt2tkNl1ZT3QuBIdwk/NViIRfjb1QUXJSULGy6rrIq3Sgl7vj4WhwACgsd8jrtJmnpwWuLOEgDBTbgqslfdEKEnBejOWXns9qJ7hNPDA4l5J681pt10Fd4DllG76BcqqQpLV7HRllN6k2lNHXeLUUM1RRkMac7hd/qLnU2nTTWU9PK6fAAEY3V08VC0pETou8dS/bry+92b1espHRS8OD3gWlRWOus2uPX6OLEUmz8BOpXjKMZpa3CFPJJq+jJO0SwV+o7Q2GKMl/jhcyouyrUNPWsqI2FrmODgQFnVxLztxjuaU6cFBKT2O4UguEmkxRVbCJBHwnIWvaQ0tX2a6T1T4iGvcXD3Vo8Q3KEsuxmqaSnFPcy1XW6lGpRU0VL+4b7pBJGQsrcIaqto21AhdHUt3xjqqWIck04idOCytMhzcbhbfVbjTPBxjPDsVrNZ2e09S5zu73O+A1Tz8yu46oOWo7PQj01pG9abvDpaVrzA7mMYWyV0GqZrnHNTte6AfFG8c1Kr1FFpR6lOFNyTb6FS86Tq77R92+ic1/XZR2Xs2rbZF+7iqGvO/u52KJVqjnmsEYwUcqZnrjpq/V9mdQiGQ8TeHjeudu9Hqre9z3d5lxyVnVq1pWymkFSgiaH0eqlpB4ZFfZ6P03CA5r1k/iO5Wen2J2dgDht3b1Yb2BuG3duRlrvdg6sOiLEfYKMAmI/qrA7BY3Y44uXkny63cObHsSs7AaYtwYB9lNH2BUjecDcfJLkVH+YXPXYbL2G2+E4dA1JnYZane8YGjO+VfwkreYl4i3QeOw2yh3CYmDCTuxKyMk4XQxAfJHwUn+Zh8U10JafsUsLpOExxn7K3H2Mad77gdFDkfJL4C/Vh8VLsW2djunGPDRFD+ie7sq01T+66KH7Jrh8OpLxM2ZGm7IdOzxhzYIj9FaHY5p8D/AKNF9kPAQHz5DT2O6e//AC0Y+iyVo7ObXZasTUcbWHnhqI4GC1E8RJ6G2iBoaAegUBpYePiMYz44Xdl0MQljfBRmMA8lQETmADkoCzmgRBIzdVnsPJAXIHMLeiZg4wgYuEnmmhuBugTEWgoEBAMiPPH0QIycIEMcwgHBUeN0D2GcJycpBp5IGwkfom4OEC2DkgIZJOUCHYDm4xlYO8W+pbGamgJDx+HoU0NmpUt1uclaaa4l7N8eC2qjssE4Ehdx53OTlZznKely1HIZOOhoqb3XloPmsnBTwcGWtGEuXZBmvubgKIdXD7Iijb+b7KrEB9Tj6klH1OLz+6BjhSw4+Ep3q8WNmBABFPF/swnd1GBswfZMAhjfyj7J3CPAJ2AOB4IgBAB5DZOzukARy5JHmiwCb4H7p4CYCxuifBABAyieWUALOOQSJQAuJYfURBtTx5FRLYEeGO2mF37XOcB48lyx0T+jHYXJhGsnzZ0V4u6t2Gd1IXfA4pwp5i7+jd9l0OSXUxjCXYe2jqX7iF/2U7bdVu/6tJn5KHVj3L5Uuw8WiuedqaQ/RO9g3JwIFLJ9lPxEO4+RPsObpu6u3FJJ9lOzSt3djFHJv/ZUPF00UsNLqTjR97P/AFJ+/knN0RfHYxRSfZJ4yA/h+7LTNAX1wGKR2/krDOzbUDz/ANFdz8FHxqeyK+HXcsM7Kr/I4fuD9lbj7IL4QMxkfRT8bN7RHyaa3Zbi7HbudnZz8lbb2MXLbJP2T51d7RFloouQ9iVW7HE5/wBAr7OxB+Bnj+yd8RIM1JdC3H2HN4d2v+ysxdhMR5tdnqjlYh9Q51NflN10noOq01F3MLXuiznHgtlFmm9b75sM3H811w5qik3sYSnFyvYgueirnfJWF0XCwHO3Mqy/QNzktvqcXeRNIwS1ZONS8rPc0zxsvQksvZvdLQf3M0j2Hm15JVqs7M5rjUiaogbnwwk6c5RytidRXui3B2bOpowYqZrSOoCqXPQDqpwNZgtbyCvkKSyvYjmNaokbo2I0zaaWQFh2wUKfQ1up5R3TmsPi04WnIindkqpIzH7KUTYge++qgOl7S8nvOF58Tuq5UL2ZLnLoNg01ZWznDWbeAV19js0bQ+RoO+MkJpR2sNqQ2a3WSBwHdtweWyVNTWZ8xZ3QODyIR4VoLK2Zv2RavVeL1ccvBYzubWHSNbTD3fJPwoEm0Y59VbWytaKXrjOFs1HR0E1FxilbjHhySUoydhuLWph5mUsVz7sUW3jhTPFIyAuFHkjpw5SU7g4WK81RSRhjjRc/BqrS3GkgyHUXvHkMJ50HLbA+6Qgsa2g4s/2VcbXM7ouNDgDl7qObFsThYFougnrnRvouHB2y1b/S00ElM1xhYD8koyUynBxJvU4RyiYPokaWL/Zt+yqxIfVo8fA37Jdyzo0IsAO5afwhLuB+UIsAhC3wCXdBFgF3bfBDu2+CVgNdvtDPJvC8tHkFhW0txYwND3P80pNp6FJLqROtl2Na1/GeDG4Varst4nkyyV/Dnl4Kc09SvCNorHeYKtz5ZHuaeSuM0/dX1vfiZ5bjGEKU9gbiWaayVwqe8nc8gcgOSNXp+pq5w4B4A57p3k1Ziuk7mctVDLSQiNwOyy5GBsrgmlqS9yNwURGyolEeW5xlRuHigCM4ymHCAIZFEBxHGEAJ0OeiidB4hIEQups9FEaXrhIY005PRRugd0VARmA+Ca6E+CSAhdC7oEwxuJymJC7t2/NNMJHRK4WGGFwPI4QML/D9EXGIQPPIIinfyweaLha4hSPzkNUooX+Bwk2OxI2gcTuFMLYSMFuyVwRirrpGmrmcXdhknRwG615tBdLHPh3FJFyyple+ZDjbyslqIn1mJmu94cxlT0VTWniin91o5YVSqbTQlH8p1ZLdWIHJFAB+qBI6lABDhnmEuMeIQK4uNo6o8bfEIsMXGzPMJCRnVyLCuHvmfmS71g34kBcImZ+ZETM/MgLgEzB1Tu/YOqBi9ZYkalgQK4PWmAoGrYjQBprWgY2RZUB7ggZZBBCo3On9YpSzyUSWg1ucS1d2WwXy4unlgDjnnhajJ2NW9mQadq8yGClfc65YjRJAHY/QNdtTM+yvx9kNCGAmlZ4clt8EurM/iJPYtRdlduY3emZk/wBlZCDsxtjR71Mzy91aLBQZDxEy9F2YW/pTNAxn4U93Z3QQ7+rM/wCFNYSmugudJmToezW3y4Pq7ST5LNRdltBt/qzPsm8LC+wKq7FpnZjbxj/V2fZTM7Nbc3/q8f2TWHh2HzGiwzs6twA/csVqPQVtZ/Vs+ypUY9ic7LDNFWxv9Uz7JtVpa2ww57tv0CrlpbCcmzAVNBa6apDCxoyqrm2yOpLCzOPFWmkhZdS7Gyhc7aEY6HCRNMJXBtN7uNjhDElcTZYgdqYcPPOFE2ui9ZIbTjGPBF+w7ErK3iyPVxnHgoo66Xvw0045+Cd9BW1NxtT2GBpexgOPBZhgiI90NVNCJOFvgEeEBTYYCwObhazebbVSZDHHh6EKZLTQaNfisFzM/wC8kcWN5K9FpmdrzK+R5zyCize5Tkrl/wBiPfTd1g7qKDS0kUBY4lxznOVWXW4s1tC5S6YgY4ukGD1Klk07DyDQ5vmnYHK5GdMQSvBkaMDonN0tSRv42ABLIK5kTa4TTCLH1VZ1jhcMYana4k7DP2ZoSMcI3Oc4V6ntkVOzgaPd8EJJajuweyabvuMsBQltNNIctYGn5IsguRCyUhd+8aCPDChlsNukf77BgctkZbhdjmWGhaP6MbctkHWWlAIwMHyRkSC46Cx0UcneMaA7xCykbBEwNamopBcl65KW2MpoQMhDZFgABskdkgAU0kJgMJGdymmRg6hMQ1zWyN3AIUYiYDs1o+iVhkjWN/KE9rG9GhFgAWN5YTmtA5BFgFt4JbJgMLgNshNLgiwrjOJp6prxlhwUCMVM58U+XclZZIyVnuu3QNjXQu5hJsZ5EJMYJIvdVItcyTrhMSLLWcTeSPc+SSGMMOeiaYMnkmJA9W8kw0oJ5JWGD1MHoozQ+SBIaaDI5ZTPUMH4UhjfZ46BEW8HogBwtrTvwoi3N8Ai1wHi3M8EfZ7Qc4RYBwomDontpWflCLBceKZvgj3TR0TsAjE3CqT0kMrCyRgcEMDXa6wGF5mo+f5VTp5GRTFs8fC/wKiUVH2ZXm33Nz9c89kPWz4q7kJA9bPiSh627oSi4WAas43KaKvI2JKYWCapwHVAVLj1SuNB79/ml30ngi4B716XHIUkwGOme13NFs7nHAcqAfxyYG6HHJ4pXGEPk6lLieeZSAOX+JSAeTzKYh3A89CiIpD+F32SGA08p24HFW6aGQc2kHzSQXL7RgYRdu3fdWIp1TYBCfdbutPuNTCys7oRg/IKHoNO5DRy8U7gac+WQsuGP4Qe5HCq3EYyV1R3zuCPkq4nq37924Bp3Sj0GZSlkqZhsA0Acyq1c2swA3ffoiewLczFnfMyJveHl91sBrQxmThXoSySGtbIcbAq20ghDQIcCj0SGNccNJ8Fh7hVtfGWcXyQBgzbRUv43Rh3gUz9nYzJ3jgM+Czasyky4y2BrQCBsrAtsJZgjfxVANbbIgOnzwj7Mps5DAD5BKwDjboS0N4dvkk21U4OQw58cIsK46cGkg4mh2PkjQ3MvqA05VJ2EzY2OBaD4pxKYkIFRVEjWN97CBmLlucbX8I4UPaW2cjCbaFYsU9c2Q81fa9pAOUgHcQ8UuNo5oGEOaeSRwOaQAJBGyZxgHCYDi9rW5KZ6wzxQK4u+aTzSMjQEBcYahmDg5+SxVXVvjk2B5oGXKOq7yMAlWHhxGQluLYTHtaQCnOl4RlMYGTtdyTJ6tsLCXEfVAmVI7vC+ThDh91kI5WyNy05CGGw8Y5I5HJJDGvOG5WAuV6ZSSYe4DpunewD6W4tqouJrsg9VVra2SJ3M4TYkTUVx42Ycf1T5a/uzzUphYfHdWd3nITW3drnYDh9FQWJ4rkxz8FwV9rwRkJDDkdE15w3ZAkazeL36g/LnYUluuwroQWuzlU30C2ly490rAXYOPHCpi7tjmDXOwlcY+tnEtIZGYO2VqUeon0ly7mYlozzKHtcI66G4UN1p6qna4OBz5q330ZOxRYlMlHC9MdTsPQFIaEyMNGwT+AYQMBjGN00xhAhBoKXAEAhcAxyQ7scsIGIRjommJvggTG92PBLgHgEAIjwG6BCAuLHVIgY35oC4CNkMIEDkggYCo3jLS3qgZiZpJo6ruyPdKjqbZBWsGQA/wAQk3q0FtLl5sXvZ4Snd0fypALuj+RFsDsfCmwKs4kyfdGAooeN78bBJASSNeTjiAToGue7BeAExFzumjm8KRkLHD40WC4/uIRzcU9tNCfH7pDKNVFC13X7qrTywCo4PPxTjdsHsZZggc0ZaPup2wQnGGhNoSH+rwj8DSj3MQ/A1KwxwjYD8IT2tYOTR9kWAdgflCcCEWAB3CQOUbAHKr1UojhJTAwVTXcb+EFM9mRVDmyv+Lop3C9idltjY7ORlW+5aW8OyBsj9Rj4id08UEPIRbfJCiBI2gY0e7EQniiHMQEn5J2C49tE9vww4Va4U9THSl4Z+qV7CMbSVcwqWtdsVt0LgYWklWndA9yXjB6hLvGDqiwrgke10TgD0Wl3B0jqksDyBnGVEiomftFKx9IOJ7iVkhQw9cqmiUPFHBj4c/VOFNAP6sIGOEMQ/A37Jd2wcmD7JALhaD8I+yOB4BFgK1ewPoXjC1BhMVaCPFJ6DRuNI/jpmlWMq3uSggqhdOI05LfBIZo0pl9fPHIQM7rMxdy6AAy5KUdUEiaF7WPAa7IVl1yEeG8W6ewE7a4kAgpS1xZg7oAMVwy4bqSW4+51QJjaa4GUkBTGqAdjkkmMgqKp/AcLEsrKh9SWgEAdUOQJGQgknMoaQceKmnfK0HHNFwKEU04mPGCBnllXfVjPFnbKV7jYooXQO5q02UmPCaE9SLjeXb+KmcHOZzQK4IY3NO56rG31rxTHgfhC2A0Snmr4Lvh7ssJ55W+2qpc5rQ4pRlcuZmg8eIS49+eyoi4i4EFaXqq396x0g5jdKWxS3RhbNcJadndPDsDYLKTVLpzsCUoyuga1ZJTP7rGdlbqWtmiBGxQK5SZSz8J4XHCMFHwuy9xykm9B3RIyGRtSCxxxlbPSEtpxxEZTV2wbJw9o5kIl8fDuQrsTc1rUVuhq4XYAKwlijfQ1PASeHKipF3TRUXo0zcJalhpdz0WnXFhkrsszzzsrexMdzKUof6twkE7YWs6gszpGmZjCHDcEKbXQ72ZhLJcbhS3H1aRri3kul0Almga/hJ2UQlfQqS6mVha5uA7Iwpycbq0SNOEkwGnKac+CBCwjjBQIPklgIGwEJHCAGkeCYRgoABG/NIjfKAuDZDbPJADT4JdECAeeyaSgBpJymkjOEAV5mNfuRkqlUVLKSPieT4ItdlM//9k="
  },
  {
    name: "Fen the Quartermaster",
    role: "Logistics and provisions",
    quest: "Clear 5 downloads and tag at least one for later.",
    tip: "Run the downloads watcher to spot stale files quickly.",
    reward: {
      xp: 30,
      item: { name: "Courier's Satchel", type: "armor", rarity: "common", notes: "Advantage on Downloads goblin pushes." },
      text: "Grants a shiny border on the Downloads card.",
    },
    icon: "ðŸ§­",
    gradient: "linear-gradient(135deg, #0ea5e9, #22c55e)",
    image:
      "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 96 96'%3E%3Cdefs%3E%3ClinearGradient id='g2' x1='0' x2='1' y1='0' y2='1'%3E%3Cstop stop-color='%230ea5e9'/%3E%3Cstop stop-color='%2322c55e' offset='1'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='96' height='96' rx='22' fill='url(%23g2)'/%3E%3Ccircle cx='48' cy='40' r='18' fill='%23e6f9ff'/%3E%3Cpath d='M22 83c4-16 18-24 26-24s22 8 26 24' fill='%23e6f9ff'/%3E%3Cpath d='M48 20l6 11 12 2-9 8 2 12-11-6-11 6 2-12-9-8 12-2z' fill='%230f172a' fill-opacity='.2'/%3E%3C/svg%3E",
  },
  {
    name: "Mara the Bard",
    role: "Traveler with tales",
    quest: "Resurface one old project and add a note in scratchpad.",
    tip: "Hit Resurface and pick something >90 days dormant.",
    reward: {
      xp: 35,
      item: { name: "Bard's Quill", type: "weapon", rarity: "uncommon", notes: "Add +1 to Performance/notes rolls." },
      text: "Adds a musical sparkle to your pill badges.",
    },
    icon: "ðŸŽ»",
    gradient: "linear-gradient(135deg, #f59e0b, #ec4899)",
    image:
      "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 96 96'%3E%3Cdefs%3E%3ClinearGradient id='g3' x1='0' x2='1' y1='0' y2='1'%3E%3Cstop stop-color='%23f59e0b'/%3E%3Cstop stop-color='%23ec4899' offset='1'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='96' height='96' rx='22' fill='url(%23g3)'/%3E%3Ccircle cx='48' cy='40' r='18' fill='%23fff5e6'/%3E%3Cpath d='M22 83c4-16 18-24 26-24s22 8 26 24' fill='%23fff5e6'/%3E%3Cpath d='M30 38c6-2 12 4 14 10 2-6 8-12 14-10-2 6-6 10-14 12-8-2-12-6-14-12z' fill='%23ec4899' fill-opacity='.35'/%3E%3C/svg%3E",
  },
  {
    name: "Rowan the Ranger",
    role: "Scout of the wild inbox",
    quest: "Finish a full sweep: Inbox zero plus one backup check.",
    tip: "Use the backup widget after clearing Inbox to log freshness.",
    reward: {
      xp: 45,
      item: { name: "Crest of the Ranger", type: "item", rarity: "rare", notes: "Glows when Inbox dragon is low." },
      text: "Temporary badge: Rangerâ€™s Crest (blue-green glow).",
    },
    icon: "ðŸ¹",
    gradient: "linear-gradient(135deg, #22c55e, #0ea5e9)",
    image:
      "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 96 96'%3E%3Cdefs%3E%3ClinearGradient id='g4' x1='0' x2='1' y1='0' y2='1'%3E%3Cstop stop-color='%2322c55e'/%3E%3Cstop stop-color='%230ea5e9' offset='1'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='96' height='96' rx='22' fill='url(%23g4)'/%3E%3Ccircle cx='48' cy='40' r='18' fill='%23e8fff1'/%3E%3Cpath d='M22 83c4-16 18-24 26-24s22 8 26 24' fill='%23e8fff1'/%3E%3Cpath d='M30 48l18-16 4 6 14-2-14 12-4-6-18 6z' fill='%230f172a' fill-opacity='.25'/%3E%3C/svg%3E",
  },
  {
    name: "Iris the Tinker",
    role: "Automation tinkerer",
    quest: "Run any automation or create a new preset.",
    tip: "Open Automation Commands and queue a two-step run.",
    reward: {
      xp: 50,
      item: { name: "Tinkerer's Tools+", type: "item", rarity: "uncommon", notes: "Add +1 to automation rolls." },
      text: "Gears icon highlight on the automation header.",
    },
    icon: "âš™ï¸",
    gradient: "linear-gradient(135deg, #6366f1, #06b6d4)",
    image:
      "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 96 96'%3E%3Cdefs%3E%3ClinearGradient id='g5' x1='0' x2='1' y1='0' y2='1'%3E%3Cstop stop-color='%236366f1'/%3E%3Cstop stop-color='%2306b6d4' offset='1'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='96' height='96' rx='22' fill='url(%23g5)'/%3E%3Ccircle cx='48' cy='40' r='18' fill='%23eef2ff'/%3E%3Cpath d='M22 83c4-16 18-24 26-24s22 8 26 24' fill='%23eef2ff'/%3E%3Cpath d='M48 28l5 5h7l2 6-5 4 2 7-6 3-5-5-6 5-6-3 2-7-5-4 2-6h7z' fill='%230f172a' fill-opacity='.22'/%3E%3C/svg%3E",
  },
];
const agendaConfig = dataSource.agenda || {};
const triageColumns = dataSource.triageColumns || [];
const triageSeeds = dataSource.triageSeeds || [];
const TRIAGE_MOVE_TARGETS = [
  { id: "Work", label: "Work" },
  { id: "Family", label: "Family" },
  { id: "Finance", label: "Finance" },
  { id: "Housing", label: "Housing" },
  { id: "Personal", label: "Personal" },
  { id: "Projects", label: "Projects" },
  { id: "Hobbies", label: "Hobbies" },
  { id: "Media", label: "Media" },
  { id: "Archive", label: "Archive" },
];
const copilotExamples = dataSource.copilotExamples || [];
const backupDestinations = dataSource.backups || [];
const PYODIDE_VERSION = "0.26.4";
const PYODIDE_LOCAL_BASE = "Resources/pyodide/";
const PYODIDE_CDN_BASE = `https://cdn.jsdelivr.net/pyodide/v${PYODIDE_VERSION}/full/`;
let pyodideBaseUrl = PYODIDE_CDN_BASE;

const getInlineData = (key) =>
  inlineData && Object.prototype.hasOwnProperty.call(inlineData, key) ? inlineData[key] : undefined;

const iconMap = {
  inbox: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
      <path d="M4 8h16v6a4 4 0 0 1-4 4H8a4 4 0 0 1-4-4Z" />
      <path d="M12 4v7l-3-3m3 3 3-3" />
    </svg>
  `,
  briefcase: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
      <path d="M7 7h10a3 3 0 0 1 3 3v5a4 4 0 0 1-4 4H8a4 4 0 0 1-4-4v-5a3 3 0 0 1 3-3Z" />
      <path d="M9 5h6v2H9zM3 12h18" />
    </svg>
  `,
  family: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="8" cy="9" r="3" />
      <circle cx="17" cy="8" r="2.5" />
      <path d="M4 18v-1a4 4 0 0 1 4-4h0a4 4 0 0 1 4 4v1" />
      <path d="M13 18v-1.2a3.5 3.5 0 0 1 3.5-3.5H21" />
    </svg>
  `,
  finance: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.7" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="7" />
      <path d="M12 8v8m-2.5-5h5" />
    </svg>
  `,
  home: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.7" stroke-linecap="round" stroke-linejoin="round">
      <path d="M3 12L12 4l9 8" />
      <path d="M5 10v8a2 2 0 0 0 2 2h4v-5h2v5h4a2 2 0 0 0 2-2v-8" />
    </svg>
  `,
  personal: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.7" stroke-linecap="round" stroke-linejoin="round">
      <rect x="4" y="5" width="16" height="14" rx="2" />
      <circle cx="12" cy="11" r="2.5" />
      <path d="M7.5 18a4.5 4.5 0 0 1 9 0" />
    </svg>
  `,
  projects: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.7" stroke-linecap="round" stroke-linejoin="round">
      <path d="M5 8h4l2-3 2 6 2-3h4" />
      <path d="M5 16h14" />
      <path d="M7 21h10" />
    </svg>
  `,
  hobbies: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
      <path d="M6 12a3 3 0 1 0 6 0 3 3 0 0 0-6 0Zm6 0 6-7" />
      <path d="M16 5h4v4M4 20l4-4" />
    </svg>
  `,
  media: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
      <rect x="3" y="6" width="18" height="12" rx="2" />
      <circle cx="9" cy="11" r="2.3" />
      <path d="M13 16l3.5-4 4 5" />
    </svg>
  `,
  templates: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
      <path d="M7 3h7l5 5v11a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2Z" />
      <path d="M14 3v5h5" />
      <path d="M9 13h6m-6 4h3" />
    </svg>
  `,
  archive: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
      <rect x="3" y="5" width="18" height="4" rx="1.5" />
      <path d="M5 9v7a3 3 0 0 0 3 3h8a3 3 0 0 0 3-3V9" />
      <path d="M10 13h4" />
    </svg>
  `,
  default: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="8" />
      <path d="M12 8v4l2 2" />
    </svg>
  `,
};

const cardGrid = document.querySelector("#card-grid");
const taskList = document.querySelector("#task-list");
const searchInput = document.querySelector("#search");
const copilotInput = document.querySelector("#copilot-input");
const copilotResults = document.querySelector("#copilot-results");
const copilotClearButton = document.querySelector("#copilot-clear");
const detailView = document.querySelector("#detail-view");
const detailTitle = document.querySelector("#detail-title");
const detailDescription = document.querySelector("#detail-description");
const detailTags = document.querySelector("#detail-tags");
const detailFocus = document.querySelector("#detail-focus");
const detailLinks = document.querySelector("#detail-links");
const detailRoot = document.querySelector("#detail-root");
const detailBack = document.querySelector("#detail-back");
const statElements = document.querySelectorAll("[data-stat]");
const taskSummary = document.querySelector("#task-summary");
const tabPanel = document.querySelector("#task-panel");
const taskSparkline = document.querySelector("#task-sparkline");
const resetButton = document.querySelector("#reset-tasks");
const statsCommandButton = document.querySelector("#copy-stats-command");
const actionFeedback = document.querySelector("#action-feedback");
const quickActionGrid = document.querySelector(".quick-action-grid");
const quickLaunchGrid = document.querySelector("#quick-launch-grid");
const customQuickLabelInput = document.querySelector("#custom-quick-label");
const customQuickUrlInput = document.querySelector("#custom-quick-url");
const customQuickIconInput = document.querySelector("#custom-quick-icon");
const customQuickColorInput = document.querySelector("#custom-quick-color");
const customQuickAddButton = document.querySelector("#custom-quick-add");
const xpBadge = document.querySelector("#xp-badge");
const xpLevelEl = document.querySelector("#xp-level");
const xpMetaEl = document.querySelector("#xp-meta");
const xpProgressEl = document.querySelector("#xp-progress");
const cadenceTabs = document.querySelectorAll("[data-cadence-tab]");
const checklistTabsContainer = document.querySelector(".checklist-tabs");
const playablesGrid = document.querySelector("#playables-grid");
const playablesCountElement = document.querySelector("#playables-count");
const textGameOutput = document.querySelector("#text-game-output");
const textGameForm = document.querySelector("#text-game-form");
const textGameInput = document.querySelector("#text-game-input");
const textGameStartButton = document.querySelector("#text-game-start");
const textGameStatus = document.querySelector("#text-game-status");
const textGameV2Output = document.querySelector("#text-game-v2-output");
const textGameV2Form = document.querySelector("#text-game-v2-form");
const textGameV2Input = document.querySelector("#text-game-v2-input");
const textGameV2StartButton = document.querySelector("#text-game-v2-start");
const textGameV2Status = document.querySelector("#text-game-v2-status");
const textGamePanel = document.getElementById("text-game-panel");
const textGameV2Panel = document.getElementById("text-game-v2-panel");
const textGameAutosaveToggle = document.getElementById("text-game-autosave");
const textGameV2AutosaveToggle = document.getElementById("text-game-v2-autosave");
const textGameMapOutput = document.getElementById("text-game-map-output");
const textGameV2MapOutput = document.getElementById("text-game-v2-map-output");
const npcPanel = document.getElementById("npc-panel");
const npcName = document.getElementById("npc-name");
const npcRole = document.getElementById("npc-role");
const npcQuest = document.getElementById("npc-quest");
const npcTip = document.getElementById("npc-tip");
const npcReward = document.getElementById("npc-reward");
const npcReroll = document.getElementById("npc-reroll");
const npcAvatar = document.getElementById("npc-avatar");
const npcAvatarImg = document.getElementById("npc-avatar-img");
const textGameSlotSelect = document.querySelector("#text-game-slot");
const textGameSaveStatus = document.querySelector("#text-game-save-status");
const textGameV2SlotSelect = document.querySelector("#text-game-v2-slot");
const textGameV2SaveStatus = document.querySelector("#text-game-v2-save-status");
const questTitle = document.querySelector("#quest-title");
const questSummary = document.querySelector("#quest-summary");
const questGoal = document.querySelector("#quest-goal");
const questReward = document.querySelector("#quest-reward");
const questStreak = document.querySelector("#quest-streak");
const questCompleteButton = document.querySelector("#quest-complete");
const questRerollButton = document.querySelector("#quest-reroll");

// --- LifeHub RPG: Quest & XP basics (persistent) ---------------------------

// --- Safe DOM helpers (minimal, avoid innerHTML with untrusted data) ---
function escapeHtml(str) {
  if (str == null) return "";
  return String(str)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
}

function safeSetInnerText(el, str) {
  if (!el) return;
  el.textContent = str == null ? "" : String(str);
}

function showMetaMessage(container, text, cls = "task-meta") {
  if (!container) return;
  container.textContent = "";
  const p = document.createElement("p");
  if (cls) p.className = cls;
  p.textContent = text == null ? "" : String(text);
  container.appendChild(p);
}

function safeAppendList(container, items, renderItem) {
  if (!container) return;
  container.textContent = "";
  const frag = document.createDocumentFragment();
  for (const it of items || []) {
    const li = document.createElement("li");
    li.textContent = renderItem ? String(renderItem(it)) : String(it);
    frag.appendChild(li);
  }
  container.appendChild(frag);
}

// --- localStorage schema/version helper (minimal) ---
const STORAGE_SCHEMA_VERSION = 1;

function readJsonWithMigration(key, defaultValue, migrateFn) {
  try {
    const raw = localStorage.getItem(key);
    if (!raw) return defaultValue;
    const parsed = JSON.parse(raw);
    const objVersion = parsed && typeof parsed._schema === 'number' ? parsed._schema : 0;
    if (objVersion === STORAGE_SCHEMA_VERSION) return parsed;
    if (objVersion < STORAGE_SCHEMA_VERSION && typeof migrateFn === 'function') {
      const migrated = migrateFn(parsed || {});
      try {
        migrated._schema = STORAGE_SCHEMA_VERSION;
        localStorage.setItem(key, JSON.stringify(migrated));
      } catch (e) {
        // ignore write failures
      }
      return migrated;
    }
    return parsed;
  } catch (e) {
    return defaultValue;
  }
}

const RPG_STORAGE_KEY = "lifehub-rpg-state";

function loadRpgState() {
  try {
    const raw = localStorage.getItem(RPG_STORAGE_KEY);
    if (!raw) return { xp: 0, level: 1, quests: [], achievements: [], lastUpdated: Date.now() };
    return JSON.parse(raw);
  } catch (e) {
    console.error("Failed to parse RPG state:", e);
    return { xp: 0, level: 1, quests: [], achievements: [], lastUpdated: Date.now() };
  }
}

function saveRpgState(state) {
  try {
    state.lastUpdated = Date.now();
    localStorage.setItem(RPG_STORAGE_KEY, JSON.stringify(state));
  } catch (e) {
    console.error("Failed to save RPG state:", e);
  }
}

let rpgState = loadRpgState();

function xpToLevel(xp) {
  // Simple linear progression: level N requires N*100 XP (level starts at 1)
  let level = 1;
  let remaining = xp;
  while (remaining >= level * 100) {
    remaining -= level * 100;
    level += 1;
  }
  return { level, xpInLevel: remaining, levelXpRequirement: level * 100 };
}

function updateXpBadge() {
  const info = xpToLevel(rpgState.xp || 0);
  xpLevelEl.textContent = `Lv ${info.level}`;
  xpMetaEl.textContent = `${info.xpInLevel} / ${info.levelXpRequirement} XP`;
  xpProgressEl.style.width = `${Math.floor((info.xpInLevel / info.levelXpRequirement) * 100)}%`;
}

function grantXp(amount, reason) {
  if (!Number.isFinite(amount) || amount <= 0) return;
  rpgState.xp = (rpgState.xp || 0) + Math.floor(amount);
  saveRpgState(rpgState);
  updateXpBadge();
  // lightweight toast / feedback
  if (actionFeedback) {
    actionFeedback.textContent = `+${amount} XP â€” ${reason || "reward"}`;
    setTimeout(() => { if (actionFeedback.textContent.startsWith('+')) actionFeedback.textContent = ''; }, 2500);
  }
}

function ensureDefaultQuest() {
  if (!Array.isArray(rpgState.quests)) rpgState.quests = [];
  // if no active quest, seed a gentle one
  if (!rpgState.quests.find(q => q.active)) {
    const seed = {
      id: `quest-seed-1`,
      title: "Weekly sweep",
      desc: "File 5 lingering Inbox items",
      progress: 0,
      goal: 5,
      reward: { xp: 50, badge: null },
      active: true,
      created: Date.now(),
    };
    rpgState.quests.push(seed);
    saveRpgState(rpgState);
  }
}

function getActiveQuest() {
  return (rpgState.quests || []).find(q => q.active) || null;
}

function renderActiveQuest() {
  const q = getActiveQuest();
  if (!q) {
    questTitle.textContent = "No active quest";
    questSummary.textContent = "Create a quest in the Quest log to get started.";
    questGoal.textContent = '';
    questReward.textContent = '';
    questStreak.textContent = '';
    return;
  }
  questTitle.textContent = q.title;
  questSummary.textContent = q.desc;
  questGoal.textContent = `${q.progress} / ${q.goal}`;
  questReward.textContent = q.reward && q.reward.xp ? `${q.reward.xp} XP` : '';
  questStreak.textContent = q.streak ? `Streak: ${q.streak}` : '';
}

function completeActiveQuest() {
  const q = getActiveQuest();
  if (!q) return;
  q.progress = q.goal;
  q.completedAt = Date.now();
  q.active = false;
  // award XP
  const amt = q.reward && q.reward.xp ? q.reward.xp : 0;
  if (amt > 0) grantXp(amt, `Quest: ${q.title}`);
  // record as achievement-like
  rpgState.achievements = rpgState.achievements || [];
  rpgState.achievements.push({ id: `ach-${q.id}`, title: `Completed: ${q.title}`, ts: Date.now() });
  saveRpgState(rpgState);
  renderActiveQuest();
}

// Wire quest buttons
if (questCompleteButton) {
  questCompleteButton.addEventListener('click', (e) => {
    e.preventDefault();
    completeActiveQuest();
  });
}

if (questRerollButton) {
  questRerollButton.addEventListener('click', (e) => {
    e.preventDefault();
    // simple reroll: replace active quest with a new seeded one
    const active = getActiveQuest();
    if (active) active.active = false;
    const newQ = {
      id: `quest-${Date.now()}`,
      title: "Resurface a project",
      desc: "Open an old project and add a note in Scratchpad",
      progress: 0,
      goal: 1,
      reward: { xp: 20 },
      active: true,
      created: Date.now()
    };
    rpgState.quests.push(newQ);
    saveRpgState(rpgState);
    renderActiveQuest();
  });
}

// Initialize RPG UI
ensureDefaultQuest();
updateXpBadge();
renderActiveQuest();

// Expose simple API for other modules
window.LifeHubRpg = {
  load: loadRpgState,
  save: saveRpgState,
  grantXp,
  getState: () => rpgState,
  setState: (s) => { rpgState = s; saveRpgState(rpgState); updateXpBadge(); renderActiveQuest(); },
};

// -------------------------------------------------------------------------
const achievementList = document.querySelector("#achievement-list");
const achievementSummary = document.querySelector("#achievement-summary");
const tavernLine = document.querySelector("#tavern-line");
const tavernMeta = document.querySelector("#tavern-meta");
const tavernPrevButton = document.querySelector("#tavern-prev");
const tavernNextButton = document.querySelector("#tavern-next");
const diceButtons = document.querySelector("#dice-buttons");
const diceLog = document.querySelector("#dice-log");
const diceEncounterButton = document.querySelector("#dice-encounter");
const diceLootButton = document.querySelector("#dice-loot");
const diceClearButton = document.querySelector("#dice-clear");
const encounterTracker = document.querySelector("#encounter-tracker");
const DND_INSPIRATION_KEY = "lifehub-dnd-inspiration";
const DND_BARDIC_KEY = "lifehub-dnd-bardic";
const DND_INSPIRATION_POOL_KEY = "lifehub-dnd-inspiration-pool";
const DND_BARDIC_POOL_KEY = "lifehub-dnd-bardic-pool";
const DND_BARDIC_DIE_KEY = "lifehub-dnd-bardic-die";
const DND_PROF_KEY = "lifehub-dnd-prof";
const ENCOUNTER_STATE_KEY = "lifehub-encounters";
const INVENTORY_KEY = "lifehub-inventory";
const MAX_ATTUNED = 3;
const CHARACTER_KEY = "lifehub-character";
const NPC_REWARD_CLAIM_KEY = "lifehub-npc-claim";
const SKILL_MAP = {
  acrobatics: { label: "Acrobatics", ability: "DEX" },
  animal: { label: "Animal Handling", ability: "WIS" },
  arcana: { label: "Arcana", ability: "INT" },
  athletics: { label: "Athletics", ability: "STR" },
  deception: { label: "Deception", ability: "CHA" },
  history: { label: "History", ability: "INT" },
  insight: { label: "Insight", ability: "WIS" },
  intimidation: { label: "Intimidation", ability: "CHA" },
  investigation: { label: "Investigation", ability: "INT" },
  medicine: { label: "Medicine", ability: "WIS" },
  nature: { label: "Nature", ability: "INT" },
  perception: { label: "Perception", ability: "WIS" },
  performance: { label: "Performance", ability: "CHA" },
  persuasion: { label: "Persuasion", ability: "CHA" },
  religion: { label: "Religion", ability: "INT" },
  sleight: { label: "Sleight of Hand", ability: "DEX" },
  stealth: { label: "Stealth", ability: "DEX" },
  survival: { label: "Survival", ability: "WIS" },
};
const dndInputs = {
  str: document.querySelector("#dnd-str"),
  dex: document.querySelector("#dnd-dex"),
  con: document.querySelector("#dnd-con"),
  int: document.querySelector("#dnd-int"),
  wis: document.querySelector("#dnd-wis"),
  cha: document.querySelector("#dnd-cha"),
};
const ABILITY_ORDER = ["str", "dex", "con", "int", "wis", "cha"];
const STANDARD_ARRAY = [15, 14, 13, 12, 10, 8];
const dndCheckType = document.querySelector("#dnd-check-type");
const dndSkillSelect = document.querySelector("#dnd-skill");
const dndSkillProf = document.querySelector("#dnd-skill-prof");
const dndSkillExpert = document.querySelector("#dnd-skill-expert");
const dndDcInput = document.querySelector("#dnd-dc");
const dndRollButton = document.querySelector("#dnd-roll");
const dndAdvButton = document.querySelector("#dnd-adv");
const dndDisButton = document.querySelector("#dnd-dis");
const dndClearButton = document.querySelector("#dnd-clear");
const dndInspirationToggle = document.querySelector("#dnd-inspiration");
const dndBardicToggle = document.querySelector("#dnd-bardic");
const dndProfInput = document.querySelector("#dnd-prof");
const dndInspirationPoolInput = document.querySelector("#dnd-insp-pool");
const dndInspirationAdd = document.querySelector("#dnd-insp-add");
const dndBardicPoolInput = document.querySelector("#dnd-bardic-pool");
const dndBardicDieSelect = document.querySelector("#dnd-bardic-die");
const dndBardicAdd = document.querySelector("#dnd-bardic-add");
const dndLog = document.querySelector("#dnd-log");
const miniStartButton = document.querySelector("#mini-start");
const miniResetButton = document.querySelector("#mini-reset");
const miniText = document.querySelector("#mini-text");
const miniChoices = document.querySelector("#mini-choices");
const miniScenarioSelect = document.querySelector("#mini-scenario-select");
const MINI_ADVENTURE_SCENARIO_KEY = "lifehub-mini-scenario";
const settingsModal = document.querySelector("#settings-modal");
const settingsBackdrop = document.querySelector("#settings-backdrop");
const settingsCloseButton = document.querySelector("#settings-close");
const settingsApplyButton = document.querySelector("#settings-apply");
const settingsCancelButton = document.querySelector("#settings-cancel");
const settingsThemeSelect = document.querySelector("#settings-theme");
const settingsCompactToggle = document.querySelector("#settings-compact");
const settingsCalmToggle = document.querySelector("#settings-calm");
const settingsReadableToggle = document.querySelector("#settings-readable");
const settingsShadowsToggle = document.querySelector("#settings-shadows");
const settingsPixelToggle = document.querySelector("#settings-pixel");
const settingsAutoRefreshToggle = document.querySelector("#settings-autorefresh-enabled");
const settingsAutoRefreshMinutesInput = document.querySelector("#settings-autorefresh-minutes");
const openSettingsButton = document.querySelector("#open-settings");
const textGameEventName = document.querySelector("#text-game-event-name");
const textGameEventSummary = document.querySelector("#text-game-event-summary");
const textGameEventMeta = document.querySelector("#text-game-event-meta");
const textGameEventEffect = document.querySelector("#text-game-event-effect");
const focusToggle = document.querySelector("#focus-toggle");
const kioskToggle = document.querySelector("#kiosk-toggle");
const recentGrid = document.querySelector("#recent-grid");
const recentRefreshButton = document.querySelector("#recent-refresh");
const inboxHealthChart = document.querySelector("#inbox-health-chart");
const inboxHealthSummary = document.querySelector("#inbox-health-summary");
const agendaEventsList = document.querySelector("#agenda-events");
const agendaRemindersList = document.querySelector("#agenda-reminders");
const agendaStatus = document.querySelector("#agenda-status");
const agendaDate = document.querySelector("#agenda-date");
const agendaUploadInput = document.querySelector("#agenda-upload-input");
const agendaUploadStatus = document.querySelector("#agenda-upload-status");
const agendaUploadClearButton = document.querySelector("#agenda-upload-clear");
const spotlightCard = document.querySelector("#spotlight-card");
const spotlightPrev = document.querySelector("#spotlight-prev");
const spotlightNext = document.querySelector("#spotlight-next");
const automationModal = document.querySelector("#automation-modal");
const automationListElement = document.querySelector("#automation-list");
const openAutomationButton = document.querySelector("#open-automation-modal");
const automationCloseButton = document.querySelector("#automation-close");
const AUTOMATION_SERVER_URL = "http://127.0.0.1:8766/run";
window.LIFEHUB_AUTOMATION_URL = AUTOMATION_SERVER_URL;
const automationSchedulerList = document.querySelector("#automation-scheduler-list");
const automationQueueList = document.querySelector("#automation-queue");
const automationStartButton = document.querySelector("#automation-start");
const automationClearButton = document.querySelector("#automation-clear");
const automationStatus = document.querySelector("#automation-status");
const automationLogList = document.querySelector("#automation-log");
const automationPresetsList = document.querySelector("#automation-presets-list");
const automationPresetNameInput = document.querySelector("#automation-preset-name");
const automationSavePresetButton = document.querySelector("#automation-save-preset");
const automationPresetsStatus = document.querySelector("#automation-presets-status");
const automationRunnerStatus = document.querySelector("#automation-runner-status");
const automationDryRunToggle = document.querySelector("#automation-dry-run");
const automationRunLastButton = document.querySelector("#automation-run-last");
const automationPresetImportInput = document.querySelector("#automation-preset-import");
const automationPresetExportButton = document.querySelector("#automation-preset-export");
const commandPalette = document.querySelector("#command-palette");
const commandInput = document.querySelector("#command-input");
const commandResults = document.querySelector("#command-results");
const commandCloseButton = document.querySelector("#command-close");
const readableFontToggle = document.querySelector("#readable-font-toggle");
const shadowToggle = document.querySelector("#shadow-toggle");
const settingsExportButton = document.querySelector("#settings-export");
const settingsImportInput = document.querySelector("#settings-import");
const statusReportExportButton = document.querySelector("#status-report-export");
const timelineList = document.querySelector("#activity-timeline");
const timelineEmpty = document.querySelector("#timeline-empty");
const timelineRefreshButton = document.querySelector("#timeline-refresh");
const timelineModal = document.querySelector("#timeline-modal");
const timelineModalBody = document.querySelector("#timeline-modal-body");
const timelineModalMeta = document.querySelector("#timeline-modal-meta");
const timelineModalClose = document.querySelector("#timeline-modal-close");
const triageGrid = document.querySelector("#triage-grid");
const triageResetButton = document.querySelector("#triage-reset");
const healthList = document.querySelector("#health-list");
const healthRefreshButton = document.querySelector("#health-refresh");
const downloadsList = document.querySelector("#downloads-list");
const downloadsStatus = document.querySelector("#downloads-status");
const downloadsRefreshButton = document.querySelector("#downloads-refresh");
const downloadsTriageList = document.querySelector("#downloads-triage-list");
const downloadsTriageStatus = document.querySelector("#downloads-triage-status");
const downloadsTriageRefreshButton = document.querySelector("#downloads-triage-refresh");
const resurfaceCard = document.querySelector("#resurface-card");
const resurfacePrevButton = document.querySelector("#resurface-prev");
const resurfaceNextButton = document.querySelector("#resurface-next");
const resurfaceFilter = document.querySelector("#resurface-filter");
const resurfaceSnoozeButton = document.querySelector("#resurface-snooze");
const resurfaceSkipButton = document.querySelector("#resurface-skip");
const scratchpadInput = document.querySelector("#scratchpad-input");
const scratchpadCopyButton = document.querySelector("#scratchpad-copy");
const scratchpadDownloadButton = document.querySelector("#scratchpad-download");
const scratchpadClearButton = document.querySelector("#scratchpad-clear");
const scratchpadStatus = document.querySelector("#scratchpad-status");
const scratchpadPromoteButton = document.querySelector("#scratchpad-promote");
const backupList = document.querySelector("#backup-list");
const backupRefreshButton = document.querySelector("#backup-refresh");
const backupSummary = document.querySelector("#backup-summary");
const backupNextAction = document.querySelector("#backup-next-action");
const kioskSettingsPanel = document.querySelector("#kiosk-settings");
const kioskOrderList = document.querySelector("#kiosk-order-list");
const kioskIntervalInput = document.querySelector("#kiosk-interval-input");
const kioskSettingsSaveButton = document.querySelector("#kiosk-settings-save");
const kioskPresetButtons = document.querySelectorAll("[data-kiosk-preset]");
const kioskPauseButton = document.querySelector("#kiosk-pause");
const statInsightElements = {
  lifehubSize: document.querySelector("[data-insight='lifehubSize']"),
  inboxChange: document.querySelector("[data-insight='inboxChange']"),
  actionItems: document.querySelector("[data-insight='actionItems']"),
};
const wellbeingFields = {
  source: document.querySelector("#wellbeing-source"),
  latest: document.querySelector("#wellbeing-latest"),
  stress: document.querySelector("#wellbeing-stress"),
  energy: document.querySelector("#wellbeing-energy"),
  focus: document.querySelector("#wellbeing-focus"),
  count: document.querySelector("#wellbeing-count"),
};
const wellbeingTrendSummary = document.querySelector("#wellbeing-trend-summary");
const wellbeingDeltaFields = {
  stress: document.querySelector("#wellbeing-stress-delta"),
  energy: document.querySelector("#wellbeing-energy-delta"),
  focus: document.querySelector("#wellbeing-focus-delta"),
  count: document.querySelector("#wellbeing-count-delta"),
};
const CHECKLIST_STATE_KEY = "lifehub-checklist";
const CHECKLIST_WEEK_KEY = "lifehub-checklist-week";
const CHECKLIST_HISTORY_KEY = "lifehub-checklist-history";
const STATS_COMMAND = "python3 LifeHub/scripts/update_dashboard_stats.py";
const TEXT_GAME_SOURCE_URL = "scripts/fun_text_game_base.py";
const TEXT_GAME_V2_SOURCE_URL = "scripts/fun_text_game_v2.py";
const TEXT_GAME_SAVE_PREFIX = "lifehub-game-save";
const FOCUS_SET_KEY = "lifehub-focus-cards";
const FOCUS_MODE_KEY = "lifehub-focus-mode";
const shortcutMap = {
  "/": "SEARCH",
  i: "Inbox",
  w: "Work",
  f: "Family",
  n: "Finance",
  h: "Hobbies",
  m: "Media",
  p: "Projects",
  a: "Archive",
};
const STAT_TARGETS = {
  inboxCount: 20,
  familyHealthCount: 150,
  financeCount: 250,
  projectsCount: 12,
  housingCount: 180,
  mediaCount: 600,
  archiveCount: 500,
  templatesCount: 80,
};
const INVERTED_STATS = new Set(["inboxCount"]);
const AUTOMATION_LOG_KEY = "lifehub-automation-log";
const AUTOMATION_PRESETS_KEY = "lifehub-automation-presets";
const TRIAGE_STATE_KEY = "lifehub-triage-state";
const PIXEL_MODE_KEY = "lifehub-pixel-mode";
const KONAMI_SEQUENCE = ["arrowup", "arrowup", "arrowdown", "arrowdown", "arrowleft", "arrowright", "arrowleft", "arrowright", "b", "a"];
const SCRATCHPAD_KEY = "lifehub-scratchpad";
const KIOSK_MODE_KEY = "lifehub-kiosk-mode";
const KIOSK_ORDER_KEY = "lifehub-kiosk-order";
const KIOSK_INTERVAL_KEY = "lifehub-kiosk-interval";
const AUTOMATION_DRY_RUN_KEY = "lifehub-automation-dryrun";
const AUTOMATION_LAST_QUEUE_KEY = "lifehub-automation-lastqueue";
const READABLE_FONT_KEY = "lifehub-readable-font";
const NO_SHADOWS_KEY = "lifehub-no-shadows";
const SETTINGS_EXPORT_FILENAME = "lifehub-settings.json";
const BACKUP_SEVERITY_ORDER = { ok: 0, warning: 1, danger: 2 };
const BACKUP_CADENCE_HOURS = {
  hourly: 1,
  daily: 24,
  weekly: 24 * 7,
  monthly: 24 * 30,
  quarterly: 24 * 90,
};
const QUEST_STATE_KEY = "lifehub-quest-state";
const ACHIEVEMENT_STATE_KEY = "lifehub-achievements";
const LORE_BLURBS = {
  Inbox: "The staging chamber where every relic first arrives. The archivists insist it never overflows.",
  Work: "Guild contracts, forge permits, and apprenticeshipsâ€”signed in wax and filed with care.",
  Family: "The hearth-ledger: healersâ€™ notes, school scrolls, and guardiansâ€™ pledges.",
  Finance: "The guild treasury, watched by careful ledgers and stamped receipts.",
  Housing: "Keep walls, rental oaths, and inspection runesâ€”proof the home stays defended.",
  Personal: "Identity seals, travel writs, and wellbeing sigils tuned to the bearer.",
  Projects: "Workbenches and prototypesâ€”schematics humming with potential.",
  Hobbies: "Tavern games, campaigns, and modding trinkets shared among friends.",
  Media: "Captured memories etched in light, stored in crystal panes.",
  Templates: "Reusable incantations and scrollsâ€”ready to clone for the next quest.",
  Archive: "Sealed vaults for closed chapters, sorted by year to honor the past.",
};
const QUEST_POOL = [
  {
    id: "inbox-keepers",
    title: "Archive Wardens",
    summary: "The guild archivists beg you to clear clutter from the vault.",
    goal: "File or delete 3 items from Inbox or Downloads.",
    reward: "Light of Order (+1 focus)",
  },
  {
    id: "coin-ledger",
    title: "Treasurer's Ledger",
    summary: "Balance the vault books before the night market opens.",
    goal: "Review Finance folder or log an expense.",
    reward: "Gleaming Coin (+1 luck on next roll)",
  },
  {
    id: "crafters-call",
    title: "Crafter's Call",
    summary: "Suppliers await your materials list.",
    goal: "Touch Projects or Templates â€” update one doc.",
    reward: "Workshop Pass (unlock a quick action reroll)",
  },
  {
    id: "hearth-scout",
    title: "Hearth Scout",
    summary: "Check the homestead wards before dusk.",
    goal: "Open Housing or Personal and confirm the latest docs.",
    reward: "Hearth Sigil (calm mode vibes)",
  },
  {
    id: "scribe-aid",
    title: "Scribe's Aid",
    summary: "The scribe needs a clean slate for tomorrow's decrees.",
    goal: "Empty Downloads â†’ Inbox or clear scratchpad.",
    reward: "Ink Charm (clipboard fortune)",
  },
  {
    id: "wilds-rumor",
    title: "Rumor from the Wilds",
    summary: "A traveler shares a path few remember.",
    goal: "Run a text-game command (map/help) or start the game.",
    reward: "Trail Token (map clarity)",
  },
];
const TAVERN_BANTER = [
  "â€œThe archivist swears the cleanest vault always finds the missing key.â€",
  "A bard hums: â€œThree clicks to gloryâ€”refresh, review, rejoice.â€",
  "â€œEmpty the Downloads satchel nightly; gremlins fear a tidy pack.â€",
  "The innkeeper whispers: â€œBack up your treasures; dragons love a second copy.â€",
  "â€œRumor says the map spell reveals more under a cometâ€™s light.â€",
  "A ranger notes: â€œTag the trailheadâ€”future-you thanks present-you.â€",
  "â€œQuests done before noon grant double bragging rights.â€",
  "The tinker: â€œRoll a d20 when stuck; high rolls mean ship it.â€",
];
const ENCOUNTER_TABLE = [
  "Friendly courier offering a shortcut (finish a quick action).",
  "Dusty mimic chest: choose a random folder to tidy.",
  "Traveling merchant: review Downloads and trade two files to Inbox.",
  "Silent obelisk: read one recent file and summarize it.",
  "Lost adventurer: rename a messy filename so itâ€™s clear.",
  "Wandering spirit: archive one completed project artifact.",
];
const LOOT_TABLE = [
  "Bag of Holding: pin a new quick action to the grid.",
  "Potion of Clarity: toggle Focus mode for the next sweep.",
  "Lucky Charm: reroll a quest or dice once for free.",
  "Polished Map: refresh stats to reveal new paths.",
  "Scribeâ€™s Quill: promote scratchpad to a file.",
  "Travelerâ€™s Token: open a random card detail for inspiration.",
];
const ACHIEVEMENTS = [
  {
    id: "refresh",
    title: "Fresh Data",
    description: "Run a dashboard refresh (Stats loaded).",
  },
  {
    id: "inbox-zero",
    title: "Vault Sealed",
    description: "Hit Inbox Zero (stats show 0 inbox items).",
  },
  {
    id: "triage-run",
    title: "Triage Captain",
    description: "Move an item on the triage board.",
  },
  {
    id: "quest-complete",
    title: "Questbreaker",
    description: "Complete a daily quest.",
  },
  {
    id: "easter-egg",
    title: "Pixel Phantom",
    description: "Unearth the hidden pixel mode.",
  },
];
const MINI_ADVENTURE_SETS = {
  clocktower: {
    label: "Clocktower Heist",
    nodes: {
      start: {
        text: "The clocktowerâ€™s bell will toll in 10 minutes. You and your crew stand at the rusted service door.",
        choices: [
          { label: "Pick the lock (DEX)", next: "pick" },
          { label: "Knock and bluff (CHA)", next: "bluff" },
          { label: "Look for another entrance (INT)", next: "scout" },
          { label: "Search for hidden tunnels (WIS)", next: "tunnel" },
          { label: "Climb to the roof (STR)", next: "roof" },
        ],
      },
      pick: {
        text: "Your picks scrape; a tumbler sticks.",
        choices: [
          { label: "Force it (STR)", next: "force" },
          { label: "Take a breath, try again (WIS)", next: "patient" },
        ],
      },
      bluff: {
        text: "A sleepy guard opens a slit. â€œPasscode?â€",
        choices: [
          { label: "Invent a delivery code", next: "delivery" },
          { label: "Flash a random badge", next: "badge" },
        ],
      },
      scout: {
        text: "You circle back; a narrow window is ajar above a crate.",
        choices: [
          { label: "Climb up quietly", next: "climb" },
          { label: "Send the nimble crew mate", next: "ally" },
        ],
      },
      force: {
        text: "The door groans openâ€”noise echoes. You rush inside.",
        choices: [{ label: "Dash to the stairs", next: "stairs" }],
      },
      patient: {
        text: "With care, the lock yields silently. Clean entry.",
        choices: [{ label: "Slip inside", next: "stairs" }],
      },
      delivery: {
        text: "â€œFine, leave it on the landing,â€ the guard mutters, unlatching the door.",
        choices: [{ label: "Thank him and head in", next: "stairs" }],
      },
      badge: {
        text: "He squints. â€œThat badge is outdated.â€ Tension rises.",
        choices: [
          { label: "Retreat to the alley", next: "start" },
          { label: "Double down with confidence", next: "delivery" },
        ],
      },
      climb: {
        text: "You squeeze through, dropping inside a storage loft.",
        choices: [{ label: "Find the stairs", next: "stairs" }],
      },
      ally: {
        text: "Your nimble friend slips in and unbars the door from within.",
        choices: [{ label: "Join them", next: "stairs" }],
      },
      stairs: {
        text: "Footsteps above. The bell ropes sway in the draft.",
        choices: [
          { label: "Cut the bell rope (prevent alarm)", next: "cut" },
          { label: "Climb to the gears (sabotage)", next: "gears" },
          { label: "Head to the archive room", next: "vault" },
        ],
      },
      cut: {
        text: "The rope snapsâ€”silence for now. The archive door is ahead.",
        choices: [{ label: "Enter the archive", next: "vault" }],
      },
      gears: {
        text: "You jam the gears; time stutters. A hidden panel clicks.",
        choices: [{ label: "Check the panel", next: "vault" }],
      },
      vault: {
        text: "Within the archive, the ledger you seek rests on a pedestal bathed in moonlight.",
        choices: [
          { label: "Swap it with a decoy", next: "win" },
          { label: "Grab and run", next: "chase" },
        ],
      },
      chase: {
        text: "Alarms flareâ€”the jam only bought seconds. You sprint down the stairs.",
        choices: [{ label: "Leap to the alley", next: "win" }],
      },
      win: {
        text: "You escape into the night with the ledger. The guild will sing of this heist.",
        choices: [{ label: "Play again", next: "start" }],
      },
      tunnel: {
        text: "A loose flagstone reveals a dark crawlspace leading under the tower.",
        choices: [
          { label: "Crawl through quietly", next: "crawl" },
          { label: "Send a lantern ahead", next: "lantern" },
        ],
      },
      crawl: {
        text: "Cobwebs and dust. You emerge in a forgotten archive vault.",
        choices: [
          { label: "Search the crates", next: "vault" },
          { label: "Leave a false trail", next: "stairs" },
        ],
      },
      lantern: {
        text: "Light spills forward, revealing a maintenance hatch under the stairs.",
        choices: [
          { label: "Pop the hatch", next: "stairs" },
          { label: "Snuff the lantern and listen", next: "patient" },
        ],
      },
      roof: {
        text: "The climb is rough, but the moonlit roof is clear.",
        choices: [
          { label: "Drop into the belfry", next: "stairs" },
          { label: "Signal your crew to follow", next: "ally" },
          { label: "Survey the city for an exit route", next: "gearhouse" },
        ],
      },
      gearhouse: {
        text: "From the roof you spot the gearhouse vent puffing steam.",
        choices: [
          { label: "Descend through the vent", next: "gears" },
          { label: "Mark the escape route and proceed", next: "vault" },
        ],
      },
    },
  },
  undersea: {
    label: "Under the Sea",
    nodes: {
      start: {
        text: "Bubbles drift past your mask. A coral tunnel leads toward a faint light.",
        choices: [
          { label: "Follow the light (PER)", next: "light" },
          { label: "Check the kelp-covered wreck (INV)", next: "wreck" },
          { label: "Call to dolphins (CHA)", next: "dolphins" },
        ],
      },
      light: {
        text: "A pearl lamp burns in a shell sconce. Shadows stir.",
        choices: [
          { label: "Take the lamp", next: "lamp" },
          { label: "Leave an offering", next: "offering" },
        ],
      },
      wreck: {
        text: "The wreck groans. A chest is wedged under a beam.",
        choices: [
          { label: "Lift the beam (STR)", next: "beam" },
          { label: "Cut the rope (DEX)", next: "rope" },
        ],
      },
      dolphins: {
        text: "Two curious dolphins circle you.",
        choices: [
          { label: "Ask for a tow", next: "tow" },
          { label: "Teach them a trick", next: "trick" },
        ],
      },
      lamp: {
        text: "The lamp brightensâ€”revealing a hidden trench downwards.",
        choices: [{ label: "Descend into the trench", next: "vault" }],
      },
      offering: {
        text: "The current stills. A shell opens with a tide-chart scroll.",
        choices: [{ label: "Pocket the scroll", next: "win" }],
      },
      beam: {
        text: "You wrench the beam aside. The chest pops free.",
        choices: [{ label: "Open the chest", next: "win" }],
      },
      rope: {
        text: "Your blade slips; bubbles and sand billow.",
        choices: [{ label: "Steady yourself", next: "start" }],
      },
      tow: {
        text: "With a chirp, they pull you to a shimmering grotto.",
        choices: [{ label: "Search the grotto", next: "win" }],
      },
      trick: {
        text: "They splash happily and bring you a rusted key.",
        choices: [{ label: "Find a matching lock", next: "vault" }],
      },
      vault: {
        text: "Anemone curtains part to a vault of pearl tablets.",
        choices: [
          { label: "Copy a tide rune", next: "win" },
          { label: "Swim away quietly", next: "start" },
        ],
      },
      win: {
        text: "Treasure secured! You surface with a lungful of salty victory.",
        choices: [{ label: "Play again", next: "start" }],
      },
    },
  },
  space: {
    label: "Out in Space",
    nodes: {
      start: {
        text: "You drift outside a damaged shuttle, stars wheeling silently.",
        choices: [
          { label: "Mag-clamp to the hull (DEX)", next: "hull" },
          { label: "Radio the station (CHA)", next: "radio" },
          { label: "Scan for debris (INT)", next: "scan" },
        ],
      },
      hull: {
        text: "Your clamps bite. A cracked viewport leaks vapor.",
        choices: [
          { label: "Patch it fast", next: "patch" },
          { label: "Peer inside", next: "inside" },
        ],
      },
      radio: {
        text: "Static... then a voice: â€œIdentify yourself.â€",
        choices: [
          { label: "Give real ID", next: "docking" },
          { label: "Bluff as inspector", next: "inspect" },
        ],
      },
      scan: {
        text: "Sensors ping: a toolbox and a drifting cargo crate nearby.",
        choices: [
          { label: "Grab the toolbox", next: "tools" },
          { label: "Ride the crate's momentum", next: "crate" },
        ],
      },
      patch: {
        text: "Seal holds. The cockpit hums back to life.",
        choices: [{ label: "Plot a burn to safety", next: "win" }],
      },
      inside: {
        text: "You spot a log slate and a flickering AI assistant.",
        choices: [
          { label: "Ask AI for help", next: "ai" },
          { label: "Download the log", next: "win" },
        ],
      },
      docking: {
        text: "Docking clamps extend. You coast toward safety.",
        choices: [{ label: "Debrief", next: "win" }],
      },
      inspect: {
        text: "The station hesitates. â€œSend clearance code.â€",
        choices: [{ label: "Transmit random code", next: "crate" }],
      },
      tools: {
        text: "Tools acquired. Repairs just got easier.",
        choices: [{ label: "Fix the shuttle", next: "patch" }],
      },
      crate: {
        text: "You drift toward the crateâ€”itâ€™s tagged for a research bay.",
        choices: [{ label: "Open mid-space", next: "win" }],
      },
      ai: {
        text: "AI boots. â€œCaptain, I can pilot us home.â€",
        choices: [{ label: "Let the AI handle it", next: "win" }],
      },
      win: {
        text: "Engines burn blue as you arc toward home. Mission success.",
        choices: [{ label: "Play again", next: "start" }],
      },
    },
  },
  underground: {
    label: "Underground Chase",
    nodes: {
      start: {
        text: "Youâ€™re in a torch-lit tunnel, footsteps echoing behind.",
        choices: [
          { label: "Duck into a side passage (DEX)", next: "side" },
          { label: "Knock over a cart (STR)", next: "cart" },
          { label: "Hide in the shadows (STEALTH)", next: "hide" },
        ],
      },
      side: {
        text: "The passage narrows. A faint breeze hints at an exit.",
        choices: [
          { label: "Crawl toward the breeze", next: "exit" },
          { label: "Set a tripwire", next: "trap" },
        ],
      },
      cart: {
        text: "The cart crashes, scattering ore.",
        choices: [
          { label: "Grab a chunk as a weapon", next: "weapon" },
          { label: "Sprint onward", next: "exit" },
        ],
      },
      hide: {
        text: "You blend into darkness. Guards rush past.",
        choices: [{ label: "Slip the other way", next: "vault" }],
      },
      trap: {
        text: "A guard trips, chaos erupts.",
        choices: [{ label: "Use the chaos to escape", next: "exit" }],
      },
      weapon: {
        text: "The ore chunk glows faintlyâ€”reactive crystal.",
        choices: [{ label: "Pocket it for later", next: "vault" }],
      },
      exit: {
        text: "You spot daylight through slats above.",
        choices: [
          { label: "Force the grate", next: "win" },
          { label: "Circle back underground", next: "vault" },
        ],
      },
      vault: {
        text: "A hidden storeroom of contraband maps and lockpicks.",
        choices: [
          { label: "Grab tools and go", next: "win" },
          { label: "Study the maps", next: "win" },
        ],
      },
      win: {
        text: "Fresh air hits your face. Youâ€™re freeâ€”for now.",
        choices: [{ label: "Play again", next: "start" }],
      },
    },
  },
  desert: {
    label: "Desert Island",
    nodes: {
      start: {
        text: "Shipwrecked on warm sand. Palms sway, waves lap.",
        choices: [
          { label: "Scout the beach (PER)", next: "beach" },
          { label: "Climb a palm for vantage (STR)", next: "palm" },
          { label: "Build a signal fire (INT)", next: "fire" },
        ],
      },
      beach: {
        text: "Footprintsâ€”yours? A tide pool shimmers with shells.",
        choices: [
          { label: "Search the tide pool", next: "pool" },
          { label: "Follow the footprints", next: "hut" },
        ],
      },
      palm: {
        text: "From the treetop you spot a hut inland and a reef offshore.",
        choices: [
          { label: "Head to the hut", next: "hut" },
          { label: "Swim to the reef", next: "reef" },
        ],
      },
      fire: {
        text: "Smoke curls skyward. Maybe someone will see.",
        choices: [{ label: "Keep tending it", next: "win" }],
      },
      pool: {
        text: "You find a waterproof map case wedged in rocks.",
        choices: [{ label: "Open the case", next: "win" }],
      },
      hut: {
        text: "An abandoned hut holds tools and a faded journal.",
        choices: [
          { label: "Read the journal", next: "win" },
          { label: "Take the tools", next: "win" },
        ],
      },
      reef: {
        text: "Colorful fish scatter. A sealed crate is snagged on coral.",
        choices: [{ label: "Free the crate", next: "win" }],
      },
      win: {
        text: "You stash supplies and chart a way off the island.",
        choices: [{ label: "Play again", next: "start" }],
      },
    },
  },
};

const MINI_SHARED_NODES = {
  "shadow-step": {
    text: "You melt into the shadows, flowing between beams and torchlight.",
    choices: [
      { label: "Scout ahead unseen", next: "vault" },
      { label: "Circle back to create a distraction", next: "start" },
    ],
  },
  "arcane-plan": {
    text: "Arcane sigils flicker at your fingertips. The air hums as you improvise a spell.",
    choices: [
      { label: "Weave a quick barrier and dash through", next: "win" },
      { label: "Scribe a rune to stall the guards", next: "stairs" },
    ],
  },
  diplomat: {
    text: "Words drip like honey; your charm could turn the tide.",
    choices: [
      { label: "Tell a bold tale to win trust", next: "win" },
      { label: "Bargain for a favor", next: "vault" },
    ],
  },
  "brute-force": {
    text: "You square your shoulders and let strength do the talking.",
    choices: [
      { label: "Shove through the blockade", next: "win" },
      { label: "Carry the crew over obstacles", next: "stairs" },
    ],
  },
  "gear-gambit": {
    text: "Tools click and whir as you deploy a gadget from your kit.",
    choices: [
      { label: "Rig a zipline escape", next: "win" },
      { label: "Sabotage a mechanism", next: "gears" },
    ],
  },
  "attuned-flash": {
    text: "Your attuned item thrums with power, eager to help.",
    choices: [
      { label: "Channel its energy for a shortcut", next: "win" },
      { label: "Use it to distract foes", next: "start" },
    ],
  },
  "heritage-path": {
    text: "You draw on ancestral instincts, moving with practiced grace.",
    choices: [
      { label: "Find the quiet route only your people know", next: "vault" },
      { label: "Leave a secret sign for others", next: "win" },
    ],
  },
  "lucky-break": {
    text: "A lucky break! Something goes your way for once.",
    choices: [
      { label: "Ride the momentum", next: "win" },
      { label: "Bank the luck and reset", next: "start" },
    ],
  },
};

// Mini adventure consequence tuning
const MINI_PENALTY_KEY = "lifehub-mini-penalty";
let miniPenalty =
  (function () {
    try {
      const stored = Number(localStorage.getItem(MINI_PENALTY_KEY));
      return Number.isFinite(stored) ? Math.max(0, Math.min(3, stored)) : 0;
    } catch (e) {
      return 0;
    }
  })();
const TEXT_GAME_EVENTS = [
  {
    id: "comet-pass",
    name: "Comet Pass",
    summary: "A blazing comet streaks overhead. Explorers feel sharper.",
    effect: "+1 map clarity; NPCs share rumors about treasure.",
    severity: "ok",
  },
  {
    id: "market-day",
    name: "Market Day",
    summary: "Caravans flood the roads with rare goods and gossip.",
    effect: "Merchants offer bonus trades; prices are kind.",
    severity: "ok",
  },
  {
    id: "hollow-eclipse",
    name: "Hollow Eclipse",
    summary: "Shadows lengthen; spirits stir near forgotten stones.",
    effect: "Undead favor dark corners; stealth checks shine.",
    severity: "warning",
  },
  {
    id: "festival-of-maps",
    name: "Festival of Maps",
    summary: "Cartographers swap secrets and redraw the Wilds.",
    effect: "Map command reveals extra exits and hidden paths.",
    severity: "ok",
  },
  {
    id: "deep-fog",
    name: "Deep Fog",
    summary: "Mist muffles the land; sounds carry in strange ways.",
    effect: "Navigation is trickier; insight rolls gain advantage.",
    severity: "warning",
  },
  {
    id: "lucky-ember",
    name: "Lucky Ember",
    summary: "An ember spirit trails you, nudging fate your way.",
    effect: "First failed check per encounter can be rerolled.",
    severity: "ok",
  },
];
let automationDryRun =
  (function () {
    try {
      return localStorage.getItem(AUTOMATION_DRY_RUN_KEY) === "1";
    } catch (e) {
      return false;
    }
  })();
let kioskPaused = false;
let questState = null;
let tavernIndex = 0;
let tavernTimer = null;
let achievementState = { earned: {} };
let pixelModeEnabled =
  (function () {
    try {
      return localStorage.getItem(PIXEL_MODE_KEY) === "1";
    } catch (e) {
      return false;
    }
  })();
let konamiIndex = 0;
let autoRefreshTimer = null;
let autoRefreshMinutes = 5;
let autoRefreshEnabled = true;
let autoRefreshLastRefresh = Date.now();
let autoRefreshTypingTimeout = null;
const XP_STORAGE_KEY = "lifehub_xp";
const XP_PER_LEVEL = 100;
const XP_AWARD_QUICK_ACTION = 8;
const XP_AWARD_QUICK_LAUNCH = 10;
const KIOSK_PRESETS = {
  ops: {
    order: ["search", "timeline", "downloads", "triage", "backup", "resurface"],
    disabled: [],
    label: "Ops sweep",
  },
  inbox: {
    order: ["triage", "downloads", "search"],
    disabled: ["resurface", "backup"],
    label: "Inbox focus",
  },
  showcase: {
    order: ["resurface", "timeline", "backup", "downloads", "search"],
    disabled: [],
    label: "Showcase",
  },
};
const DOWNLOAD_STALE_HOURS = 24;
const DOWNLOAD_TRIAGE_LIMIT = 5;
const DOWNLOAD_TRIAGE_MIN_AGE_HOURS = 4;
const DOWNLOAD_TRIAGE_RULES = [
  { destination: "Finance", test: /(invoice|receipt|statement|tax|paystub|bank|insurance|claim)/i, reason: "Finance keyword match" },
  { destination: "Family", test: /(clinic|medical|therapy|school|consent|report|assessment)/i, reason: "Family/health keyword match" },
  { destination: "Work", test: /(resume|cv|offer|contract|position|job)/i, reason: "Work keyword match" },
  { destination: "Projects", test: /(design|spec|prototype|draft|whirring|project)/i, reason: "Projects keyword match" },
  { destination: "Housing", test: /(lease|rental|property|mortgage|rent)/i, reason: "Housing keyword match" },
  { destination: "Personal", test: /(passport|travel|medicare|license|welltory|fitness)/i, reason: "Personal keyword match" },
];
const DOWNLOAD_TRIAGE_EXTENSION_MAP = {
  pdf: { destination: "Finance", reason: "PDF document" },
  csv: { destination: "Personal", reason: "Data export" },
  png: { destination: "Media", reason: "Image asset" },
  jpg: { destination: "Media", reason: "Image asset" },
  jpeg: { destination: "Media", reason: "Image asset" },
  heic: { destination: "Media", reason: "Photo" },
  mov: { destination: "Media", reason: "Video" },
  mp4: { destination: "Media", reason: "Video" },
  zip: { destination: "Projects", reason: "Archive" },
  doc: { destination: "Work", reason: "Document" },
  docx: { destination: "Work", reason: "Document" },
};
const RESURFACE_THRESHOLD_DAYS = 90;
const DEFAULT_AUTOMATION_PRESETS = [
  {
    id: "preset-weekly-sweep",
    name: "Weekly sweep",
    automations: ["sweep-downloads", "update-stats", "archive-quarter"],
  },
  {
    id: "preset-health-refresh",
    name: "Health refresh",
    automations: ["update-stats"],
  },
];
const WELLBEING_DELTA_META = {
  stress: { label: "Stress", decimals: 1, unit: "pts" },
  energy: { label: "Energy", decimals: 1, unit: "pts" },
  focus: { label: "Focus", decimals: 1, unit: "pts" },
  measurementCount: { label: "Measurements", decimals: 0, unit: "" },
};

let checklistState = loadChecklistState();
let checklistHistory = loadChecklistHistory();
let focusCards = new Set(loadFocusCards());
let focusModeEnabled = localStorage.getItem(FOCUS_MODE_KEY) === "true";
let kioskModeEnabled = localStorage.getItem(KIOSK_MODE_KEY) === "true";
let activeCadence = "All";
let automationQueue = [];
let automationLog = loadAutomationLog();
let automationRunning = false;
let recentFilesCache = null;
let recentFilesFlat = [];
let timelineSources = { events: [], reminders: [], files: [], automations: [], downloads: [], backups: [], wellbeing: [] };
let downloadTriageSuggestions = new Map();
let downloadsPathHint = "";
let automationPresets = loadAutomationPresets();
let triageState = loadTriageState();
let triageCards = [];
let resurfaceEntries = [];
let resurfaceIndex = 0;
let customQuickActions = loadCustomQuickActions();
const RESURFACE_SNOOZE_KEY = "lifehub-resurface-snoozed";
let resurfaceSnoozed = loadResurfaceSnoozed();
let kioskRotationTimer = null;
let draggedTriageId = null;
const TIMELINE_FILTER_KEY = "lifehub-timeline-filters";
let timelineFilters = loadTimelineFilters();
let kioskPanels = [];
let kioskActiveIndex = 0;
let searchIndex = Array.isArray(getInlineData("searchIndex")) ? getInlineData("searchIndex") : [];
let searchIndexRequested = false;
let kioskRotationInterval = Number(localStorage.getItem(KIOSK_INTERVAL_KEY)) || 8000;
let xpState = loadXpState();
let encounterState = loadEncounterState();
let inventory = loadInventory();
let miniActiveScenario =
  (function () {
    try {
      const stored = localStorage.getItem(MINI_ADVENTURE_SCENARIO_KEY);
      return stored && MINI_ADVENTURE_SETS[stored] ? stored : "clocktower";
    } catch (e) {
      return "clocktower";
    }
  })();

const encodePath = (path) => (path ? encodeURI(path) : "");
const encodeBase64Utf8 = (value) => {
  if (typeof value !== "string") return "";
  try {
    const encoder = new TextEncoder();
    const bytes = encoder.encode(value);
    let binary = "";
    bytes.forEach((byte) => {
      binary += String.fromCharCode(byte);
    });
    return btoa(binary);
  } catch (error) {
    try {
      return btoa(unescape(encodeURIComponent(value)));
    } catch {
      console.warn("Failed to encode base64 argument", error);
      return "";
    }
  }
};
async function fetchJsonWithFallback(url, { cache = "default" } = {}) {
  // When running from the file:// protocol the browser frequently blocks
  // cross-origin or local file fetches which creates noisy console errors.
  // To make LifeHub work "without you running a server", return safe
  // defaults immediately when on file:// to avoid fetch attempts.
  if (window.location && window.location.protocol === "file:") {
    console.info(`Running in file:// mode â€” skipping fetch for ${url}`);
    return {};
  }
  try {
    const response = await fetch(url, { cache });
    if (!response.ok) throw new Error(`Failed to load ${url} (${response.status})`);
    return await response.json();
  } catch (error) {
    // If fetch fails in normal HTTP(s) mode propagate the error so callers can handle it
    throw error;
  }
}

async function fetchTextWithFallback(url, { cache = "default" } = {}) {
  // Avoid attempting fetches of file:// resources which cause CORS errors in many browsers.
  if (window.location && window.location.protocol === "file:") {
    console.info(`Running in file:// mode â€” skipping text fetch for ${url}`);
    return "";
  }
  try {
    const response = await fetch(url, { cache });
    if (!response.ok) throw new Error(`Failed to load ${url} (${response.status})`);
    return await response.text();
  } catch (error) {
    throw error;
  }
}
function normalizeLinkHref(href) {
  if (!href) return "#";
  if (/^(?:[a-z]+:|\/\/)/i.test(href)) return href;
  if (href.endsWith(".html")) return href;
  const cleaned = href.replace(/\/+$/, "");
  const segments = cleaned.split("/").filter(Boolean);
  const lastSegment = segments[segments.length - 1] || "";
  if (!lastSegment || lastSegment.includes(".")) {
    return href;
  }
  return `${cleaned}/index.html`;
}
const LIFEHUB_WRAPPER = `
import io, sys, json, base64, pickle

def _lifehub_capture(func, *args):
    buf = io.StringIO()
    old_out, old_err = sys.stdout, sys.stderr
    sys.stdout = sys.stderr = buf
    keep = True
    try:
        result = func(*args)
        keep = True if result is None else bool(result)
    except Exception as exc:
        print(f"[Error] {exc}")
        keep = True
    finally:
        sys.stdout = old_out
        sys.stderr = old_err
    return buf.getvalue(), keep

def lifehub_intro():
    parts = []
    if hasattr(GAME, "intro"):
        out, _ = _lifehub_capture(GAME.intro)
        parts.append(out)
    else:
        if hasattr(GAME, "say"):
            out, _ = _lifehub_capture(GAME.say, "Welcome. Type 'help' for commands.")
            parts.append(out)
        if hasattr(GAME, "look"):
            out, _ = _lifehub_capture(GAME.look)
            parts.append(out)
        elif hasattr(GAME, "help"):
            out, _ = _lifehub_capture(GAME.help)
            parts.append(out)
    return "".join(parts)

def lifehub_command(line):
    out, keep = _lifehub_capture(GAME.dispatch, line)
    return json.dumps({"output": out, "keep_running": bool(keep)})

def lifehub_room_npcs():
    try:
        room = GAME.room()
        names = list(getattr(room, "npcs", []))
    except Exception:
        names = []
    return json.dumps(names)

def lifehub_save_state():
    return base64.b64encode(pickle.dumps(GAME)).decode("ascii")

def lifehub_load_state(payload):
    global GAME
    GAME = pickle.loads(base64.b64decode(payload))
    return lifehub_intro()
`;
let pyodideInstance = null;
let pyodideV2Instance = null;
let textGameReady = false;
let textGameLoading = false;
let textGameNpcs = [];
let textGameV2Ready = false;
let textGameV2Loading = false;
let textGameV2Npcs = [];
let textGameAutosave = false;
let textGameV2Autosave = false;
const textGameHistory = [];
let textGameHistoryIndex = 0;
const textGameV2History = [];
let textGameV2HistoryIndex = 0;
let lastTextGameOutput = "";
let lastTextGameV2Output = "";
const TEXT_GAME_AUTOSAVE_KEY = "lifehub-game-autosave";
const TEXT_GAME_V2_AUTOSAVE_KEY = "lifehub-game-autosave-v2";
const NPC_STORAGE_KEY = "lifehub-npc";
const PANEL_ICON_MAP = {
  "copilot-panel": "ðŸ”",
  "automation-scheduler-panel": "ðŸ› ï¸",
  "health-panel": "ðŸ’ ",
  "timeline-panel": "ðŸ§­",
  "recent-files-panel": "ðŸ—‚ï¸",
  "wellbeing-widget": "ðŸ’œ",
  "card-grid": "ðŸ“Œ",
  "resource-spotlight": "ðŸ”¦",
  playables: "ðŸŽ®",
  "triage-panel": "ðŸ“¥",
  "downloads-panel": "â¬‡ï¸",
  "downloads-triage-panel": "ðŸ§¹",
  "resurface-panel": "ðŸŒ€",
  "backup-panel": "ðŸ›¡ï¸",
  "text-game-panel": "ðŸ§™â€â™‚ï¸",
  "text-game-v2-panel": "ðŸ‰",
  "scratchpad-panel": "ðŸ“",
};
const STAT_ICON_MAP = {
  "Inbox items awaiting filing": "ðŸ“¬",
  "Family health records": "ðŸ©º",
  "Finance docs": "ðŸ’°",
  "Active projects (code + docs)": "ðŸ§±",
  "Housing & property files": "ðŸ ",
  "Media assets": "ðŸŽžï¸",
  "Archive entries": "ðŸ—„ï¸",
  "Templates ready": "ðŸ“„",
};
const INSPIRATION_KEY = "lh_inspiration";
const BARDIC_KEY = "lh_bardic";
let spotlightIndex = 0;
let spotlightRotation = null;
const gameSourceCache = new Map();
const commandItems = [];
const commandItemMap = new Map();
const DIRECTION_ALIASES = new Set(["n", "s", "e", "w", "north", "south", "east", "west"]);

function getWeekKey(date = new Date()) {
  const firstDay = new Date(date.getFullYear(), 0, 1);
  const pastDays = Math.floor((date - firstDay) / 86400000);
  const week = Math.ceil((pastDays + firstDay.getDay() + 1) / 7);
  return `${date.getFullYear()}-W${String(week).padStart(2, "0")}`;
}

function loadChecklistState() {
  const currentWeek = getWeekKey();
  const storedWeek = localStorage.getItem(CHECKLIST_WEEK_KEY);
  if (storedWeek !== currentWeek) {
    localStorage.setItem(CHECKLIST_WEEK_KEY, currentWeek);
    localStorage.removeItem(CHECKLIST_STATE_KEY);
    return {};
  }
  try {
    return JSON.parse(localStorage.getItem(CHECKLIST_STATE_KEY) || "{}");
  } catch {
    return {};
  }
}

function loadChecklistHistory() {
  try {
    return JSON.parse(localStorage.getItem(CHECKLIST_HISTORY_KEY) || "{}");
  } catch {
    return {};
  }
}

function saveChecklistState(state) {
  localStorage.setItem(CHECKLIST_STATE_KEY, JSON.stringify(state));
}

function saveChecklistHistory(history) {
  localStorage.setItem(CHECKLIST_HISTORY_KEY, JSON.stringify(history));
}

function loadFocusCards() {
  try {
    return JSON.parse(localStorage.getItem(FOCUS_SET_KEY) || "[]");
  } catch {
    return [];
  }
}

function saveFocusCards(set) {
  localStorage.setItem(FOCUS_SET_KEY, JSON.stringify(Array.from(set)));
}

async function loadGameSource(url, fallbackKey) {
  const cacheKey = fallbackKey || url;
  if (cacheKey && gameSourceCache.has(cacheKey)) {
    return gameSourceCache.get(cacheKey);
  }
  let source = null;
  const shouldAttemptFetch = url && window.location.protocol !== "file:";
  if (shouldAttemptFetch) {
    try {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`Failed to load game source at ${url}`);
      }
      source = (await response.text()).trim();
    } catch (error) {
      console.warn(error);
    }
  } else if (url && !source) {
    console.info(`Skipping fetch for ${url} due to unsupported protocol.`);
  }
  if (!source && fallbackKey && window.LIFEHUB_GAME_SOURCES?.[fallbackKey]) {
    source = window.LIFEHUB_GAME_SOURCES[fallbackKey].trim();
  }
  if (!source) {
    throw new Error(`Game source unavailable (${fallbackKey || url})`);
  }
  if (cacheKey) {
    gameSourceCache.set(cacheKey, source);
  }
  return source;
}

function formatDate(value) {
  if (!value) return "Never";
  try {
    const formatter = new Intl.DateTimeFormat(undefined, { month: "short", day: "numeric" });
    return formatter.format(new Date(value));
  } catch {
    return value;
  }
}

function formatBytes(bytes) {
  if (!Number.isFinite(bytes) || bytes < 0) return "--";
  if (bytes === 0) return "0 B";
  const units = ["B", "KB", "MB", "GB", "TB"];
  const index = Math.min(units.length - 1, Math.floor(Math.log(bytes) / Math.log(1024)));
  const value = bytes / Math.pow(1024, index);
  return `${value >= 100 ? Math.round(value) : value.toFixed(1)} ${units[index]}`;
}

function formatDownloadAge(ageHours) {
  const value = Number(ageHours);
  if (!Number.isFinite(value)) return "Unknown age";
  if (value < 1) return "<1h old";
  if (value < 24) return `${Math.round(value)}h old`;
  const days = Math.round(value / 24);
  return `${days} day${days === 1 ? "" : "s"} old`;
}

function formatRefreshTime(isoTimestamp) {
  if (!isoTimestamp) return "Never";
  try {
    const date = new Date(isoTimestamp);
    const now = new Date();
    const diffMs = now - date;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);
    
    if (diffMins < 1) return "just now";
    if (diffMins < 60) return `${diffMins}m ago`;
    if (diffHours < 24) return `${diffHours}h ago`;
    return `${diffDays}d ago`;
  } catch (e) {
    return "Unknown";
  }
}

function getRefreshBadgeClass(isoTimestamp) {
  if (!isoTimestamp) return "very-stale";
  try {
    const date = new Date(isoTimestamp);
    const now = new Date();
    const diffHours = (now - date) / 3600000;
    if (diffHours < 1) return "fresh";
    if (diffHours < 24) return "fresh";
    if (diffHours < 72) return "stale";
    return "very-stale";
  } catch (e) {
    return "very-stale";
  }
}

function createRefreshBadge(isoTimestamp, label = "Refreshed") {
  const badgeClass = getRefreshBadgeClass(isoTimestamp);
  const timeText = formatRefreshTime(isoTimestamp);
  return `<span class="refresh-badge ${badgeClass}" title="Last refresh: ${isoTimestamp || 'Never'}">
    <span class="refresh-badge-indicator"></span>
    <span>${label} ${timeText}</span>
  </span>`;
}

function getCurrentTextGameEventIndex() {
  const dayNumber = Math.floor(Date.now() / 86400000);
  return TEXT_GAME_EVENTS.length ? dayNumber % TEXT_GAME_EVENTS.length : -1;
}

function hoursUntilNextEvent() {
  const now = new Date();
  const next = new Date(now);
  next.setHours(24, 0, 0, 0);
  return Math.max(0, Math.round((next - now) / 36e5));
}

function renderTextGameEventBanner() {
  if (!textGameEventName || !textGameEventSummary || !textGameEventMeta || !textGameEventEffect) return;
  const index = getCurrentTextGameEventIndex();
  const event = index > -1 ? TEXT_GAME_EVENTS[index] : null;
  if (!event) {
    textGameEventName.textContent = "No events defined";
    textGameEventSummary.textContent = "Add entries to TEXT_GAME_EVENTS to rotate realm affixes.";
    textGameEventMeta.textContent = "Rotates daily.";
    textGameEventEffect.textContent = "N/A";
    textGameEventEffect.className = "status-chip";
    return;
  }
  textGameEventName.textContent = event.name || "Daily event";
  textGameEventSummary.textContent = event.summary || "";
  textGameEventEffect.textContent = event.effect || "";
  const severityClass = event.severity ? ` ${event.severity}` : "";
  textGameEventEffect.className = `status-chip${severityClass}`;
  const hoursLeft = hoursUntilNextEvent();
  textGameEventMeta.textContent = hoursLeft > 0 ? `Rotates in ~${hoursLeft}h` : "Rotates soon";
}

function togglePixelMode() {
  pixelModeEnabled = !pixelModeEnabled;
  try {
    localStorage.setItem(PIXEL_MODE_KEY, pixelModeEnabled ? "1" : "0");
  } catch (e) {}
  applyPixelModeState();
  setActionFeedback(pixelModeEnabled ? "Pixel mode: ON" : "Pixel mode: OFF");
  if (pixelModeEnabled) {
    markAchievement("easter-egg");
  }
}

function applyPixelModeState() {
  document.body.classList.toggle("pixel-mode", pixelModeEnabled);
}

function handleKonamiKey(key) {
  const normalized = (key || "").toLowerCase();
  if (!KONAMI_SEQUENCE.length) return;
  if (normalized === KONAMI_SEQUENCE[konamiIndex]) {
    konamiIndex += 1;
    if (konamiIndex === KONAMI_SEQUENCE.length) {
      togglePixelMode();
      konamiIndex = 0;
    }
  } else {
    konamiIndex = normalized === KONAMI_SEQUENCE[0] ? 1 : 0;
  }
}

function loadAutoRefreshMinutes() {
  const stored = Number(localStorage.getItem("lh_auto_refresh_minutes"));
  if (Number.isFinite(stored) && stored > 0) return stored;
  return 5;
}

function loadAutoRefreshEnabled() {
  const stored = localStorage.getItem("lh_auto_refresh_enabled");
  if (stored === "0") return false;
  return true;
}

function stopAutoRefresh() {
  if (autoRefreshTimer) {
    clearInterval(autoRefreshTimer);
    autoRefreshTimer = null;
  }
}

function startAutoRefreshTimer() {
  stopAutoRefresh();
  if (!autoRefreshEnabled) return;
  const intervalMs = autoRefreshMinutes * 60 * 1000;
  autoRefreshTimer = setInterval(performAutoRefresh, intervalMs);
}

function performAutoRefresh() {
  if (!autoRefreshEnabled) return;
  const intervalMs = autoRefreshMinutes * 60 * 1000;
  const timeSinceLastRefresh = Date.now() - autoRefreshLastRefresh;
  if (timeSinceLastRefresh < intervalMs * 0.8) return;
  autoRefreshLastRefresh = Date.now();
  Promise.all([
    loadStats().catch(() => {}),
    loadWellbeing().catch(() => {}),
    loadRecentFiles({ force: true }).catch(() => {}),
    loadDownloadsWatch({ force: true }).catch(() => {}),
  ])
    .then(() => updateAllRefreshBadges().catch(() => {}))
    .catch((error) => console.debug("Auto-refresh completed with some errors:", error));
}

function loadDisplayPreferences() {
  const get = (key) => {
    try {
      return localStorage.getItem(key);
    } catch (e) {
      return null;
    }
  };
  return {
    theme: get("lh_theme_style") || "modern",
    compact: get("lh_density_compact") === "true",
    calm: get("lh_mode_calm") === "true",
    readable: get("lh_readable_font") === "true",
    noShadows: get("lh_no_shadows") === "true",
    pixel: pixelModeEnabled,
    autoRefreshEnabled: loadAutoRefreshEnabled(),
    autoRefreshMinutes: loadAutoRefreshMinutes(),
  };
}

function applyDisplayPreferences(prefs) {
  const theme = prefs.theme || "modern";
  document.body.classList.remove("theme-modern", "theme-classic", "theme-contrast");
  if (theme !== "modern") {
    document.body.classList.add(`theme-${theme}`);
  }
  try {
    localStorage.setItem("lh_theme_style", theme);
  } catch (e) {}
  document.body.classList.toggle("density-compact", !!prefs.compact);
  document.body.classList.toggle("mode-calm", !!prefs.calm);
  document.body.classList.toggle("font-readable", !!prefs.readable);
  document.body.classList.toggle("no-shadows", !!prefs.noShadows);
  try {
    localStorage.setItem("lh_density_compact", prefs.compact ? "true" : "false");
    localStorage.setItem("lh_mode_calm", prefs.calm ? "true" : "false");
    localStorage.setItem("lh_readable_font", prefs.readable ? "true" : "false");
    localStorage.setItem("lh_no_shadows", prefs.noShadows ? "true" : "false");
  } catch (e) {}
  pixelModeEnabled = !!prefs.pixel;
  try {
    localStorage.setItem(PIXEL_MODE_KEY, pixelModeEnabled ? "1" : "0");
  } catch (e) {}
  applyPixelModeState();
  autoRefreshEnabled = !!prefs.autoRefreshEnabled;
  autoRefreshMinutes = Math.max(1, Number(prefs.autoRefreshMinutes) || 5);
  try {
    localStorage.setItem("lh_auto_refresh_enabled", autoRefreshEnabled ? "1" : "0");
    localStorage.setItem("lh_auto_refresh_minutes", String(autoRefreshMinutes));
  } catch (e) {}
  startAutoRefreshTimer();
}

function syncSettingsForm(prefs = loadDisplayPreferences()) {
  if (settingsThemeSelect) settingsThemeSelect.value = prefs.theme || "modern";
  if (settingsCompactToggle) settingsCompactToggle.checked = !!prefs.compact;
  if (settingsCalmToggle) settingsCalmToggle.checked = !!prefs.calm;
  if (settingsReadableToggle) settingsReadableToggle.checked = !!prefs.readable;
  if (settingsShadowsToggle) settingsShadowsToggle.checked = !!prefs.noShadows;
  if (settingsPixelToggle) settingsPixelToggle.checked = !!prefs.pixel;
  if (settingsAutoRefreshToggle) settingsAutoRefreshToggle.checked = !!prefs.autoRefreshEnabled;
  if (settingsAutoRefreshMinutesInput) settingsAutoRefreshMinutesInput.value = prefs.autoRefreshMinutes || 5;
}

function openSettingsDrawer() {
  if (!settingsModal) {
    const w = window.open("settings.html", "_blank");
    if (w) w.focus();
    return;
  }
  syncSettingsForm();
  settingsModal.setAttribute("aria-hidden", "false");
  document.body.classList.add("modal-open");
}

function closeSettingsDrawer() {
  if (!settingsModal) return;
  settingsModal.setAttribute("aria-hidden", "true");
  document.body.classList.remove("modal-open");
}

function getQuestTodayKey() {
  return new Date().toISOString().slice(0, 10);
}

function loadQuestState() {
  const today = getQuestTodayKey();
  let state = { date: today, completed: false, streak: 0, reroll: 0 };
  try {
    const saved = JSON.parse(localStorage.getItem(QUEST_STATE_KEY) || "{}");
    if (saved.date === today) {
      state = { ...state, ...saved };
    } else if (saved.completed) {
      state.streak = Math.max(1, Number(saved.streak) || 1);
    }
  } catch (e) {
    state = { date: today, completed: false, streak: 0, reroll: 0 };
  }
  state.date = today;
  return state;
}

function saveQuestState(state) {
  try {
    localStorage.setItem(QUEST_STATE_KEY, JSON.stringify(state));
  } catch (e) {
    console.warn("Unable to save quest state", e);
  }
}

function getQuestIndex(state) {
  const dayNumber = Math.floor(Date.now() / 86400000);
  const offset = Number(state?.reroll) || 0;
  return QUEST_POOL.length ? (dayNumber + offset) % QUEST_POOL.length : -1;
}

function renderQuestBoard() {
  if (!questTitle || !questSummary || !questGoal || !questReward || !questStreak || !questCompleteButton) return;
  if (!questState) {
    questState = loadQuestState();
  }
  const index = getQuestIndex(questState);
  const quest = index > -1 ? QUEST_POOL[index] : null;
  if (!quest) {
    questTitle.textContent = "No quests yet";
    questSummary.textContent = "Add entries to QUEST_POOL to rotate chores as adventures.";
    questGoal.textContent = "â€”";
    questReward.textContent = "â€”";
    questReward.className = "status-chip";
    questCompleteButton.disabled = true;
    questRerollButton && (questRerollButton.disabled = true);
    return;
  }
  questTitle.textContent = quest.title;
  questSummary.textContent = quest.summary;
  questGoal.textContent = quest.goal;
  questReward.textContent = quest.reward;
  questReward.className = `status-chip ${questState.completed ? "ok" : ""}`;
  questStreak.textContent = `Streak: ${questState.streak || 0}${questState.completed ? " âœ“" : ""}`;
  questCompleteButton.disabled = !!questState.completed;
  if (questCompleteButton) {
    questCompleteButton.textContent = questState.completed ? "Completed" : "Complete quest";
  }
  if (questRerollButton) {
    questRerollButton.disabled = questState.completed;
  }
}

function completeQuest() {
  if (!questState) questState = loadQuestState();
  if (questState.completed) return;
  questState.completed = true;
  questState.streak = Math.max(1, Number(questState.streak) || 0) + 1;
  saveQuestState(questState);
  renderQuestBoard();
  markAchievement("quest-complete");
}

function rerollQuest() {
  if (!questState) questState = loadQuestState();
  if (questState.completed) return;
  questState.reroll = (Number(questState.reroll) || 0) + 1;
  saveQuestState(questState);
  renderQuestBoard();
}

function loadAchievementState() {
  try {
    const parsed = JSON.parse(localStorage.getItem(ACHIEVEMENT_STATE_KEY) || "{}");
    if (parsed && typeof parsed === "object" && parsed.earned) {
      return { earned: parsed.earned };
    }
  } catch (e) {
    /* ignore */
  }
  return { earned: {} };
}

function saveAchievementState(state) {
  try {
    localStorage.setItem(ACHIEVEMENT_STATE_KEY, JSON.stringify(state));
  } catch (e) {
    console.warn("Unable to save achievements", e);
  }
}

function markAchievement(id) {
  if (!id) return;
  if (!achievementState?.earned) achievementState = { earned: {} };
  if (achievementState.earned[id]) return;
  achievementState.earned[id] = new Date().toISOString();
  saveAchievementState(achievementState);
  renderAchievements();
}

function renderAchievements() {
  if (!achievementList) return;
  const state = achievementState?.earned || {};
  const earnedCount = Object.keys(state).length;
  if (achievementSummary) {
    achievementSummary.textContent = `${earnedCount}/${ACHIEVEMENTS.length} earned`;
    achievementSummary.className = `status-chip ${earnedCount ? "ok" : ""}`;
  }
  achievementList.innerHTML = ACHIEVEMENTS.map((ach) => {
    const earnedAt = state[ach.id];
    const status = earnedAt ? "badge-earned" : "badge-locked";
    const label = earnedAt ? `Earned ${formatRefreshTime(earnedAt)}` : "Locked";
    return `
      <li class="achievement-card">
        <strong>${ach.title}</strong>
        <small>${ach.description}</small>
        <span class="${status}">${label}</span>
      </li>
    `;
  }).join("");
}

function renderTavernLine() {
  if (!tavernLine || !tavernMeta) return;
  if (!TAVERN_BANTER.length) {
    tavernLine.textContent = "No tavern tales yetâ€”add some to TAVERN_BANTER.";
    tavernMeta.textContent = "";
    return;
  }
  const index = ((tavernIndex % TAVERN_BANTER.length) + TAVERN_BANTER.length) % TAVERN_BANTER.length;
  tavernLine.textContent = TAVERN_BANTER[index];
  tavernMeta.textContent = `Line ${index + 1} of ${TAVERN_BANTER.length} Â· rotates every 7s`;
}

function startTavernRotation() {
  renderTavernLine();
  if (tavernTimer) clearInterval(tavernTimer);
  tavernTimer = setInterval(() => {
    tavernIndex = (tavernIndex + 1) % Math.max(1, TAVERN_BANTER.length || 1);
    renderTavernLine();
  }, 7000);
}

function rollDie(sides) {
  if (!Number.isFinite(sides) || sides <= 0) return 0;
  return Math.floor(Math.random() * sides) + 1;
}

function logDiceResult(text) {
  if (!diceLog) return;
  if (!diceLog.dataset.hasEntries) {
    diceLog.innerHTML = "";
    diceLog.dataset.hasEntries = "1";
  }
  const li = document.createElement("li");
  li.textContent = text;
  diceLog.prepend(li);
  const items = Array.from(diceLog.querySelectorAll("li"));
  items.slice(10).forEach((item) => item.remove());
}

function rollEncounter() {
  const roll = rollDie(ENCOUNTER_TABLE.length);
  const entry = ENCOUNTER_TABLE[roll - 1] || "Mysterious silence.";
  logDiceResult(`Encounter (d${ENCOUNTER_TABLE.length}â†’${roll}): ${entry}`);
}

function rollLoot() {
  const roll = rollDie(LOOT_TABLE.length);
  const entry = LOOT_TABLE[roll - 1] || "Empty satchel.";
  logDiceResult(`Loot (d${LOOT_TABLE.length}â†’${roll}): ${entry}`);
}

function clearDiceLog() {
  if (!diceLog) return;
  diceLog.innerHTML = "<li>Awaiting your first roll.</li>";
  delete diceLog.dataset.hasEntries;
}

function readAbilityMod(key) {
  const input = dndInputs[key.toLowerCase()];
  if (!input) return 0;
  const score = Number(input.value);
  if (!Number.isFinite(score)) return 0;
  // Convert 5e ability score to modifier (e.g., 15 -> +2)
  return Math.floor((score - 10) / 2);
}

function getAbilityScores() {
  return ABILITY_ORDER.map((key) => Number(dndInputs[key]?.value));
}

function applyStandardArray() {
  ABILITY_ORDER.forEach((key, index) => {
    if (dndInputs[key]) {
      dndInputs[key].value = STANDARD_ARRAY[index];
    }
  });
}

function abilityScoresMatchStandardArray(scores) {
  if (!Array.isArray(scores) || scores.length !== STANDARD_ARRAY.length) return false;
  const normalized = scores.map((v) => Number.isFinite(v) ? Math.round(v) : NaN);
  if (normalized.some((v) => !Number.isFinite(v))) return false;
  const sorted = normalized.slice().sort((a, b) => b - a);
  const target = STANDARD_ARRAY.slice().sort((a, b) => b - a);
  return sorted.every((val, idx) => val === target[idx]);
}

function enforceLegalAbilityScores({ silent = false } = {}) {
  const scores = getAbilityScores();
  const withinBounds = scores.every((v) => Number.isFinite(v) && v >= 3 && v <= 18);
  if (withinBounds && abilityScoresMatchStandardArray(scores)) {
    return;
  }
  applyStandardArray();
  if (!silent) {
    setActionFeedback("Ability scores reset to the standard array for 5e legality.");
  }
}

function persistDndToggleState(storageKey, element) {
  if (!element) return;
  try {
    localStorage.setItem(storageKey, element.checked ? "1" : "0");
  } catch (e) {}
}

function hydrateDndToggle(element, storageKey) {
  if (!element) return;
  const saved = localStorage.getItem(storageKey);
  if (saved === "1") {
    element.checked = true;
  }
  element.addEventListener("change", () => persistDndToggleState(storageKey, element));
}

function logDndResult(text) {
  if (!dndLog) return;
  if (!dndLog.dataset.hasEntries) {
    dndLog.innerHTML = "";
    dndLog.dataset.hasEntries = "1";
  }
  const li = document.createElement("li");
  li.textContent = text;
  dndLog.prepend(li);
  const items = Array.from(dndLog.querySelectorAll("li"));
  items.slice(12).forEach((item) => item.remove());
}

function rollDndCheck({ mode = "normal" } = {}) {
  if (!dndCheckType || !dndDcInput) return;
  let ability = (dndCheckType.value || "STR").toUpperCase();
  let checkLabel = ability;
  let profBonus = 0;
  const skillKey = (dndSkillSelect?.value || "").trim();
  if (skillKey) {
    const skill = getSkillConfig(skillKey);
    if (skill) {
      ability = skill.ability.toUpperCase();
      checkLabel = skill.label;
      const prof = readProficiencyBonus();
      const expert = !!dndSkillExpert?.checked;
      const profChecked = !!dndSkillProf?.checked || expert;
      if (profChecked && prof) {
        profBonus = prof * (expert ? 2 : 1);
      }
    }
  }
  const dc = Number(dndDcInput.value) || 10;
  const mod = readAbilityMod(ability) + profBonus;
  const rolls = [rollDie(20)];
  if (mode === "adv" || mode === "dis") rolls.push(rollDie(20));
  let inspirationUsed = false;
  let bardicUsed = false;
  const inspPool = getPoolValue(dndInspirationPoolInput);
  if (dndInspirationToggle?.checked && inspPool > 0) {
    rolls.push(rollDie(20));
    inspirationUsed = true;
    setPoolValue(dndInspirationPoolInput, DND_INSPIRATION_POOL_KEY, inspPool - 1);
    dndInspirationToggle.checked = false;
    persistDndToggleState(DND_INSPIRATION_KEY, dndInspirationToggle);
  } else if (dndInspirationToggle?.checked && inspPool <= 0) {
    setActionFeedback("No inspiration in the pool.");
  }
  const bardicPool = getPoolValue(dndBardicPoolInput);
  const bardicDie = Number(dndBardicDieSelect?.value) || 6;
  const bardicBonus =
    dndBardicToggle?.checked && bardicPool > 0 ? rollDie(Math.max(4, bardicDie)) : 0;
  if (bardicBonus) {
    bardicUsed = true;
    setPoolValue(dndBardicPoolInput, DND_BARDIC_POOL_KEY, bardicPool - 1);
    dndBardicToggle.checked = false;
    persistDndToggleState(DND_BARDIC_KEY, dndBardicToggle);
  } else if (dndBardicToggle?.checked && bardicPool <= 0) {
    setActionFeedback("No bardic dice left.");
  }
  let used = rolls[0];
  if (mode === "dis") {
    used = Math.min(...rolls);
  } else if (mode === "adv" || inspirationUsed || rolls.length > 1) {
    used = Math.max(...rolls);
  }
  const total = used + mod + bardicBonus;
  const success = total >= dc;
  const tags = [];
  if (mode === "adv") tags.push("adv");
  if (mode === "dis") tags.push("dis");
  if (inspirationUsed) tags.push("insp");
  if (profBonus) tags.push("prof");
  const tagText = tags.length ? ` (${tags.join(" + ")})` : "";
  const detail = rolls.length > 1 ? ` [${rolls.join(", ")}]` : "";
  const pieces = [`${checkLabel} check${tagText}:`, `d20 ${used}${detail}`, `${mod >= 0 ? "+" : ""}${mod}`];
  if (bardicBonus) pieces.push(`+ bardic ${bardicBonus}`);
  pieces.push(`= ${total}`, "â†’", success ? "SUCCESS" : "fail", `vs DC ${dc}`);
  logDndResult(pieces.join(" "));
  if (inspirationUsed) {
    showToast({ icon: "âœ¨", label: "Inspiration used", meta: `Rolls ${rolls.join(" / ")}` });
  }
  if (bardicUsed) {
    showToast({ icon: "ðŸŽ¶", label: `Bardic +${bardicBonus}`, meta: `Total ${total}` });
  }
}

function clearDndLog() {
  if (!dndLog) return;
  dndLog.innerHTML = "<li>Ready for a check.</li>";
  delete dndLog.dataset.hasEntries;
}

function setupMiniAdventureSelector() {
  if (!miniStartButton && !miniResetButton) return;
  let select = miniScenarioSelect;
  if (!select) {
    select = document.createElement("select");
    select.id = "mini-scenario-select";
    select.className = "mini-scenario-select";
  }
  select.innerHTML = Object.entries(MINI_ADVENTURE_SETS)
    .map(([key, entry]) => `<option value="${key}">${entry.label}</option>`)
    .join("") + `<option value="random">ðŸŽ² Roll random</option>`;
  select.value = MINI_ADVENTURE_SETS[miniActiveScenario] ? miniActiveScenario : "clocktower";
  select.addEventListener("change", () => {
    const choice = select.value;
    if (choice === "random") {
      rollRandomMiniScenario();
      return;
    }
    setMiniScenario(choice, { render: true });
  });
  const host =
    miniStartButton?.parentElement ||
    miniResetButton?.parentElement ||
    miniText?.parentElement ||
    document.querySelector("#mini-panel");
  if (host && !select.parentElement) {
    host.insertBefore(select, miniStartButton || host.firstChild);
  }
  let randomButton = document.querySelector("#mini-scenario-roll");
  if (!randomButton) {
    randomButton = document.createElement("button");
    randomButton.type = "button";
    randomButton.id = "mini-scenario-roll";
    randomButton.className = "ghost";
    randomButton.textContent = "Roll random adventure";
    randomButton.addEventListener("click", () => rollRandomMiniScenario());
    if (host) {
      host.insertBefore(randomButton, (miniStartButton || select).nextSibling);
    }
  }
}

function getActiveMiniNodes() {
  return MINI_ADVENTURE_SETS[miniActiveScenario]?.nodes || MINI_ADVENTURE_SETS.clocktower.nodes;
}

function getMiniNode(key) {
  const nodes = getActiveMiniNodes();
  return nodes[key] || MINI_SHARED_NODES[key] || nodes.start || MINI_SHARED_NODES.start;
}

function getScenarioWinKey() {
  const nodes = getActiveMiniNodes();
  if (nodes.win) return "win";
  if (nodes.vault) return "vault";
  return "start";
}

function getCharacterContext() {
  const char = loadCharacter();
  const stats = {
    str: Number(dndInputs?.str?.value) || 0,
    dex: Number(dndInputs?.dex?.value) || 0,
    con: Number(dndInputs?.con?.value) || 0,
    int: Number(dndInputs?.int?.value) || 0,
    wis: Number(dndInputs?.wis?.value) || 0,
    cha: Number(dndInputs?.cha?.value) || 0,
  };
  const bestStatKey = Object.entries(stats).sort((a, b) => b[1] - a[1])[0]?.[0] || "str";
  const bestStatScore = stats[bestStatKey];
  const inv = Array.isArray(inventory) ? inventory : [];
  const hasWeapon = inv.some((item) => item.type === "weapon");
  const hasArmor = inv.some((item) => item.type === "armor");
  const hasAttuned = inv.some((item) => item.attuned);
  const classLabel = (char.cls || char.class || "").toString();
  const raceLabel = (char.race || "").toString();
  const flavorParts = [];
  if (char.name) flavorParts.push(char.name);
  if (classLabel || raceLabel) flavorParts.push([raceLabel, classLabel].filter(Boolean).join(" "));
  flavorParts.push(`favored stat: ${bestStatKey.toUpperCase()} ${bestStatScore || 0}`);
  return {
    name: char.name || "",
    cls: classLabel,
    race: raceLabel,
    stats,
    bestStatKey,
    bestStatScore,
    hasWeapon,
    hasArmor,
    hasAttuned,
    inventory: inv,
    flavor: flavorParts.filter(Boolean).join(" Â· "),
  };
}

function buildDynamicMiniChoices(nodeKey, node, context) {
  const choices = [];
  const addChoice = (label, next) => {
    if (!label || !next) return;
    choices.push({ label, next });
  };
  const cls = context.cls.toLowerCase();
  const race = context.race.toLowerCase();
  if (cls.match(/rogue|ranger|monk|assassin/) || context.stats.dex >= 15) {
    addChoice("Slip into the shadows (DEX)", "shadow-step");
  }
  if (cls.match(/wizard|sorcerer|warlock|mage/) || context.stats.int >= 14) {
    addChoice("Cast a quick ritual (INT)", "arcane-plan");
  }
  if (cls.match(/bard|singer|diplomat/) || context.stats.cha >= 14) {
    addChoice("Charm or negotiate (CHA)", "diplomat");
  }
  if (cls.match(/barbarian|fighter|paladin/) || context.stats.str >= 15) {
    addChoice("Muscle through it (STR)", "brute-force");
  }
  if (context.hasWeapon) {
    addChoice("Brandish your weapon", "gear-gambit");
  }
  if (context.hasArmor) {
    addChoice("Shield the team with your armor", "brute-force");
  }
  if (context.hasAttuned) {
    addChoice("Channel an attuned item", "attuned-flash");
  }
  if (race.includes("elf") || race.includes("dwarf") || race.includes("halfling")) {
    addChoice("Lean on your heritage instincts", "heritage-path");
  }
  if ((node?.choices || []).length < 2) {
    addChoice("Improvise a wild shortcut", "lucky-break");
    addChoice("Regroup and rethink", "start");
  }
  return choices;
}

function setMiniScenario(key, { render = false } = {}) {
  const next = MINI_ADVENTURE_SETS[key] ? key : "clocktower";
  miniActiveScenario = next;
  try {
    localStorage.setItem(MINI_ADVENTURE_SCENARIO_KEY, next);
  } catch (e) {}
  const select = miniScenarioSelect || document.querySelector("#mini-scenario-select");
  if (select) select.value = next;
  if (render) {
    renderMiniNode("start");
    setActionFeedback(`Mini adventure set: ${MINI_ADVENTURE_SETS[next].label}`);
  }
}

function rollRandomMiniScenario() {
  const keys = Object.keys(MINI_ADVENTURE_SETS);
  if (!keys.length) return;
  const next = keys[Math.floor(Math.random() * keys.length)];
  setMiniScenario(next, { render: true });
}

function renderMiniNode(key) {
  if (!miniText || !miniChoices) return;
  const nodes = getActiveMiniNodes();
  const node = getMiniNode(key);
  const context = getCharacterContext();
  miniText.textContent = node.text || "â€”";
  if (context.flavor) {
    const meta = document.createElement("small");
    meta.className = "task-meta";
    meta.textContent = `Playing as: ${context.flavor}`;
    miniText.appendChild(meta);
  }
  miniChoices.innerHTML = "";
  const combinedChoices = (() => {
    const base = Array.isArray(node.choices) ? node.choices : [];
    const dynamic = buildDynamicMiniChoices(key, node, context);
    const seen = new Set();
    return [...base, ...dynamic].filter((choice) => {
      const label = choice?.label || "";
      if (!label) return false;
      if (seen.has(label)) return false;
      seen.add(label);
      return true;
    });
  })();
  const effectiveChoices = combinedChoices.length
    ? combinedChoices
    : [{ label: "Restart", next: "start" }];
  ensureMiniRollArea();
  effectiveChoices.forEach((choice) => {
    const btn = document.createElement("button");
    btn.type = "button";
    btn.textContent = choice.label || "Continue";
    btn.addEventListener("click", () => {
      const rollResult = performMiniSkillCheck(choice.label || "");
      if (rollResult) {
        renderMiniRollResult(rollResult);
        applyMiniConsequences(rollResult);
      }
      renderMiniNode(choice.next);
    });
    miniChoices.appendChild(btn);
  });
}

function saveMiniPenalty() {
  try {
    localStorage.setItem(MINI_PENALTY_KEY, String(miniPenalty));
  } catch (e) {
    /* ignore */
  }
}

function applyMiniConsequences(result) {
  if (!result) return;
  if (result.success) {
    const eased = miniPenalty > 0;
    miniPenalty = Math.max(0, miniPenalty - 1);
    saveMiniPenalty();
    awardXp(6, `Mini adventure success (${result.label || result.ability})`);
    setActionFeedback(`Success! +6 XP${eased ? " Â· tension eased (-1 penalty)" : ""}`);
  } else {
    miniPenalty = Math.min(3, miniPenalty + 1);
    saveMiniPenalty();
    setActionFeedback(`Complication! Future checks suffer -${miniPenalty} penalty.`);
  }
}

function ensureMiniRollArea() {
  let rollBox = document.querySelector("#mini-roll-result");
  if (!rollBox) {
    rollBox = document.createElement("div");
    rollBox.id = "mini-roll-result";
    rollBox.className = "status-chip neutral";
    rollBox.style.marginTop = "0.35rem";
    rollBox.style.display = "inline-block";
    miniChoices?.insertAdjacentElement("afterend", rollBox);
  }
  ensureMiniRollStyles();
}

function mapSkillLabelToAbility(label = "") {
  const upper = label.toUpperCase();
  if (upper.includes("STR")) return "str";
  if (upper.includes("DEX")) return "dex";
  if (upper.includes("CON")) return "con";
  if (upper.includes("INT")) return "int";
  if (upper.includes("WIS")) return "wis";
  if (upper.includes("CHA")) return "cha";
  if (upper.includes("PER")) return "wis"; // perception style
  if (upper.includes("INV")) return "int"; // investigation style
  if (upper.includes("STEALTH")) return "dex";
  if (upper.includes("ATHLETIC")) return "str";
  return null;
}

function performMiniSkillCheck(label = "") {
  const abilityKey = mapSkillLabelToAbility(label);
  if (!abilityKey) return null;
  const dc = 12;
  const mod = readAbilityMod(abilityKey) || 0;
  const roll = rollDie(20);
  const penaltyApplied = Math.max(0, Math.min(3, Number(miniPenalty) || 0));
  const total = roll + mod - penaltyApplied;
  const success = total >= dc;
  return {
    label,
    ability: abilityKey.toUpperCase(),
    roll,
    mod,
    penaltyApplied,
    total,
    dc,
    success,
  };
}

function renderMiniRollResult(result) {
  const rollBox = document.querySelector("#mini-roll-result");
  if (!rollBox) return;
  const { label, ability, roll, mod, total, dc, success } = result;
  rollBox.className = `status-chip ${success ? "success" : "warning"}`;
  const modText = `${mod >= 0 ? "+" : ""}${mod}`;
  const penaltyText = result.penaltyApplied ? ` - penalty ${result.penaltyApplied}` : "";
  rollBox.textContent = `${label || "Check"}: d20 ${roll} ${modText}${penaltyText} = ${total} vs DC ${dc} â†’ ${success ? "PASS" : "FAIL"}`;
}

function ensureMiniRollStyles() {
  if (document.getElementById("mini-roll-style")) return;
  const style = document.createElement("style");
  style.id = "mini-roll-style";
  style.textContent = `
    #mini-roll-result {
      background: #ffffff !important;
      color: #0f172a !important;
      border: 1px solid var(--border-strong, #d1d5db);
      font-weight: 700;
      font-size: 1.05rem;
      padding: 0.45rem 0.8rem;
      border-radius: 12px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.18);
      letter-spacing: 0.01em;
    }
    #mini-roll-result.success {
      color: #166534 !important;
      border-color: #22c55e;
    }
    #mini-roll-result.warning {
      color: #b45309 !important;
      border-color: #f59e0b;
    }
  `;
  document.head.appendChild(style);
}

function parseBackupCadenceHours(frequency) {
  if (!frequency) return null;
  const key = String(frequency || "").toLowerCase().trim();
  if (BACKUP_CADENCE_HOURS[key]) return BACKUP_CADENCE_HOURS[key];
  if (key.includes("hour")) return 1;
  if (key.includes("day")) return 24;
  if (key.includes("week")) return 24 * 7;
  if (key.includes("month")) return 24 * 30;
  if (key.includes("quarter")) return 24 * 90;
  const numericHours = Number.parseFloat(key);
  if (Number.isFinite(numericHours) && numericHours > 0) return numericHours;
  return null;
}

function formatBackupDuration(hours) {
  if (!Number.isFinite(hours)) return "unknown";
  const abs = Math.abs(hours);
  if (abs < 1) return "<1h";
  const days = Math.floor(abs / 24);
  const remainingHours = Math.round(abs % 24);
  if (days >= 1) {
    return remainingHours >= 6 ? `${days}d ${remainingHours}h` : `${days}d`;
  }
  return `${Math.round(abs)}h`;
}

function describeBackupDestination(destination, now = Date.now()) {
  const last = destination?.lastBackup ? new Date(destination.lastBackup) : null;
  const ageHours = last instanceof Date && !Number.isNaN(last) ? (now - last.getTime()) / 36e5 : Infinity;
  const cadenceHours = parseBackupCadenceHours(destination?.frequency) ?? 72;
  const ratio = Number.isFinite(ageHours) && Number.isFinite(cadenceHours) ? ageHours / cadenceHours : Infinity;
  let state = "ok";
  if (!Number.isFinite(ageHours)) {
    state = "danger";
  } else if (ratio > 1.5) {
    state = "danger";
  } else if (ratio > 1) {
    state = "warning";
  }
  if (destination?.status && BACKUP_SEVERITY_ORDER[destination.status] > BACKUP_SEVERITY_ORDER[state]) {
    state = destination.status;
  }
  const dueInHours = Number.isFinite(cadenceHours) && Number.isFinite(ageHours) ? cadenceHours - ageHours : NaN;
  const ageLabel = Number.isFinite(ageHours) ? formatRefreshTime(last?.toISOString?.()) : "Unknown";
  const dueLabel = Number.isFinite(dueInHours)
    ? dueInHours > 0
      ? `Due in ${formatBackupDuration(dueInHours)}`
      : `Overdue by ${formatBackupDuration(Math.abs(dueInHours))}`
    : "Due date unknown";
  const stateLabel = state === "danger" ? "Overdue" : state === "warning" ? "Due soon" : "Healthy";
  const progress = Number.isFinite(ageHours) && Number.isFinite(cadenceHours)
    ? Math.max(0, Math.min(140, Math.round((ageHours / cadenceHours) * 100)))
    : 140;
  return { destination, last, ageHours, cadenceHours, ratio, state, stateLabel, ageLabel, dueLabel, dueInHours, progress };
}

function updateRefreshBadges(stats, recentFiles, welltory, downloads) {
  // Update stats refresh badge
  const statsWidget = document.querySelector('[data-panel="stats"] .panel-header');
  if (statsWidget && stats?.generatedAt) {
    const existing = statsWidget.querySelector('.refresh-badge');
    if (existing) existing.remove();
    statsWidget.insertAdjacentHTML('beforeend', createRefreshBadge(stats.generatedAt, 'Stats'));
  }
  
  // Update recent files refresh badge
  const recentWidget = document.getElementById('recent-files-panel');
  if (recentWidget && recentFiles?.generatedAt) {
    const header = recentWidget.querySelector('.panel-header');
    if (header) {
      const existing = header.querySelector('.refresh-badge');
      if (existing) existing.remove();
      header.insertAdjacentHTML('beforeend', createRefreshBadge(recentFiles.generatedAt, 'Files'));
    }
  }
  
  // Update wellbeing refresh badge
  const wellbeingWidget = document.getElementById('wellbeing-widget');
  if (wellbeingWidget && welltory?.updatedAt) {
    const header = wellbeingWidget.querySelector('.panel-header');
    if (header) {
      const existing = header.querySelector('.refresh-badge');
      if (existing) existing.remove();
      header.insertAdjacentHTML('beforeend', createRefreshBadge(welltory.updatedAt, 'Welltory'));
    }
  }
  
  // Update downloads refresh badge
  const downloadsWidget = document.getElementById('downloads-panel');
  if (downloadsWidget && downloads?.generatedAt) {
    const header = downloadsWidget.querySelector('.panel-header');
    if (header) {
      const existing = header.querySelector('.refresh-badge');
      if (existing) existing.remove();
      header.insertAdjacentHTML('beforeend', createRefreshBadge(downloads.generatedAt, 'Downloads'));
    }
  }
}

function setupAutoRefresh(intervalMinutes = 5) {
  autoRefreshMinutes = Math.max(1, intervalMinutes);
  autoRefreshEnabled = loadAutoRefreshEnabled();
  autoRefreshLastRefresh = Date.now();
  startAutoRefreshTimer();

  window.stopAutoRefresh = stopAutoRefresh;
  window.restartAutoRefresh = startAutoRefreshTimer;

  // Pause auto-refresh when user is typing (don't refresh during active work)
  document.addEventListener(
    "input",
    () => {
      stopAutoRefresh();
      clearTimeout(autoRefreshTypingTimeout);
      autoRefreshTypingTimeout = setTimeout(() => {
        startAutoRefreshTimer();
      }, 60000); // Resume after 1 minute of inactivity
    },
    true
  );

  console.log(`Auto-refresh ${autoRefreshEnabled ? "enabled" : "disabled"}: every ${autoRefreshMinutes} minutes`);
}

function updateTaskSummary() {
  if (!taskSummary) return;
  const sourceTasks = activeCadence === "All" ? tasks : tasks.filter((task) => task.cadence === activeCadence);
  const total = sourceTasks.length;
  const completed = sourceTasks.filter((task) => checklistState[task.id]).length;
  const label = activeCadence === "All" ? "tasks" : `${activeCadence.toLowerCase()} tasks`;
  taskSummary.textContent = total ? `${completed}/${total} ${label} completed` : `No ${label} to track`;
}

function setActionFeedback(message) {
  if (actionFeedback) {
    actionFeedback.textContent = message;
  }
}

function loadXpState() {
  try {
    const parsed = JSON.parse(localStorage.getItem(XP_STORAGE_KEY) || "{}");
    if (!parsed || typeof parsed !== "object") return { xp: 0 };
    return { xp: Number(parsed.xp) || 0 };
  } catch (error) {
    console.warn("Failed to load XP state", error);
    return { xp: 0 };
  }
}

function saveXpState(state) {
  try {
    localStorage.setItem(XP_STORAGE_KEY, JSON.stringify(state));
  } catch (e) {}
}

function getLevelFromXp(xp = 0) {
  return Math.floor(Math.max(0, xp) / XP_PER_LEVEL) + 1;
}

function getLevelBounds(level = 1) {
  const prev = Math.max(0, (level - 1) * XP_PER_LEVEL);
  const next = level * XP_PER_LEVEL;
  return { prev, next, span: Math.max(1, next - prev) };
}

function renderXpBadge() {
  const totalXp = Math.max(0, xpState?.xp || 0);
  const level = getLevelFromXp(totalXp);
  renderCharacterCard(level);
  if (!xpBadge || !xpLevelEl || !xpMetaEl || !xpProgressEl) return;
  const { prev, next, span } = getLevelBounds(level);
  const progress = totalXp - prev;
  const percent = Math.min(100, Math.max(0, (progress / span) * 100));
  xpLevelEl.textContent = `Lv ${level}`;
  xpMetaEl.textContent = `${progress} / ${span} XP`;
  xpProgressEl.style.width = `${percent}%`;
  xpBadge.setAttribute("title", `${totalXp} XP total`);
}


function loadCharacter() {
  try {
    const parsed = JSON.parse(localStorage.getItem(CHARACTER_KEY) || '{}');
    if (!parsed || typeof parsed !== 'object') return {};
    return {
      name: parsed.name || '',
      race: parsed.race || '',
      cls: parsed.cls || parsed.class || '',
      notes: parsed.notes || '',
    };
  } catch (e) {
    return {};
  }
}

function saveCharacter(state) {
  try {
    localStorage.setItem(CHARACTER_KEY, JSON.stringify(state || {}));
  } catch (e) {}
}

function renderCharacterCard(level = 1) {
  const card = document.querySelector('#character-card');
  if (!card) return;
  const { name = '', race = '', cls = '', notes = '' } = loadCharacter();
  const nameEl = document.querySelector('#character-name');
  const lineageEl = document.querySelector('#character-lineage');
  const notesEl = document.querySelector('#character-notes');
  const levelEl = document.querySelector('#character-level');
  nameEl && (nameEl.textContent = name || 'Unassigned');
  lineageEl && (lineageEl.textContent = race || cls ? `${race || 'Race'} / ${cls || 'Class'}` : 'Race / Class');
  notesEl && (notesEl.textContent = notes ? `Background: ${notes}` : 'Background: â€”');
  if (levelEl) levelEl.textContent = `Lv ${level}`;
}

function awardXp(amount = 0, reason = "") {
  const delta = Math.max(0, Math.round(amount));
  if (!delta) return;
  xpState = { xp: Math.max(0, (xpState?.xp || 0) + delta) };
  saveXpState(xpState);
  renderXpBadge();
  if (reason) setActionFeedback(`+${delta} XP â€” ${reason}`);
}

function readProficiencyBonus() {
  const val = Number(dndProfInput?.value);
  return Number.isFinite(val) ? val : 0;
}

function persistNumberInput(key, input) {
  if (!input) return;
  const val = Number(input.value);
  try {
    localStorage.setItem(key, String(Number.isFinite(val) ? val : 0));
  } catch (e) {}
}

function hydrateNumberInput(input, key, fallback = 0) {
  if (!input) return fallback;
  const saved = Number(localStorage.getItem(key));
  const value = Number.isFinite(saved) ? saved : fallback;
  input.value = value;
  input.addEventListener("change", () => persistNumberInput(key, input));
  return value;
}

function getSkillConfig(key) {
  return SKILL_MAP[key] || null;
}

function getPoolValue(input) {
  const val = Number(input?.value);
  return Number.isFinite(val) ? Math.max(0, val) : 0;
}

function setPoolValue(input, key, value) {
  if (!input) return;
  const next = Math.max(0, Number(value) || 0);
  input.value = next;
  try {
    localStorage.setItem(key, String(next));
  } catch (e) {}
}

function loadEncounterState() {
  try {
    const parsed = JSON.parse(localStorage.getItem(ENCOUNTER_STATE_KEY) || "{}");
    return {
      inbox: Math.max(0, Math.min(10, Number(parsed.inbox) || 0)),
      downloads: Math.max(0, Math.min(10, Number(parsed.downloads) || 0)),
    };
  } catch (e) {
    return { inbox: 0, downloads: 0 };
  }
}

function saveEncounterState(state) {
  try {
    localStorage.setItem(ENCOUNTER_STATE_KEY, JSON.stringify(state));
  } catch (e) {}
}

function renderEncounterTracker() {
  if (!encounterTracker) return;
  Array.from(encounterTracker.querySelectorAll(".encounter-row")).forEach((row) => {
    const key = row.dataset.encounter;
    const bar = row.querySelector(".encounter-bar span");
    if (!key || !bar) return;
    const value = Math.max(0, Math.min(10, Number(encounterState?.[key]) || 0));
    const pct = (value / 10) * 100;
    bar.style.width = `${pct}%`;
    bar.parentElement.title = `${value}/10`;
  });
}

function adjustEncounter(key, delta) {
  if (!key) return;
  const current = Math.max(0, Math.min(10, Number(encounterState?.[key]) || 0));
  const next = Math.max(0, Math.min(10, current + delta));
  encounterState = { ...encounterState, [key]: next };
  saveEncounterState(encounterState);
  renderEncounterTracker();
}

function loadInventory() {
  try {
    const parsed = JSON.parse(localStorage.getItem(INVENTORY_KEY) || "[]");
    return Array.isArray(parsed) ? parsed : [];
  } catch (e) {
    return [];
  }
}

function saveInventory(items = []) {
  try {
    localStorage.setItem(INVENTORY_KEY, JSON.stringify(items));
  } catch (e) {}
}

function renderInventory() {
  const list = document.querySelector("#inventory-list");
  if (!list) return;
  const items = inventory;
  if (!items.length) {
    showMetaMessage(list, 'No items yet.');
    return;
  }
  const grouped = items.reduce((acc, item) => {
    acc[item.type || "item"] = acc[item.type || "item"] || [];
    acc[item.type || "item"].push(item);
    return acc;
  }, {});
  const order = ["weapon", "armor", "item"];
  const sections = order
    .filter((type) => grouped[type]?.length)
    .map((type) => {
      const entries = grouped[type]
        .map((item) => {
          const rarityClass = `rarity-${(item.rarity || "common").replace(/\\s+/g, "-")}`;
          const attuned = item.attuned ? " (attuned)" : "";
          const notes = item.notes ? `<small>${item.notes}</small>` : "";
          return `
            <div class="inventory-item" data-id="${item.id}">
              <div>
                <h4>${item.name || "Item"}${attuned}</h4>
                <div class="inventory-actions">
                  <span class="rarity-chip ${rarityClass}">${item.rarity || "common"}</span>
                  <span class="task-meta">${item.type || "item"}</span>
                  ${notes}
                </div>
              </div>
              <button type="button" class="ghost" data-attune="${item.id}">${item.attuned ? "Unattune" : "Attune"}</button>
              <button type="button" class="ghost" data-remove="${item.id}">Remove</button>
            </div>
          `;
        })
        .join("");
      return `<div><p class="task-meta" style="text-transform: capitalize;">${type}</p>${entries}</div>`;
    })
    .join("");
  list.innerHTML = sections;
}

function attunedCount() {
  return inventory.filter((item) => item.attuned).length;
}

function addInventoryItem({ name, type, rarity, notes }) {
  const item = {
    id: `inv-${Date.now()}-${Math.random().toString(16).slice(2, 6)}`,
    name: name || "Item",
    type: type || "item",
    rarity: rarity || "common",
    notes: notes || "",
    attuned: false,
  };
  inventory = [item, ...inventory].slice(0, 200);
  saveInventory(inventory);
  renderInventory();
}

function removeInventoryItem(id) {
  if (!id) return;
  inventory = inventory.filter((item) => item.id !== id);
  saveInventory(inventory);
  renderInventory();
}

function toggleAttune(id) {
  const item = inventory.find((i) => i.id === id);
  if (!item) return;
  if (item.attuned) {
    item.attuned = false;
  } else {
    if (attunedCount() >= MAX_ATTUNED) {
      setActionFeedback(`Max attuned items reached (${MAX_ATTUNED}).`);
      return;
    }
    item.attuned = true;
  }
  saveInventory(inventory);
  renderInventory();
}

function hexToRgba(hex, alpha = 1) {
  if (typeof hex !== "string") return null;
  const normalized = hex.replace("#", "").trim();
  if (![3, 6].includes(normalized.length)) return null;
  const expanded = normalized.length === 3 ? normalized.split("").map((c) => c + c).join("") : normalized;
  const int = parseInt(expanded, 16);
  if (Number.isNaN(int)) return null;
  const r = parseInt(expanded.slice(0, 2), 16);
  const g = parseInt(expanded.slice(2, 4), 16);
  const b = parseInt(expanded.slice(4, 6), 16);
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

function loadCustomQuickActions() {
  try {
    const parsed = JSON.parse(localStorage.getItem("lh_custom_quick_actions") || "[]");
    if (!Array.isArray(parsed)) return [];
    return parsed
      .map((item) => {
        if (!item || typeof item !== "object") return null;
        const label = (item.label || "").toString().trim();
        const url = (item.url || "").toString().trim();
        if (!label || !url) return null;
        return {
          id: item.id || `custom-${Date.now()}-${Math.random().toString(16).slice(2, 6)}`,
          label,
          url,
          icon: (item.icon || "").toString().trim().slice(0, 3) || "âš¡",
          color: typeof item.color === "string" && item.color.trim() ? item.color.trim() : null,
        };
      })
      .filter(Boolean);
  } catch (error) {
    console.warn("Failed to load custom quick actions", error);
    return [];
  }
}

function saveCustomQuickActions(actions = []) {
  try {
    localStorage.setItem("lh_custom_quick_actions", JSON.stringify(actions));
  } catch (e) {}
}

function applyQuickActionAccent(element, color) {
  if (!element) return;
  if (color) {
    const soft = hexToRgba(color, 0.18);
    const border = hexToRgba(color, 0.55) || color;
    element.dataset.accent = "true";
    element.style.setProperty("--custom-quick-accent", color);
    if (soft) {
      element.style.background = `linear-gradient(135deg, ${soft}, var(--surface-soft))`;
    }
    element.style.borderColor = border;
  } else {
    element.dataset.accent = "false";
    element.style.removeProperty("--custom-quick-accent");
  }
}

function renderCustomQuickActions() {
  if (!quickLaunchGrid) return;
  quickLaunchGrid.querySelectorAll(".custom-quick-item").forEach((node) => node.remove());
  if (!customQuickActions.length) return;
  const fragment = document.createDocumentFragment();
  customQuickActions.forEach((action) => {
    const link = document.createElement("a");
    link.setAttribute("role", "listitem");
    link.className = "quick-launch-item custom-quick-item";
    link.dataset.id = action.id;
    link.dataset.href = action.url;
    link.href = action.url;
    link.draggable = true;
    if (/^https?:/i.test(action.url)) {
      link.target = "_blank";
      link.rel = "noopener noreferrer";
    }
    applyQuickActionAccent(link, action.color || customQuickColorInput?.value || "#2563eb");
    const removeButton = document.createElement("button");
    removeButton.type = "button";
    removeButton.className = "quick-remove-btn";
    removeButton.dataset.removeQuick = action.id;
    removeButton.setAttribute("aria-label", `Remove ${action.label}`);
    removeButton.textContent = "Ã—";
    const icon = document.createElement("span");
    icon.className = "icon";
    icon.textContent = action.icon || "âš¡";
    const textWrap = document.createElement("div");
    textWrap.className = "quick-launch-text";
    const label = document.createElement("span");
    label.className = "label";
    label.textContent = action.label;
    const meta = document.createElement("span");
    meta.className = "quick-launch-meta";
    meta.textContent = action.url;
    textWrap.append(label, meta);
    link.append(removeButton, icon, textWrap);
    fragment.appendChild(link);
  });
  quickLaunchGrid.appendChild(fragment);
}

function handleCustomQuickAdd() {
  const label = (customQuickLabelInput?.value || "").trim();
  const url = (customQuickUrlInput?.value || "").trim();
  if (!label || !url) {
    setActionFeedback("Add a label and link before saving.");
    return;
  }
  if (/^javascript:/i.test(url)) {
    setActionFeedback("That link type is blocked.");
    return;
  }
  const icon = (customQuickIconInput?.value || "").trim().slice(0, 3) || "âš¡";
  const color = (customQuickColorInput?.value || "").trim() || null;
  const newAction = {
    id: `custom-${Date.now()}-${Math.random().toString(16).slice(2, 6)}`,
    label,
    url,
    icon,
    color,
  };
  customQuickActions = [newAction, ...customQuickActions].slice(0, 30);
  saveCustomQuickActions(customQuickActions);
  renderCustomQuickActions();
  setActionFeedback(`Added quick action: ${label}`);
  customQuickLabelInput && (customQuickLabelInput.value = "");
  customQuickUrlInput && (customQuickUrlInput.value = "");
  customQuickIconInput && (customQuickIconInput.value = "");
  if (commandPalette?.getAttribute("aria-hidden") === "false") {
    buildCommandItems();
    renderCommandResults(commandItems);
  }
}

function handleCustomQuickRemove(id) {
  if (!id) return;
  const removed = customQuickActions.find((item) => item.id === id);
  customQuickActions = customQuickActions.filter((item) => item.id !== id);
  saveCustomQuickActions(customQuickActions);
  renderCustomQuickActions();
  setActionFeedback(removed ? `Removed ${removed.label}` : "Removed quick action");
  if (commandPalette?.getAttribute("aria-hidden") === "false") {
    buildCommandItems();
    renderCommandResults(commandItems);
  }
}

function showToast({ icon = 'ðŸŽ‰', label = 'Nice!', meta = '' } = {}) {
  const toast = document.getElementById('toast');
  const toastIcon = document.getElementById('toast-icon');
  const toastLabel = document.getElementById('toast-label');
  const toastMeta = document.getElementById('toast-meta');
  if (!toast || !toastIcon || !toastLabel || !toastMeta) return;
  toastIcon.textContent = icon;
  toastLabel.textContent = label;
  toastMeta.textContent = meta;
  toast.classList.add('show');
  setTimeout(() => toast.classList.remove('show'), 2400);
}

function focusTextGameInput(variant = "base") {
  const input = variant === "v2" ? textGameV2Input : textGameInput;
  if (input && !input.disabled) {
    input.focus();
  }
}

function setGameCommandBusy(variant = "base", busy = false) {
  const form = variant === "v2" ? textGameV2Form : textGameForm;
  const button = form?.querySelector("button");
  if (button) {
    button.disabled = busy;
    button.textContent = busy ? "Runningâ€¦" : "Send";
  }
  form?.classList.toggle("is-busy", !!busy);
}

function ensureTextGameStyling() {
  if (document.getElementById("text-game-style")) return;
  const style = document.createElement("style");
  style.id = "text-game-style";
  style.textContent = `
    #text-game-output, #text-game-v2-output { max-height: 420px; overflow-y: auto; }
    .textgame-quickbar { display: flex; gap: 0.5rem; flex-wrap: wrap; margin: 0.35rem 0; }
    .textgame-quickbar button { border: 1px solid var(--border-subtle, #d1d5db); padding: 0.25rem 0.65rem; border-radius: 6px; background: var(--surface, #fff); cursor: pointer; }
    .textgame-quickbar button:hover { background: var(--surface-strong, #f3f4f6); }
    .is-busy button[type="submit"] { opacity: 0.7; }
    .status-chip.success { color: #166534; background: rgba(22, 101, 52, 0.12); }
    .status-chip.warning { color: #92400e; background: rgba(146, 64, 14, 0.12); }
    .status-chip.danger { color: #991b1b; background: rgba(153, 27, 27, 0.12); }
    .status-chip.info { color: #1d4ed8; background: rgba(29, 78, 216, 0.12); }
  `;
  document.head.appendChild(style);
}

function revealMapOutput(variant = "base") {
  const el = variant === "v2" ? textGameV2MapOutput : textGameMapOutput;
  if (el) {
    el.style.display = "block";
    el.dataset.visible = "1";
  }
}

function setSaveStatus(variant = "base", message = "", tone = "info") {
  const el = variant === "v2" ? textGameV2SaveStatus : textGameSaveStatus;
  if (!el) return;
  el.textContent = message;
  el.className = `status-chip ${tone}`;
}

function renderSlotMeta(variant = "base") {
  const statusEl = variant === "v2" ? textGameV2SaveStatus : textGameSaveStatus;
  const select = variant === "v2" ? textGameV2SlotSelect : textGameSlotSelect;
  if (!statusEl || !select) return;
  const slot = getGameSlot(variant);
  const metaKey = `${TEXT_GAME_SAVE_PREFIX}-${variant}-${slot}-meta`;
  let savedAt = null;
  try {
    const raw = localStorage.getItem(metaKey);
    if (raw) savedAt = JSON.parse(raw)?.savedAt || null;
  } catch (e) {
    savedAt = null;
  }
  const timeLabel = savedAt ? new Date(savedAt).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" }) : "never";
  statusEl.textContent = `Slot ${slot.toUpperCase()} Â· saved ${timeLabel}`;
  statusEl.className = "status-chip neutral";
}

function attachTextGameQuickBar() {
  const configs = [
    { form: textGameForm, variant: "base", mapOutput: textGameMapOutput, status: textGameStatus },
    { form: textGameV2Form, variant: "v2", mapOutput: textGameV2MapOutput, status: textGameV2Status },
  ];
  configs.forEach((cfg) => {
    if (!cfg.form || cfg.form.dataset.quickbarAttached) return;
    const bar = document.createElement("div");
    bar.className = "textgame-quickbar";
    const helpBtn = document.createElement("button");
    helpBtn.type = "button";
    helpBtn.textContent = "Help";
    helpBtn.addEventListener("click", () => runQuickTextGameCommand("help", cfg.variant));

    const mapBtn = document.createElement("button");
    mapBtn.type = "button";
    mapBtn.textContent = "Map";
    mapBtn.addEventListener("click", () => {
      revealMapOutput(cfg.variant);
      runQuickTextGameCommand("map", cfg.variant);
    });

    const toggleMapBtn = document.createElement("button");
    toggleMapBtn.type = "button";
    toggleMapBtn.textContent = "Toggle map panel";
    toggleMapBtn.addEventListener("click", () => {
      const target = cfg.variant === "v2" ? textGameV2MapOutput : textGameMapOutput;
      if (!target) return;
      const visible = target.style.display !== "none";
      target.style.display = visible ? "none" : "block";
      target.dataset.visible = visible ? "0" : "1";
    });

    bar.append(helpBtn, mapBtn, toggleMapBtn);
    cfg.form.insertAdjacentElement("beforebegin", bar);
    cfg.form.dataset.quickbarAttached = "1";
    if (cfg.mapOutput && !cfg.mapOutput.dataset.initialized) {
      cfg.mapOutput.style.display = "none";
      cfg.mapOutput.dataset.initialized = "1";
    }
  });
}

function pickNpcVisitor(forceNew = false) {
  if (!npcPanel) return null;
  const todayKey = new Date().toISOString().slice(0, 10);
  let stored = null;
  if (!forceNew) {
    try {
      stored = JSON.parse(localStorage.getItem(NPC_STORAGE_KEY) || "null");
    } catch (e) {
      stored = null;
    }
  }
  if (stored && stored.date === todayKey && stored.visitor && stored.visitor.image) {
    return stored.visitor;
  }
  const visitor = npcVisitors[Math.floor(Math.random() * npcVisitors.length)];
  try {
    localStorage.setItem(NPC_STORAGE_KEY, JSON.stringify({ date: todayKey, visitor }));
  } catch (e) {}
  return visitor;
}

function renderNpc(visitor) {
  if (!npcPanel || !visitor) return;
  if (npcName) npcName.textContent = visitor.name;
  if (npcRole) npcRole.textContent = visitor.role;
  if (npcQuest) npcQuest.textContent = visitor.quest;
  if (npcTip) npcTip.textContent = visitor.tip;
  if (npcReward) npcReward.textContent = visitor.reward?.text || visitor.reward || "";
  const claimed = isNpcRewardClaimed();
  const claimBtn = document.getElementById("npc-claim");
  if (claimBtn) {
    claimBtn.disabled = claimed;
    claimBtn.textContent = claimed ? "Claimed" : "Claim reward";
    claimBtn.dataset.npcId = visitor.name || "npc";
  }
  if (npcAvatar) {
    const hasImage = !!visitor.image;
    npcAvatar.textContent = hasImage ? "" : visitor.icon || visitor.name?.[0] || "â˜…";
    npcAvatar.style.background = hasImage
      ? "radial-gradient(circle at 30% 30%, rgba(255,255,255,0.16), transparent 55%)"
      : visitor.gradient || "var(--accent-soft)";
    if (npcAvatarImg) {
      if (hasImage) {
        const resolved = (() => {
          try {
            return new URL(visitor.image, window.location.href).toString();
          } catch (e) {
            return visitor.image;
          }
        })();
        npcAvatarImg.onerror = () => {
          npcAvatarImg.style.display = "none";
          npcAvatar.textContent = visitor.icon || visitor.name?.[0] || "â˜…";
        };
        npcAvatarImg.onload = () => {
          npcAvatarImg.style.display = "block";
        };
        npcAvatarImg.src = resolved;
        npcAvatarImg.style.display = "block";
        npcAvatar.style.backgroundImage = `url('${resolved}')`;
      } else {
        npcAvatarImg.removeAttribute("src");
        npcAvatarImg.style.display = "none";
        npcAvatar.style.backgroundImage = "";
      }
    }
  }
}

function isNpcRewardClaimed() {
  const todayKey = new Date().toISOString().slice(0, 10);
  try {
    const raw = localStorage.getItem(NPC_REWARD_CLAIM_KEY);
    if (!raw) return false;
    const parsed = JSON.parse(raw);
    return parsed?.date === todayKey;
  } catch (e) {
    return false;
  }
}

function setNpcRewardClaimed(visitor) {
  const todayKey = new Date().toISOString().slice(0, 10);
  try {
    localStorage.setItem(NPC_REWARD_CLAIM_KEY, JSON.stringify({ date: todayKey, npc: visitor?.name || "" }));
  } catch (e) {}
}

function claimNpcReward(visitor) {
  if (!visitor?.reward) {
    setActionFeedback("This visitor has no reward today.");
    return;
  }
  if (isNpcRewardClaimed()) {
    setActionFeedback("Already claimed today.");
    return;
  }
  const { xp: rewardXp = 0, item } = visitor.reward || {};
  if (rewardXp) awardXp(rewardXp, "NPC reward");
  if (item) addInventoryItem(item);
  setNpcRewardClaimed(visitor);
  const claimBtn = document.getElementById("npc-claim");
  if (claimBtn) {
    claimBtn.disabled = true;
    claimBtn.textContent = "Claimed";
  }
  setActionFeedback("Reward claimed.");
}

function setupTextGameHistory(input, historyArray) {
  if (!input) return { push: () => {} };
  let index = historyArray.length;
  input.addEventListener("keydown", (event) => {
    if (!historyArray.length) return;
    if (event.key === "ArrowUp") {
      event.preventDefault();
      index = Math.max(0, index - 1);
      input.value = historyArray[index] || "";
      input.setSelectionRange(input.value.length, input.value.length);
    } else if (event.key === "ArrowDown") {
      event.preventDefault();
      index = Math.min(historyArray.length, index + 1);
      input.value = index === historyArray.length ? "" : historyArray[index] || "";
      input.setSelectionRange(input.value.length, input.value.length);
    }
  });
  return {
    push(command) {
      historyArray.push(command);
      index = historyArray.length;
    },
    reset() {
      index = historyArray.length;
    },
  };
}

function clearTextGameConsole(variant = "base") {
  const output = variant === "v2" ? textGameV2Output : textGameOutput;
  const status = variant === "v2" ? textGameV2Status : textGameStatus;
  if (output) output.innerHTML = "";
  if (status) status.textContent = "Console cleared.";
  focusTextGameInput(variant);
}

async function runQuickTextGameCommand(command, variant = "base") {
  const ready = variant === "v2" ? textGameV2Ready : textGameReady;
  const input = variant === "v2" ? textGameV2Input : textGameInput;
  const history = variant === "v2" ? textGameV2History : textGameHistory;
  const append = variant === "v2" ? appendTextGameV2Output : appendTextGameOutput;
  const send = variant === "v2" ? sendTextGameCommandV2 : sendTextGameCommand;
  const status = variant === "v2" ? setTextGameV2Status : setTextGameStatus;
  const mapOutput = variant === "v2" ? textGameV2MapOutput : textGameMapOutput;
  const lastOutput = variant === "v2" ? () => lastTextGameV2Output : () => lastTextGameOutput;
  if (command === "clear") {
    clearTextGameConsole(variant);
    return;
  }
  if (!ready) {
    status(`Start ${variant === "v2" ? "the v2 game" : "the game"} first, then try again.`);
    return;
  }
  append(`> ${command}`);
  history.push(command);
  if (input) input.value = "";
  await send(command);
  if (command === "map" && mapOutput) {
    mapOutput.textContent = lastOutput() || "Map output not available yet.";
    revealMapOutput(variant);
  }
}

function appendTextGameOutput(text) {
  if (!textGameOutput || !text) return;
  const chunk = document.createElement("pre");
  chunk.textContent = text.trim();
  textGameOutput.appendChild(chunk);
  textGameOutput.scrollTop = textGameOutput.scrollHeight;
  lastTextGameOutput = text.trim();
  focusTextGameInput("base");
}

function setTextGameStatus(message) {
  if (textGameStatus) {
    textGameStatus.textContent = message;
  }
}

function appendTextGameV2Output(text) {
  if (!textGameV2Output || !text) return;
  const chunk = document.createElement("pre");
  chunk.textContent = text.trim();
  textGameV2Output.appendChild(chunk);
  textGameV2Output.scrollTop = textGameV2Output.scrollHeight;
  lastTextGameV2Output = text.trim();
  focusTextGameInput("v2");
}

function setTextGameV2Status(message) {
  if (textGameV2Status) {
    textGameV2Status.textContent = message;
  }
}

function loadPyodideScript() {
  if (window.loadPyodide) {
    return Promise.resolve();
  }
  const sources = [
    { script: `${PYODIDE_LOCAL_BASE}pyodide.js`, base: PYODIDE_LOCAL_BASE },
    { script: `${PYODIDE_CDN_BASE}pyodide.js`, base: PYODIDE_CDN_BASE },
  ];
  return new Promise((resolve, reject) => {
    const trySource = (index) => {
      if (index >= sources.length) {
        reject(new Error("Failed to load Pyodide runtime"));
        return;
      }
      const source = sources[index];
      const script = document.createElement("script");
      script.src = source.script;
      script.onload = () => {
        pyodideBaseUrl = source.base;
        resolve();
      };
      script.onerror = () => {
        script.remove();
        trySource(index + 1);
      };
      document.head.appendChild(script);
    };
    trySource(0);
  });
}

async function ensurePyodideInstance() {
  if (pyodideInstance) return pyodideInstance;
  await loadPyodideScript();
  pyodideInstance = await loadPyodide({ indexURL: pyodideBaseUrl });
  return pyodideInstance;
}

async function ensurePyodideV2Instance() {
  if (pyodideV2Instance) return pyodideV2Instance;
  await loadPyodideScript();
  pyodideV2Instance = await loadPyodide({ indexURL: pyodideBaseUrl });
  return pyodideV2Instance;
}

async function refreshTextGameNpcs() {
  if (!pyodideInstance) {
    textGameNpcs = [];
    return;
  }
  try {
    const raw = await pyodideInstance.runPythonAsync("lifehub_room_npcs()");
    const parsed = JSON.parse(raw);
    textGameNpcs = Array.isArray(parsed) ? parsed : [];
  } catch {
    textGameNpcs = [];
  }
}

async function refreshTextGameV2Npcs() {
  if (!pyodideV2Instance) {
    textGameV2Npcs = [];
    return;
  }
  try {
    const raw = await pyodideV2Instance.runPythonAsync("lifehub_room_npcs()");
    const parsed = JSON.parse(raw);
    textGameV2Npcs = Array.isArray(parsed) ? parsed : [];
  } catch {
    textGameV2Npcs = [];
  }
}

async function initTextGameEngine() {
  if (textGameReady || textGameLoading) return;
  textGameLoading = true;
  if (textGameStartButton) {
    textGameStartButton.textContent = "Loadingâ€¦";
  }
  try {
    setTextGameStatus("Loading Pyodide runtime and text adventureâ€¦");
    const pyodide = await ensurePyodideInstance();
    const loadedSource = await loadGameSource(TEXT_GAME_SOURCE_URL, "base");
    let pythonSource = loadedSource;
    const runnerIndex = pythonSource.indexOf("# ===========================\n# SINGLE RUNNER");
    if (runnerIndex > -1) {
      pythonSource = pythonSource.slice(0, runnerIndex);
    }
    const fullSource = `${pythonSource}\nGAME = Game()\n${LIFEHUB_WRAPPER}`;
    await pyodide.runPythonAsync(fullSource);
    const intro = await pyodide.runPythonAsync("lifehub_intro()");
    appendTextGameOutput(intro);
    await refreshTextGameNpcs();
    textGameReady = true;
    setTextGameStatus("Game ready. Enter commands below.");
    if (textGameInput) {
      textGameInput.disabled = false;
      textGameInput.focus();
    }
    const formButton = textGameForm?.querySelector("button");
    if (formButton) {
      formButton.disabled = false;
    }
    if (textGameStartButton) {
      textGameStartButton.textContent = "Loaded";
      textGameStartButton.disabled = true;
    }
  } catch (error) {
    console.error(error);
    setTextGameStatus(
      "Failed to load the Python game. Check your internet connection and reload the dashboard to try again."
    );
    if (textGameStartButton) {
      textGameStartButton.disabled = false;
      textGameStartButton.textContent = "Retry Load";
    }
  } finally {
    textGameLoading = false;
  }
}

function normalizeGameInput(line, npcs = []) {
  const raw = (line || "").trim();
  if (!raw) return { command: "" };
  const lower = raw.toLowerCase();
  if (["inventory", "inv", "backpack", "bag", "pack"].includes(lower)) {
    return { command: "inv" };
  }
  if (DIRECTION_ALIASES.has(lower)) {
    const short = lower[0];
    return { command: `move ${short}` };
  }
  if (/^\\d+$/.test(lower)) {
    return { command: `say ${lower}` };
  }
  if (lower === "unlock" || lower === "unlock gate") {
    return { command: "use rusty key", autoMessage: "You test the rusty key in the gate." };
  }
  if (lower === "talk") {
    if (npcs.length === 1) {
      const npc = npcs[0];
      return { command: `talk ${npc}`, autoMessage: `You approach ${npc}.` };
    }
    if (npcs.length > 1) {
      return { command: "", statusHint: `Multiple NPCs nearby: ${npcs.join(", ")}. Try â€œtalk nameâ€.` };
    }
  }
  return { command: raw };
}

function normalizeTextGameInput(line) {
  return normalizeGameInput(line, textGameNpcs);
}

function normalizeTextGameV2Input(line) {
  return normalizeGameInput(line, textGameV2Npcs);
}

async function sendTextGameCommand(line) {
  if (!pyodideInstance || !textGameReady) return;
  setGameCommandBusy("base", true);
  const normalized = normalizeTextGameInput(line);
  if (normalized.statusHint) {
    setTextGameStatus(normalized.statusHint);
  }
  if (!normalized.command) {
    setGameCommandBusy("base", false);
    return;
  }
  if (normalized.autoMessage) {
    appendTextGameOutput(normalized.autoMessage);
  }
  try {
    const escaped = JSON.stringify(normalized.command);
    const resultJson = await pyodideInstance.runPythonAsync(`lifehub_command(${escaped})`);
    const data = JSON.parse(resultJson);
    appendTextGameOutput(data.output || "");
    await refreshTextGameNpcs();
    if (data.keep_running) {
      setTextGameStatus("Game ready. Enter commands below.");
    }
    if (!data.keep_running) {
      setTextGameStatus("Game ended. Refresh or click Start Game to play again.");
      if (textGameInput) textGameInput.disabled = true;
      const formButton = textGameForm?.querySelector("button");
      if (formButton) formButton.disabled = true;
    }
    if (textGameAutosave) {
      await saveGameState("base");
    }
  } catch (error) {
    console.error(error);
    appendTextGameOutput("[Error] Failed to run command.");
  } finally {
    setGameCommandBusy("base", false);
    focusTextGameInput("base");
  }
}

async function initTextGameEngineV2() {
  if (textGameV2Ready || textGameV2Loading) return;
  textGameV2Loading = true;
  if (textGameV2StartButton) {
    textGameV2StartButton.textContent = "Loadingâ€¦";
  }
  try {
    setTextGameV2Status("Loading Pyodide runtime and v2 gameâ€¦");
    const pyodide = await ensurePyodideV2Instance();
    const loadedSource = await loadGameSource(TEXT_GAME_V2_SOURCE_URL, "v2");
    let pythonSource = loadedSource;
    const runnerIndex = pythonSource.indexOf("# ===========================\n# SINGLE RUNNER");
    if (runnerIndex > -1) {
      pythonSource = pythonSource.slice(0, runnerIndex);
    }
    const fullSource = `${pythonSource}\nGAME = Game()\n${LIFEHUB_WRAPPER}`;
    await pyodide.runPythonAsync(fullSource);
    const intro = await pyodide.runPythonAsync("lifehub_intro()");
    appendTextGameV2Output(intro);
    await refreshTextGameV2Npcs();
    textGameV2Ready = true;
    setTextGameV2Status("Game ready. Enter commands below.");
    if (textGameV2Input) {
      textGameV2Input.disabled = false;
      textGameV2Input.focus();
    }
    const formButton = textGameV2Form?.querySelector("button");
    if (formButton) {
      formButton.disabled = false;
    }
    if (textGameV2StartButton) {
      textGameV2StartButton.textContent = "Loaded";
      textGameV2StartButton.disabled = true;
    }
  } catch (error) {
    console.error(error);
    setTextGameV2Status(
      "Failed to load the v2 Python game. Check your internet connection and reload the dashboard to try again."
    );
    if (textGameV2StartButton) {
      textGameV2StartButton.disabled = false;
      textGameV2StartButton.textContent = "Retry Load";
    }
  } finally {
    textGameV2Loading = false;
  }
}

async function sendTextGameCommandV2(line) {
  if (!pyodideV2Instance || !textGameV2Ready) return;
  setGameCommandBusy("v2", true);
  const normalized = normalizeTextGameV2Input(line);
  if (normalized.statusHint) {
    setTextGameV2Status(normalized.statusHint);
  }
  if (!normalized.command) {
    setGameCommandBusy("v2", false);
    return;
  }
  if (normalized.autoMessage) {
    appendTextGameV2Output(normalized.autoMessage);
  }
  try {
    const escaped = JSON.stringify(normalized.command);
    const resultJson = await pyodideV2Instance.runPythonAsync(`lifehub_command(${escaped})`);
    const data = JSON.parse(resultJson);
    appendTextGameV2Output(data.output || "");
    await refreshTextGameV2Npcs();
    if (data.keep_running) {
      setTextGameV2Status("Game ready. Enter commands below.");
    }
    if (!data.keep_running) {
      setTextGameV2Status("Game ended. Refresh or click Start v2 to play again.");
      if (textGameV2Input) textGameV2Input.disabled = true;
      const formButton = textGameV2Form?.querySelector("button");
      if (formButton) formButton.disabled = true;
    }
    if (textGameV2Autosave) {
      await saveGameState("v2");
    }
  } catch (error) {
    console.error(error);
    appendTextGameV2Output("[Error] Failed to run command.");
  } finally {
    setGameCommandBusy("v2", false);
    focusTextGameInput("v2");
  }
}

function getGameSlot(variant) {
  const select = variant === "v2" ? textGameV2SlotSelect : textGameSlotSelect;
  return select?.value || "slotA";
}

async function saveGameState(variant = "base") {
  const slot = getGameSlot(variant);
  const statusElement = variant === "v2" ? textGameV2SaveStatus : textGameSaveStatus;
  const pyodide = variant === "v2" ? pyodideV2Instance : pyodideInstance;
  if (!pyodide || (variant === "v2" ? !textGameV2Ready : !textGameReady)) {
    setSaveStatus(variant, "Start the game before saving.", "danger");
    return;
  }
  try {
    const payload = await pyodide.runPythonAsync("lifehub_save_state()");
    localStorage.setItem(`${TEXT_GAME_SAVE_PREFIX}-${variant}-${slot}`, payload);
    const now = new Date().toISOString();
    localStorage.setItem(`${TEXT_GAME_SAVE_PREFIX}-${variant}-${slot}-meta`, JSON.stringify({ savedAt: now }));
    setSaveStatus(variant, `Saved Slot ${slot.toUpperCase()} at ${new Date(now).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })}.`, "success");
  } catch (error) {
    console.error(error);
    setSaveStatus(variant, "Save failed.", "danger");
  }
}

async function loadGameState(variant = "base") {
  const slot = getGameSlot(variant);
  const statusElement = variant === "v2" ? textGameV2SaveStatus : textGameSaveStatus;
  const pyodide = variant === "v2" ? pyodideV2Instance : pyodideInstance;
  if (!pyodide || (variant === "v2" ? !textGameV2Ready : !textGameReady)) {
    setSaveStatus(variant, "Start the game before loading.", "danger");
    return;
  }
  const payload = localStorage.getItem(`${TEXT_GAME_SAVE_PREFIX}-${variant}-${slot}`);
  if (!payload) {
    setSaveStatus(variant, "Slot empty.", "warning");
    return;
  }
  try {
    const result = await pyodide.runPythonAsync(`lifehub_load_state(${JSON.stringify(payload)})`);
    if (variant === "v2") {
      appendTextGameV2Output(result || "Loaded save.");
      setTextGameV2Status("Save loaded.");
    } else {
      appendTextGameOutput(result || "Loaded save.");
      setTextGameStatus("Save loaded.");
    }
    await (variant === "v2" ? refreshTextGameV2Npcs() : refreshTextGameNpcs());
    const meta = localStorage.getItem(`${TEXT_GAME_SAVE_PREFIX}-${variant}-${slot}-meta`);
    const metaTime = meta ? (() => { try { return JSON.parse(meta).savedAt; } catch { return null; } })() : null;
    const savedAt = metaTime ? new Date(metaTime).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" }) : null;
    setSaveStatus(variant, `Loaded ${slot.toUpperCase()}${savedAt ? ` (saved ${savedAt})` : ""}.`, "success");
  } catch (error) {
    console.error(error);
    setSaveStatus(variant, "Failed to load save.", "danger");
  }
}

async function copyStatsCommand() {
  if (!statsCommandButton) return;
  try {
    if (navigator.clipboard?.writeText) {
      await navigator.clipboard.writeText(STATS_COMMAND);
    } else {
      throw new Error("Clipboard API unavailable");
    }
    setActionFeedback("Copied! Paste into Terminal to refresh stats.");
  } catch {
    const textarea = document.createElement("textarea");
    textarea.value = STATS_COMMAND;
    document.body.appendChild(textarea);
    textarea.select();
    try {
      document.execCommand("copy");
      setActionFeedback("Command copied. Paste into Terminal to run it.");
    } catch {
      setActionFeedback("Copy failed â€” run the command manually.");
    } finally {
      textarea.remove();
    }
  }
}

function cardMatchesQuery(card, tokens) {
  if (!tokens.length) return true;
  const haystack = [
    card.title,
    card.description,
    card.focus,
    (card.tags || []).join(" "),
    (card.keywords || []).join(" "),
    card.links?.map((link) => link.label).join(" "),
    card.snippet || "",
  ]
    .join(" ")
    .toLowerCase();
  return tokens.every((token) => haystack.includes(token));
}

function renderCards(filter = "") {
  if (!cardGrid) return;
  cardGrid.innerHTML = "";
  const query = filter.trim().toLowerCase();
  const tokens = query.split(/\s+/).filter(Boolean);
  let visibleCards = cards.filter((card) => cardMatchesQuery(card, tokens));
  if (focusModeEnabled) {
    visibleCards = visibleCards.filter((card) => focusCards.has(card.title));
  }

  if (!visibleCards.length) {
    const empty = document.createElement("p");
    empty.className = "empty-state";
    empty.textContent = focusModeEnabled
      ? "No focus cards yet. Pin a few areas, then toggle Focus mode."
      : "No matching area â€” try another keyword.";
    cardGrid.appendChild(empty);
    return;
  }

  visibleCards.forEach((card) => {
    const el = document.createElement("article");
    el.className = "card";
    const icon = iconMap[card.icon] || iconMap.default;
    el.innerHTML = `
      <div class="card-heading">
        <span class="card-icon" aria-hidden="true">${icon}</span>
        <div>
          <h2>${card.title}</h2>
          <p>${card.description}</p>
          ${card.snippet ? `<p class="card-snippet">${card.snippet}</p>` : ""}
        </div>
      </div>
      <ul>
        ${card.links
          .map((link) => `<li><a href="${normalizeLinkHref(link.href)}" target="_blank">${link.label}</a></li>`)
          .join("")}
      </ul>
      <div class="taglist">
        ${card.tags.map((tag) => `<span class="tag">${tag}</span>`).join("")}
      </div>
      <div class="card-actions">
        <button type="button" class="focus-pin" data-focus-card="${card.title}" aria-pressed="${
      focusCards.has(card.title) ? "true" : "false"
    }">
          ${focusCards.has(card.title) ? "Pinned" : "Pin to focus"}
        </button>
        <button type="button" data-section="${card.title}">View details</button>
      </div>
    `;
    cardGrid.appendChild(el);
  });
}

function updateFocusToggle() {
  if (!focusToggle) return;
  focusToggle.setAttribute("aria-pressed", String(focusModeEnabled));
  focusToggle.textContent = focusModeEnabled ? "Focus mode: On" : "Focus mode: Off";
}

function toggleFocusMode() {
  focusModeEnabled = !focusModeEnabled;
  localStorage.setItem(FOCUS_MODE_KEY, String(focusModeEnabled));
  updateFocusToggle();
  renderCards(searchInput?.value || "");
}

function toggleFocusCard(title) {
  if (!title) return;
  if (focusCards.has(title)) {
    focusCards.delete(title);
  } else {
    focusCards.add(title);
  }
  saveFocusCards(focusCards);
  renderCards(searchInput?.value || "");
}

function setActiveCadenceTab(tab, { focus = false } = {}) {
  if (!tab) return;
  activeCadence = tab.dataset.cadenceTab || "All";
  cadenceTabs.forEach((button) => {
    const isActive = button === tab;
    button.classList.toggle("active", isActive);
    button.setAttribute("aria-selected", String(isActive));
    button.setAttribute("tabindex", isActive ? "0" : "-1");
  });
  if (tabPanel && tab.id) {
    tabPanel.setAttribute("aria-labelledby", tab.id);
  }
  renderTasks();
  if (focus) {
    tab.focus();
  }
}

function renderTasks() {
  taskList.innerHTML = "";
  const visibleTasks = activeCadence === "All" ? tasks : tasks.filter((task) => task.cadence === activeCadence);
  visibleTasks.forEach((task) => {
    const li = document.createElement("li");
    const checked = !!checklistState[task.id];
    const history = checklistHistory[task.id];
    const lastCompleted = history?.lastCompleted ? formatDate(history.lastCompleted) : "Not completed yet";
    li.innerHTML = `
      <label>
        <input type="checkbox" data-task="${task.id}" ${checked ? "checked" : ""}>
        <span>${task.label} <small>(${task.cadence})</small></span>
      </label>
      <p class="task-meta">Last done: ${lastCompleted}</p>
    `;
    taskList.appendChild(li);
  });
  if (!visibleTasks.length) {
    const empty = document.createElement("p");
    empty.className = "task-meta";
    empty.textContent = `No ${activeCadence.toLowerCase()} tasks configured yet.`;
    taskList.appendChild(empty);
  }
  updateTaskSummary();
  renderTaskSparkline();
}

function listRecentWeekKeys(count = 8) {
  const keys = [];
  const date = new Date();
  for (let i = 0; i < count; i++) {
    keys.unshift(getWeekKey(new Date(date)));
    date.setDate(date.getDate() - 7);
  }
  return keys;
}

function renderTaskSparkline() {
  if (!taskSparkline) return;
  let canvas = taskSparkline.querySelector("canvas");
  if (!canvas) {
    canvas = document.createElement("canvas");
    taskSparkline.appendChild(canvas);
  }
  const width = taskSparkline.clientWidth || 240;
  const height = taskSparkline.clientHeight || 50;
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, width, height);
  const weeks = listRecentWeekKeys(8);
  const values = weeks.map((week) => {
    let count = 0;
    Object.values(checklistHistory || {}).forEach((entry) => {
      if (entry?.week === week) count += 1;
    });
    return count;
  });
  const maxValue = Math.max(...values, 1);
  ctx.strokeStyle = "rgba(37, 99, 235, 0.9)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  values.forEach((value, index) => {
    const x = (index / (values.length - 1 || 1)) * width;
    const y = height - (value / maxValue) * height;
    if (index === 0) {
      ctx.moveTo(x, y);
    } else {
      ctx.lineTo(x, y);
    }
  });
  ctx.stroke();
}

function renderPlayables() {
  if (!playablesGrid) return;
  if (!playables.length) {
    showMetaMessage(playablesGrid, 'No playable projects registered yet.');
    if (playablesCountElement) playablesCountElement.textContent = "";
    return;
  }
  if (playablesCountElement) {
    playablesCountElement.textContent = `${playables.length} project${playables.length === 1 ? "" : "s"}`;
  }
  playablesGrid.innerHTML = playables
    .map(
      (project) => `
        <article class="playable-card" data-playable="${project.id}">
          <div>
            <h3>${project.name}</h3>
            <p class="playable-meta">${project.type}</p>
          </div>
          <p>${project.description}</p>
          <p class="playable-command">${project.command}</p>
          <div class="playable-actions">
            <button type="button" data-copy-command="${encodeURIComponent(project.command)}">Copy run command</button>
            ${
              project.entry
                ? `<a href="${encodePath(project.entry)}" target="_blank" rel="noopener">${
                    project.type.includes("Python") ? "Open script" : "Open entry point"
                  }</a>`
                : ""
            }
            ${
              project.folderLink
                ? `<a href="${encodePath(project.folderLink)}" target="_blank" rel="noopener">Open project folder</a>`
                : ""
            }
          </div>
          ${project.notes ? `<p class="playable-meta">${project.notes}</p>` : ""}
        </article>
      `
    )
    .join("");
}

function showDetail(sectionName, { updateHash = true } = {}) {
  const card = cards.find((item) => item.title.toLowerCase() === sectionName.toLowerCase());
  if (!card) return;
  detailTitle.textContent = card.title;
  detailDescription.textContent = card.description;
  const lore = LORE_BLURBS[card.title];
  if (lore) {
    const loreEl = document.createElement("span");
    loreEl.className = "lore-blurb";
    loreEl.textContent = lore;
    detailDescription.appendChild(loreEl);
  }
  detailTags.textContent = card.tags.join(", ");
  detailFocus.textContent = card.focus;
  safeSetInnerText(detailLinks, card.links)
    .map(
      (link) => `
        <div>
          <a href="${normalizeLinkHref(link.href)}" target="_blank">${link.label}</a>
          ${link.note ? `<small>${link.note}</small>` : ""}
        </div>
      `
    )
    .join("");
  safeSetInnerText(detailRoot, card.root)
    ? `<a href="${normalizeLinkHref(card.root)}" target="_blank">Open ${card.title} folder â†’</a>`
    : "";
  detailView.classList.add("visible");
  detailView.scrollIntoView({ behavior: "smooth", block: "start" });
  if (updateHash) {
    history.replaceState(null, "", `#${encodeURIComponent(card.title)}`);
  }
}

function hideDetail({ updateHash = true } = {}) {
  detailView.classList.remove("visible");
  if (updateHash) {
    history.replaceState(null, "", window.location.pathname);
  }
}

function bindEvents() {
  automationDryRunToggle && (automationDryRunToggle.checked = automationDryRun);
  const baseHistory = setupTextGameHistory(textGameInput, textGameHistory);
  const v2History = setupTextGameHistory(textGameV2Input, textGameV2History);
  ensureTextGameStyling();
  attachTextGameQuickBar();
  renderSlotMeta("base");
  renderSlotMeta("v2");
  setupMiniAdventureSelector();
  textGameSlotSelect?.addEventListener("change", () => renderSlotMeta("base"));
  textGameV2SlotSelect?.addEventListener("change", () => renderSlotMeta("v2"));
  try {
    textGameAutosave = localStorage.getItem(TEXT_GAME_AUTOSAVE_KEY) === "1";
    textGameV2Autosave = localStorage.getItem(TEXT_GAME_V2_AUTOSAVE_KEY) === "1";
    if (textGameAutosaveToggle) textGameAutosaveToggle.checked = textGameAutosave;
    if (textGameV2AutosaveToggle) textGameV2AutosaveToggle.checked = textGameV2Autosave;
  } catch (e) {}
  searchInput.addEventListener("input", (event) => {
    renderCards(event.target.value);
  });

  customQuickAddButton?.addEventListener("click", handleCustomQuickAdd);
  [customQuickLabelInput, customQuickUrlInput, customQuickIconInput, customQuickColorInput].forEach((input) => {
    input?.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        handleCustomQuickAdd();
      }
    });
  });
  quickLaunchGrid?.addEventListener("click", (event) => {
    const removeButton = event.target.closest("[data-remove-quick]");
    if (removeButton) {
      event.preventDefault();
      event.stopPropagation();
      handleCustomQuickRemove(removeButton.dataset.removeQuick);
    }
    const item = event.target.closest(".quick-launch-item");
    if (item && !event.target.closest("[data-remove-quick]")) {
      awardXp(XP_AWARD_QUICK_LAUNCH, "Quick launch");
    }
  });

  quickActionGrid?.addEventListener("click", (event) => {
    const link = event.target.closest(".quick-link");
    if (link) {
      awardXp(XP_AWARD_QUICK_ACTION, "Quick action");
    }
  });

  cardGrid.addEventListener("click", (event) => {
    const pinButton = event.target.closest("button.focus-pin");
    if (pinButton) {
      toggleFocusCard(pinButton.dataset.focusCard);
      return;
    }
    const button = event.target.closest("button[data-section]");
    if (button) {
      showDetail(button.dataset.section);
    }
  });

  focusToggle?.addEventListener("click", () => toggleFocusMode());
  kioskToggle?.addEventListener("click", () => toggleKioskMode());
  kioskPresetButtons.forEach((button) => {
    button.addEventListener("click", () => applyKioskPreset(button.dataset.kioskPreset));
  });
  questCompleteButton?.addEventListener("click", completeQuest);
  questRerollButton?.addEventListener("click", rerollQuest);
  tavernPrevButton?.addEventListener("click", () => {
    tavernIndex = (tavernIndex - 1 + TAVERN_BANTER.length) % Math.max(1, TAVERN_BANTER.length || 1);
    renderTavernLine();
  });
  tavernNextButton?.addEventListener("click", () => {
    tavernIndex = (tavernIndex + 1) % Math.max(1, TAVERN_BANTER.length || 1);
    renderTavernLine();
  });
  diceButtons?.addEventListener("click", (event) => {
    const button = event.target.closest("[data-die]");
    if (!button) return;
    const sides = Number(button.dataset.die);
    const roll = rollDie(sides);
    logDiceResult(`Roll d${sides}: ${roll}`);
  });
  diceEncounterButton?.addEventListener("click", rollEncounter);
  diceLootButton?.addEventListener("click", rollLoot);
  diceClearButton?.addEventListener("click", clearDiceLog);
  hydrateDndToggle(dndInspirationToggle, DND_INSPIRATION_KEY);
  hydrateDndToggle(dndBardicToggle, DND_BARDIC_KEY);
  hydrateNumberInput(dndProfInput, DND_PROF_KEY, 2);
  setPoolValue(dndInspirationPoolInput, DND_INSPIRATION_POOL_KEY, Number(localStorage.getItem(DND_INSPIRATION_POOL_KEY)) || 0);
  setPoolValue(dndBardicPoolInput, DND_BARDIC_POOL_KEY, Number(localStorage.getItem(DND_BARDIC_POOL_KEY)) || 0);
  if (dndBardicDieSelect) {
    const savedDie = Number(localStorage.getItem(DND_BARDIC_DIE_KEY));
    if (savedDie) dndBardicDieSelect.value = String(savedDie);
    dndBardicDieSelect.addEventListener("change", () => {
      try { localStorage.setItem(DND_BARDIC_DIE_KEY, dndBardicDieSelect.value); } catch (e) {}
    });
  }
  dndInspirationPoolInput?.addEventListener("change", () =>
    setPoolValue(dndInspirationPoolInput, DND_INSPIRATION_POOL_KEY, dndInspirationPoolInput.value),
  );
  dndBardicPoolInput?.addEventListener("change", () =>
    setPoolValue(dndBardicPoolInput, DND_BARDIC_POOL_KEY, dndBardicPoolInput.value),
  );
  dndInspirationAdd?.addEventListener("click", () =>
    setPoolValue(dndInspirationPoolInput, DND_INSPIRATION_POOL_KEY, getPoolValue(dndInspirationPoolInput) + 1),
  );
  dndBardicAdd?.addEventListener("click", () =>
    setPoolValue(dndBardicPoolInput, DND_BARDIC_POOL_KEY, getPoolValue(dndBardicPoolInput) + 1),
  );
  dndSkillExpert?.addEventListener("change", (event) => {
    if (event.target.checked && dndSkillProf) dndSkillProf.checked = true;
  });
  // Enforce 5e-legal ability scores (standard array) on load and on change
  ABILITY_ORDER.forEach((key) => {
    const input = dndInputs[key];
    if (input) {
      input.addEventListener("change", () => enforceLegalAbilityScores());
      input.addEventListener("blur", () => enforceLegalAbilityScores({ silent: true }));
    }
  });
  enforceLegalAbilityScores({ silent: true });
  document.getElementById("inv-add")?.addEventListener("click", () => {
    const name = document.getElementById("inv-name")?.value.trim() || "";
    const type = document.getElementById("inv-type")?.value || "item";
    const rarity = document.getElementById("inv-rarity")?.value || "common";
    const notes = document.getElementById("inv-notes")?.value.trim() || "";
    if (!name) {
      setActionFeedback("Add an item name first.");
      return;
    }
    addInventoryItem({ name, type, rarity, notes });
    document.getElementById("inv-name").value = "";
    document.getElementById("inv-notes").value = "";
    setActionFeedback("Item added to inventory.");
  });
  document.getElementById("inventory-list")?.addEventListener("click", (event) => {
    const removeBtn = event.target.closest("[data-remove]");
    const attuneBtn = event.target.closest("[data-attune]");
    if (removeBtn) {
      removeInventoryItem(removeBtn.dataset.remove);
    }
    if (attuneBtn) {
      toggleAttune(attuneBtn.dataset.attune);
    }
  });
  dndRollButton?.addEventListener("click", () => rollDndCheck({ mode: "normal" }));
  dndAdvButton?.addEventListener("click", () => rollDndCheck({ mode: "adv" }));
  dndDisButton?.addEventListener("click", () => rollDndCheck({ mode: "dis" }));
  dndClearButton?.addEventListener("click", clearDndLog);

  const characterModal = document.querySelector('#character-modal');
  // DnD Character modal accessibility & persistence helpers
  (function(){
    // Simple focus-trap factory for a container element
    function createFocusTrap(container) {
      if (!container) return { enable: ()=>{}, disable: ()=>{} };
      let previouslyFocused = null;
      const FOCUSABLE = 'a[href], area[href], input:not([disabled]):not([type=hidden]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, [tabindex]:not([tabindex="-1"]), [contenteditable]';
      function getFocusableElements() {
        return Array.from(container.querySelectorAll(FOCUSABLE)).filter(el => el.offsetWidth || el.offsetHeight || el.getClientRects().length);
      }
      function handleKey(e){
        if (e.key === 'Tab') {
          const focusables = getFocusableElements();
          if (focusables.length === 0) { e.preventDefault(); return; }
          const first = focusables[0];
          const last = focusables[focusables.length-1];
          if (e.shiftKey) {
            if (document.activeElement === first) { e.preventDefault(); last.focus(); }
          } else {
            if (document.activeElement === last) { e.preventDefault(); first.focus(); }
          }
        }
        if (e.key === 'Escape' || e.key === 'Esc') {
          // let the modal-specific handler decide to close; dispatch a custom event
          const ev = new CustomEvent('trap-escape', { bubbles: true });
          container.dispatchEvent(ev);
        }
      }
      return {
        enable() {
          previouslyFocused = document.activeElement;
          const focusables = getFocusableElements();
          if (focusables.length) focusables[0].focus();
          document.addEventListener('keydown', handleKey, true);
        },
        disable() {
          document.removeEventListener('keydown', handleKey, true);
          try { if (previouslyFocused && previouslyFocused.focus) previouslyFocused.focus(); } catch(e){}
        }
      };
    }
  
    // localStorage helpers for DnD character sheet with simple schema versioning
    const CHARACTER_KEY = 'lifehub_dnd_character_v1';
    function saveCharacterToStorage(obj) {
      try {
        const payload = { v: 1, data: obj };
        localStorage.setItem(CHARACTER_KEY, JSON.stringify(payload));
        return true;
      } catch (e) {
        console.warn('Failed to save character', e);
        return false;
      }
    }
    function loadCharacterFromStorage() {
      try {
        const raw = localStorage.getItem(CHARACTER_KEY);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || parsed.v !== 1) return null;
        return parsed.data || null;
      } catch (e) {
        console.warn('Failed to load character', e);
        return null;
      }
    }
  
    // Wire the character modal (if present) to trap focus, ESC-to-close, and save/load
    try {
      const modal = document.querySelector('#character-modal');
      const openBtn = document.querySelector('#character-edit'); // try multiple ids as fallbacks
      const closeBtn = document.querySelector('#character-close');
      const cancelBtn = document.querySelector('#character-cancel');
      const backdrop = document.querySelector('#character-backdrop');
      const form = document.querySelector('#character-form');
      if (modal) {
        const trap = createFocusTrap(modal);
        function openCharacterModalWithEnhancements() {
          modal.setAttribute('aria-hidden', 'false');
          modal.setAttribute('role', modal.getAttribute('role') || 'dialog');
          modal.setAttribute('aria-modal', 'true');
          document.body.classList.add('modal-open');
          // load stored character if present
          const data = loadCharacterFromStorage();
          if (data && form) {
            Object.keys(data).forEach(k => {
              const el = form.querySelector('[name="' + k + '"]');
              if (!el) return;
              try {
                if (el.type === 'checkbox') {
                  el.checked = !!data[k];
                } else if (el.type === 'number') {
                  // strip leading plus signs which are invalid for number inputs
                  const raw = String(data[k] ?? '');
                  const stripped = raw.replace(/^\+/, '');
                  const asNum = Number(stripped);
                  if (!Number.isNaN(asNum)) el.value = String(asNum);
                  else el.value = stripped;
                } else {
                  // default: set as text (for text inputs/selects)
                  el.value = data[k];
                }
              } catch (e) {
                // defensive: if setting value fails, log and continue
                console.warn('Failed to populate character field', k, e);
              }
            });
          }
          trap.enable();
        }
        function closeCharacterModalWithEnhancements() {
          modal.setAttribute('aria-hidden', 'true');
          modal.removeAttribute('aria-modal');
          document.body.classList.remove('modal-open');
          trap.disable();
        }
  
        // Attach event listeners safely (avoid duplicating)
        if (openBtn && !openBtn.__dnd_enhanced) {
          openBtn.addEventListener('click', openCharacterModalWithEnhancements);
          openBtn.__dnd_enhanced = true;
        }
        if (closeBtn && !closeBtn.__dnd_enhanced) {
          closeBtn.addEventListener('click', closeCharacterModalWithEnhancements);
          closeBtn.__dnd_enhanced = true;
        }
        if (cancelBtn && !cancelBtn.__dnd_enhanced) {
          cancelBtn.addEventListener('click', closeCharacterModalWithEnhancements);
          cancelBtn.__dnd_enhanced = true;
        }
        if (backdrop && !backdrop.__dnd_enhanced) {
          backdrop.addEventListener('click', (ev) => { if (ev.target === backdrop) closeCharacterModalWithEnhancements(); });
          backdrop.__dnd_enhanced = true;
        }
        // Allow ESC to close via the custom event dispatched by focus trap
        modal.addEventListener('trap-escape', () => closeCharacterModalWithEnhancements());
  
        // Form submit: gather fields and save to localStorage
        if (form && !form.__dnd_save_enhanced) {
          form.addEventListener('submit', (ev) => {
            ev.preventDefault();
            const fd = new FormData(form);
            const obj = {};
            for (const [k,v] of fd.entries()) {
              const el = form.querySelector('[name="' + k + '"]');
              if (!el) continue;
              if (el.type === 'checkbox') obj[k] = !!el.checked;
              else obj[k] = v;
            }
            const saved = saveCharacterToStorage(obj);
            // show meta feedback if available
            const meta = document.querySelector('#character-meta');
            if (meta) meta.textContent = saved ? 'Saved' : 'Save failed';
            // close modal after save
            setTimeout(() => closeCharacterModalWithEnhancements(), 250);
          });
          form.__dnd_save_enhanced = true;
        }
  
        // If there is an existing function openCharacterModal/closeCharacterModal elsewhere, keep them but prefer our enhanced ones on the UI controls.
      }
    } catch (e) {
      console.warn('Failed to wire DnD character modal enhancements', e);
    }
  })();
  const characterEdit = document.querySelector('#character-edit');
  const characterClose = document.querySelector('#character-close');
  const characterCancel = document.querySelector('#character-cancel');
  const characterSave = document.querySelector('#character-save');
  const characterBackdrop = document.querySelector('#character-backdrop');
  const nameInput = document.querySelector('#char-name-input');
  const raceInput = document.querySelector('#char-race-input');
  const classInput = document.querySelector('#char-class-input');
  const notesInput = document.querySelector('#char-notes-input');

  function openCharacterModal() {
    const state = loadCharacter();
    if (nameInput) nameInput.value = state.name || '';
    if (raceInput) raceInput.value = state.race || '';
    if (classInput) classInput.value = state.cls || '';
    if (notesInput) notesInput.value = state.notes || '';
    characterModal?.setAttribute('aria-hidden', 'false');
    nameInput?.focus();
  }
  function closeCharacterModal() {
    characterModal?.setAttribute('aria-hidden', 'true');
  }
  characterEdit?.addEventListener('click', openCharacterModal);
  characterClose?.addEventListener('click', closeCharacterModal);
  characterCancel?.addEventListener('click', closeCharacterModal);
  characterBackdrop?.addEventListener('click', closeCharacterModal);
  characterSave?.addEventListener('click', () => {
    const next = {
      name: nameInput?.value?.trim() || '',
      race: raceInput?.value || '',
      cls: classInput?.value || '',
      notes: notesInput?.value?.trim() || '',
    };
    saveCharacter(next);
    renderCharacterCard(getLevelFromXp(Math.max(0, xpState?.xp || 0)));
    closeCharacterModal();
    setActionFeedback('Character saved.');
  });
  encounterTracker?.addEventListener("click", (event) => {
    const inc = event.target.closest("[data-encounter-inc]");
    const dec = event.target.closest("[data-encounter-dec]");
    if (inc) adjustEncounter(inc.dataset.encounterInc, 1);
    if (dec) adjustEncounter(dec.dataset.encounterDec, -1);
  });
  miniStartButton?.addEventListener("click", () => renderMiniNode("start"));
  miniResetButton?.addEventListener("click", () => renderMiniNode("start"));
  automationDryRunToggle?.addEventListener("change", (event) => {
    const enabled = !!event.target.checked;
    try {
      localStorage.setItem(AUTOMATION_DRY_RUN_KEY, enabled ? "1" : "0");
    } catch (e) {}
    automationDryRun = enabled;
    automationStatus &&
      (automationStatus.textContent = enabled ? "Dry run: will simulate queued automations." : "Dry run off: will execute if runner is up.");
  });
  automationRunLastButton?.addEventListener("click", restoreLastAutomationQueueAndRun);
  copilotInput?.addEventListener("input", (event) => handleCopilotQuery(event.target.value));
  copilotInput?.addEventListener("focus", (event) => {
    if (!event.target.value) {
      handleCopilotQuery("");
    }
  });
  copilotClearButton?.addEventListener("click", () => {
    copilotInput.value = "";
    handleCopilotQuery("");
    copilotInput.focus();
  });
  copilotResults?.addEventListener("click", (event) => {
    const commandButton = event.target.closest("[data-copilot-command]");
    if (!commandButton) return;
    const command = decodeURIComponent(commandButton.dataset.copilotCommand || "");
    if (!command) return;
    navigator.clipboard
      ?.writeText(command)
      .then(() => {
        commandButton.textContent = "Copied!";
        setTimeout(() => (commandButton.textContent = "Copy command"), 1500);
      })
      .catch(() => {
        commandButton.textContent = "Clipboard blocked";
      });
  });

  cadenceTabs.forEach((tab) => {
    tab.addEventListener("click", () => {
      setActiveCadenceTab(tab);
    });
  });

  checklistTabsContainer?.addEventListener("keydown", (event) => {
    const tabs = Array.from(cadenceTabs);
    if (!tabs.length) return;
    const currentIndex = tabs.findIndex((tab) => tab.getAttribute("aria-selected") === "true");
    if (currentIndex === -1) return;
    let nextIndex = currentIndex;
    switch (event.key) {
      case "ArrowRight":
      case "ArrowDown":
        nextIndex = (currentIndex + 1) % tabs.length;
        break;
      case "ArrowLeft":
      case "ArrowUp":
        nextIndex = (currentIndex - 1 + tabs.length) % tabs.length;
        break;
      case "Home":
        nextIndex = 0;
        break;
      case "End":
        nextIndex = tabs.length - 1;
        break;
      default:
        return;
    }
    event.preventDefault();
    if (nextIndex !== currentIndex) {
      setActiveCadenceTab(tabs[nextIndex], { focus: true });
    } else {
      tabs[nextIndex].focus();
    }
  });

  taskList.addEventListener("change", (event) => {
    if (event.target.matches("input[type='checkbox'][data-task]")) {
      const taskId = event.target.dataset.task;
      const checked = event.target.checked;
      checklistState[taskId] = checked;
      saveChecklistState(checklistState);
      if (checked) {
        checklistHistory[taskId] = { lastCompleted: new Date().toISOString(), week: getWeekKey() };
        saveChecklistHistory(checklistHistory);
      }
      renderTasks();
    }
  });

  resetButton?.addEventListener("click", () => {
    checklistState = {};
    saveChecklistState(checklistState);
    renderTasks();
  });

  statsCommandButton?.addEventListener("click", copyStatsCommand);
  recentRefreshButton?.addEventListener("click", () => loadRecentFiles({ force: true }));
  timelineRefreshButton?.addEventListener("click", () => refreshTimeline());
  agendaUploadInput?.addEventListener("change", handleAgendaUpload);
  agendaUploadClearButton?.addEventListener("click", () => {
    clearAgendaOverride();
    updateAgendaUploadStatus(null);
    if (agendaUploadInput) agendaUploadInput.value = "";
    loadAgenda();
  });
  spotlightPrev?.addEventListener("click", () => rotateSpotlight(-1));
  spotlightNext?.addEventListener("click", () => rotateSpotlight(1));
  openAutomationButton?.addEventListener("click", openAutomationModal);
  automationCloseButton?.addEventListener("click", closeAutomationModal);
  automationModal?.addEventListener("click", (event) => {
    if (event.target === automationModal) {
      closeAutomationModal();
    }
  });
  automationListElement?.addEventListener("click", (event) => {
    const commandButton = event.target.closest("[data-automation-command]");
    if (commandButton) {
      const command = decodeURIComponent(commandButton.dataset.automationCommand);
      navigator.clipboard
        ?.writeText(command)
        .then(() => {
          commandButton.textContent = "Copied!";
          setTimeout(() => (commandButton.textContent = "Copy command"), 1200);
        })
        .catch(() => {
          commandButton.textContent = "Clipboard blocked";
        });
    }
  });
  automationSchedulerList?.addEventListener("click", (event) => {
    const queueButton = event.target.closest("[data-automation-queue]");
    if (!queueButton) return;
    queueAutomation(queueButton.dataset.automationQueue);
  });
  automationQueueList?.addEventListener("click", (event) => {
    const removeButton = event.target.closest("[data-remove-queue]");
    if (removeButton) {
      removeAutomationFromQueue(removeButton.dataset.removeQueue);
    }
  });
  automationRunLastButton?.addEventListener("click", restoreLastAutomationQueueAndRun);
  kioskPauseButton?.addEventListener("click", toggleKioskPause);
  automationPresetImportInput?.addEventListener("change", handleAutomationPresetImport);
  automationPresetExportButton?.addEventListener("click", handleAutomationPresetExport);
  timelineList?.addEventListener("click", (event) => {
    const item = event.target.closest(".activity-item");
    if (item) {
      openTimelineModal(item);
    }
  });
  timelineModalClose?.addEventListener("click", closeTimelineModal);
  timelineModal?.addEventListener("click", (event) => {
    if (event.target === timelineModal) closeTimelineModal();
  });
  playablesGrid?.addEventListener("click", (event) => {
    const copyButton = event.target.closest("button[data-copy-command]");
    if (copyButton) {
      const decoded = decodeURIComponent(copyButton.dataset.copyCommand);
      if (navigator.clipboard?.writeText) {
        navigator.clipboard
          .writeText(decoded)
          .then(() => setActionFeedback("Command copied â€” paste into Terminal to play."))
          .catch(() => setActionFeedback("Clipboard blocked â€” copy manually."));
      } else {
        setActionFeedback("Clipboard unavailable â€” please copy the command manually.");
      }
      event.preventDefault();
    }
  });

  textGameStartButton?.addEventListener("click", () => {
    if (textGameReady || textGameLoading) return;
    textGameStartButton.disabled = true;
    initTextGameEngine();
  });

  textGameForm?.addEventListener("submit", async (event) => {
    event.preventDefault();
    if (!textGameInput?.value.trim()) return;
    const command = textGameInput.value.trim();
    appendTextGameOutput(`> ${command}`);
    baseHistory.push(command);
    textGameInput.value = "";
    try {
      await sendTextGameCommand(command);
    } catch (error) {
      console.error(error);
      appendTextGameOutput("[Error] Failed to run command.");
    }
  });

  textGameV2StartButton?.addEventListener("click", () => {
    if (textGameV2Ready || textGameV2Loading) return;
    textGameV2StartButton.disabled = true;
    initTextGameEngineV2();
  });

  textGameV2Form?.addEventListener("submit", async (event) => {
    event.preventDefault();
    if (!textGameV2Input?.value.trim()) return;
    const command = textGameV2Input.value.trim();
    appendTextGameV2Output(`> ${command}`);
    v2History.push(command);
    textGameV2Input.value = "";
    try {
      await sendTextGameCommandV2(command);
    } catch (error) {
      console.error(error);
      appendTextGameV2Output("[Error] Failed to run command.");
    }
  });
  textGameAutosaveToggle?.addEventListener("change", (event) => {
    textGameAutosave = !!event.target.checked;
    try { localStorage.setItem(TEXT_GAME_AUTOSAVE_KEY, textGameAutosave ? "1" : "0"); } catch (e) {}
  });
  textGameV2AutosaveToggle?.addEventListener("change", (event) => {
    textGameV2Autosave = !!event.target.checked;
    try { localStorage.setItem(TEXT_GAME_V2_AUTOSAVE_KEY, textGameV2Autosave ? "1" : "0"); } catch (e) {}
  });
  if (npcPanel) {
    renderNpc(pickNpcVisitor());
    npcReroll?.addEventListener("click", () => renderNpc(pickNpcVisitor(true)));
    document.getElementById("npc-claim")?.addEventListener("click", () => {
      const visitor = pickNpcVisitor();
      claimNpcReward(visitor);
    });
  }

  // Panel icons on headings
  Object.entries(PANEL_ICON_MAP).forEach(([id, icon]) => {
    const panel = document.getElementById(id);
    if (!panel) return;
    const heading = panel.querySelector("h2");
    if (!heading || heading.dataset.iconApplied) return;
    const chip = document.createElement("span");
    chip.className = "panel-icon-chip";
    chip.textContent = icon;
    heading.classList.add("panel-title-with-icon");
    heading.prepend(chip);
    heading.dataset.iconApplied = "true";
  });

  // Stat chips
  document.querySelectorAll(".stat-row").forEach((row) => {
    const title = row.querySelector("dt");
    const dd = row.querySelector("dd");
    if (!title || !dd) return;
    const icon = STAT_ICON_MAP[title.textContent.trim()];
    if (icon && !title.querySelector(".stat-chip")) {
      const chip = document.createElement("span");
      chip.className = "stat-chip";
      chip.textContent = icon;
      title.prepend(chip);
    }
  });

  document.addEventListener("click", (event) => {
    const saveButton = event.target.closest("button[data-game-save]");
    if (saveButton) {
      const variant = saveButton.dataset.gameSave;
      saveGameState(variant);
    }
    const loadButton = event.target.closest("button[data-game-load]");
    if (loadButton) {
      const variant = loadButton.dataset.gameLoad;
      loadGameState(variant);
    }
    const commandButton = event.target.closest("button[data-game-command]");
    if (commandButton) {
      const variant = commandButton.dataset.gameCommand === "v2" ? "v2" : "base";
      const command = commandButton.dataset.command;
      if (command) {
        runQuickTextGameCommand(command, variant);
      }
    }
  });

  window.addEventListener("keydown", (event) => {
    handleKonamiKey(event.key);
    const target = event.target;
    const isTyping =
      target instanceof HTMLInputElement ||
      target instanceof HTMLTextAreaElement ||
      target?.isContentEditable;
    const inGameContext = textGamePanel?.contains(target) || textGameV2Panel?.contains(target);
    const gameShortcut =
      (event.metaKey || event.ctrlKey) &&
      ["k", "l", "s", "r"].includes((event.key || "").toLowerCase());

    if (event.key === "/" && !event.metaKey && !event.ctrlKey) {
      event.preventDefault();
      searchInput.focus();
      searchInput.select();
      return;
    }

    if (event.key === "Escape") {
      if (commandPalette?.getAttribute("aria-hidden") === "false") {
        event.preventDefault();
        closeCommandPalette();
        return;
      }
      if (automationModal?.getAttribute("aria-hidden") === "false") {
        event.preventDefault();
        closeAutomationModal();
        return;
      }
    }

    if (isTyping && !gameShortcut) return;

    // Cmd+T: Jump to Triage
    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 't') {
      event.preventDefault();
      const triagePanel = document.getElementById('triage-panel');
      if (triagePanel) {
        triagePanel.scrollIntoView({ behavior: 'smooth' });
        triagePanel.focus();
      }
      return;
    }

    // Cmd+S: Jump to Search / Copilot (when not in game), otherwise save game slot
    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 's') {
      event.preventDefault();
      if (inGameContext) {
        const variant = textGameV2Panel?.contains(target) ? "v2" : "base";
        saveGameState(variant);
      } else {
        const searchInput = document.querySelector('input[type="search"]') || commandInput;
        if (searchInput) {
          searchInput.focus();
          searchInput.select();
        }
      }
      return;
    }

    // Cmd+R: Load current game slot when in-game; otherwise refresh data
    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'r') {
      event.preventDefault();
      if (inGameContext) {
        const variant = textGameV2Panel?.contains(target) ? "v2" : "base";
        loadGameState(variant);
      } else {
        document.body.classList.add('refreshing');
        Promise.all([
          loadStats(),
          loadWellbeing(),
          loadRecentFiles({ force: true }),
          loadDownloadsWatch({ force: true })
        ]).then(() => {
          updateAllRefreshBadges();
          document.body.classList.remove('refreshing');
        }).catch(e => {
          document.body.classList.remove('refreshing');
          console.error('Refresh failed:', e);
        });
      }
      return;
    }

    // Cmd+K: Focus game input (prefer v2 if ready)
    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === "k") {
      event.preventDefault();
      focusTextGameInput(textGameV2Ready ? "v2" : "base");
      return;
    }

    // Cmd+L: Clear game console when in-game; otherwise fall through
    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === "l" && inGameContext) {
      event.preventDefault();
      const variant = textGameV2Panel?.contains(target) ? "v2" : "base";
      clearTextGameConsole(variant);
      return;
    }

    if (event.key === "?" && !event.metaKey && !event.ctrlKey) {
      event.preventDefault();
      openCommandPalette();
      return;
    }
    const section = shortcutMap[event.key?.toLowerCase()];
    if (section) {
      event.preventDefault();
      showDetail(section);
    }
  });

  // Achievement: Inbox zero toast
  const inboxStat = document.querySelector('[data-stat="inboxCount"]');
  if (inboxStat) {
    const observer = new MutationObserver(() => {
      const val = Number(inboxStat.textContent || "0");
      if (val === 0) {
        showToast({ icon: "ðŸ“¬", label: "Inbox zero!", meta: "Nice sweep." });
      }
    });
    observer.observe(inboxStat, { childList: true, characterData: true, subtree: true });
  }

  // Side nav active state + back to top
  const sideNavLinks = Array.from(document.querySelectorAll(".side-nav a"));
  const backToTop = document.getElementById("back-to-top");
  const sectionTargets = sideNavLinks
    .map((link) => {
      const id = link.getAttribute("href") || "";
      if (!id.startsWith("#")) return null;
      const el = document.querySelector(id);
      return el ? { link, el } : null;
    })
    .filter(Boolean);
  function updateNavState() {
    const scrollY = window.scrollY + 120;
    sectionTargets.forEach(({ link, el }) => {
      const rect = el.getBoundingClientRect();
      const top = rect.top + window.scrollY;
      const bottom = top + rect.height;
      const active = scrollY >= top && scrollY < bottom;
      link.classList.toggle("active", active);
    });
    if (backToTop) {
      backToTop.classList.toggle("visible", window.scrollY > 240);
    }
  }
  updateNavState();
  window.addEventListener("scroll", updateNavState, { passive: true });
  backToTop?.addEventListener("click", () => window.scrollTo({ top: 0, behavior: "smooth" }));

  settingsExportButton?.addEventListener("click", exportSettings);
  settingsImportInput?.addEventListener("change", handleSettingsImport);
  statusReportExportButton?.addEventListener("click", exportStatusReport);

  healthRefreshButton?.addEventListener("click", () => {
    refreshTimeline();
    loadWellbeing();
    loadStats();
    loadRecentFiles({ force: true });
    loadDownloadsWatch({ force: true });
    renderHealthPanel();
  });

  commandCloseButton?.addEventListener("click", closeCommandPalette);
  commandPalette?.addEventListener("click", (event) => {
    if (event.target === commandPalette) {
      closeCommandPalette();
    }
  });
  commandResults?.addEventListener("click", (event) => {
    const item = event.target.closest("li[data-command-id]");
    if (item) {
      executeCommandFromEvent(item);
    }
  });
  commandInput?.addEventListener("input", (event) => filterCommandResults(event.target.value));
  commandInput?.addEventListener("keydown", handleCommandInputKeydown);

  triageResetButton?.addEventListener("click", resetTriageBoard);
  triageGrid?.addEventListener("change", handleTriageSelectChange);
  triageGrid?.addEventListener("dragstart", handleTriageDragStart);
  triageGrid?.addEventListener("dragend", handleTriageDragEnd);
  triageGrid?.addEventListener("dragover", handleTriageDragOver);
  triageGrid?.addEventListener("drop", handleTriageDrop);
  triageGrid?.addEventListener("dragenter", handleTriageDragEnter);
  triageGrid?.addEventListener("dragleave", handleTriageDragLeave);

  downloadsRefreshButton?.addEventListener("click", () => loadDownloadsWatch({ force: true }));
  downloadsTriageRefreshButton?.addEventListener("click", () => loadDownloadsWatch({ force: true }));
  downloadsTriageList?.addEventListener("click", handleDownloadsTriageClick);

  resurfacePrevButton?.addEventListener("click", () => rotateResurface(-1));
  resurfaceNextButton?.addEventListener("click", () => rotateResurface(1));
  resurfaceFilter?.addEventListener("change", () => {
    resurfaceIndex = 0;
    renderResurfaceCard();
  });
  resurfaceSnoozeButton?.addEventListener("click", () => snoozeResurfaceEntry(30));
  resurfaceSkipButton?.addEventListener("click", () => rotateResurface(1));

  scratchpadInput?.addEventListener("input", handleScratchpadInput);
  scratchpadCopyButton?.addEventListener("click", copyScratchpad);
  scratchpadDownloadButton?.addEventListener("click", downloadScratchpad);
  scratchpadClearButton?.addEventListener("click", clearScratchpad);
  scratchpadPromoteButton?.addEventListener("click", promoteScratchpadToFile);

  backupRefreshButton?.addEventListener("click", () => renderBackupStatus({ force: true }));
  backupList?.addEventListener("click", handleBackupListClick);
  kioskOrderList?.addEventListener("click", handleKioskOrderListClick);
  kioskSettingsSaveButton?.addEventListener("click", saveKioskSettings);

  detailBack.addEventListener("click", () => hideDetail());

  window.addEventListener("hashchange", handleHashNavigation);

  // Mobile nav toggle
  const navToggle = document.getElementById('nav-toggle');
  const sideNav = document.querySelector('.side-nav');
  const showNavToggleOnMobile = () => {
    if (window.innerWidth <= 900) {
      navToggle.style.display = 'block';
    } else {
      navToggle.style.display = 'none';
      sideNav?.classList.remove('mobile-open');
    }
  };
  
  navToggle?.addEventListener('click', () => {
    const isOpen = sideNav?.classList.toggle('mobile-open');
    navToggle.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
  });

  // Close nav when a link is clicked
  sideNav?.querySelectorAll('a').forEach(link => {
    link.addEventListener('click', () => {
      sideNav.classList.remove('mobile-open');
      navToggle?.setAttribute('aria-expanded', 'false');
    });
  });

  // Close nav when clicking outside
  document.addEventListener('click', (e) => {
    if (!sideNav?.contains(e.target) && !navToggle?.contains(e.target)) {
      sideNav?.classList.remove('mobile-open');
      navToggle?.setAttribute('aria-expanded', 'false');
    }
  });

  // Check on load and when resizing
  showNavToggleOnMobile();
  window.addEventListener('resize', showNavToggleOnMobile);
}

function handleHashNavigation() {
  const target = decodeURIComponent(window.location.hash.replace("#", ""));
  if (target) {
    showDetail(target, { updateHash: false });
  } else {
    hideDetail({ updateHash: false });
  }
}

async function loadStats() {
  if (!statElements.length) return;
  try {
    let stats = null;
    if (isFileProtocol) {
      stats = getInlineData("stats");
    }
    if (!stats) {
      stats = await fetchJsonWithFallback("dashboard-stats.json", { cache: "no-store" });
    }
    if (!stats) throw new Error("Stats data unavailable");
    markAchievement("refresh");
    statElements.forEach((node) => {
      const key = node.dataset.stat;
      const value = stats[key];
      node.textContent = typeof value === "number" ? value.toLocaleString() : "0";
      const meter = node.parentElement?.querySelector(".stat-meter span");
      if (meter) {
        meter.style.width = `${getStatProgress(key, Number(value) || 0)}%`;
      }
    });
    updateStatInsights(stats);
    renderInboxHealth(stats);
    if (Number(stats.inboxCount) === 0) {
      markAchievement("inbox-zero");
    }
  } catch (error) {
    console.error(error);
    statElements.forEach((node) => {
      node.textContent = "N/A";
    });
    updateStatInsights({});
    renderInboxHealth({});
  }
}

function getStatProgress(key, value) {
  if (!Number.isFinite(value)) return 0;
  const target = STAT_TARGETS[key] || Math.max(value, 1);
  let ratio = target ? Math.min(1, value / target) : 0;
  if (INVERTED_STATS.has(key)) {
    ratio = 1 - ratio;
  }
  return Math.max(0, Math.min(100, ratio * 100));
}

function updateStatInsights(stats = {}) {
  if (statInsightElements.lifehubSize) {
    statInsightElements.lifehubSize.textContent = formatBytes(Number(stats.lifehubSizeBytes || 0));
  }
  const changeValue = Number(stats.inboxWeeklyChange);
  if (statInsightElements.inboxChange) {
    const formatted = Number.isFinite(changeValue) ? `${changeValue > 0 ? "+" : ""}${changeValue}` : "--";
    statInsightElements.inboxChange.textContent = formatted;
    const card = statInsightElements.inboxChange.closest(".stat-insight-card");
    if (card) {
      card.classList.toggle("trend-up", changeValue > 0);
      card.classList.toggle("trend-down", changeValue < 0);
    }
  }
  if (statInsightElements.actionItems) {
    const actionItems = Number(stats.actionItemCount);
    statInsightElements.actionItems.textContent = Number.isFinite(actionItems) ? actionItems.toLocaleString() : "--";
  }
}

function updateWellbeingDeltas(summary = {}) {
  const deltas = summary?.deltas || {};
  setWellbeingDeltaValue(wellbeingDeltaFields.stress, deltas.stress, WELLBEING_DELTA_META.stress);
  setWellbeingDeltaValue(wellbeingDeltaFields.energy, deltas.energy, WELLBEING_DELTA_META.energy);
  setWellbeingDeltaValue(wellbeingDeltaFields.focus, deltas.focus, WELLBEING_DELTA_META.focus);
  setWellbeingDeltaValue(wellbeingDeltaFields.count, deltas.measurementCount, WELLBEING_DELTA_META.measurementCount);
}

function setWellbeingDeltaValue(node, value, meta = {}) {
  if (!node) return;
  const baseClass = "wellbeing-delta";
  if (!Number.isFinite(value) || value === null) {
    node.textContent = "â€”";
    node.className = `${baseClass} neutral`;
    return;
  }
  if (value === 0) {
    node.textContent = "â†” steady";
    node.className = `${baseClass} neutral`;
    return;
  }
  const decimals = typeof meta.decimals === "number" ? meta.decimals : 1;
  const formatted =
    decimals === 0 ? `${value > 0 ? "+" : ""}${Math.round(value)}` : `${value > 0 ? "+" : ""}${value.toFixed(decimals)}`;
  const unit = meta.unit ? ` ${meta.unit}` : "";
  const arrow = value > 0 ? "â†‘" : "â†“";
  const directionClass = value > 0 ? "positive" : "negative";
  node.textContent = `${arrow} ${formatted}${unit}`;
  node.className = `${baseClass} ${directionClass}`;
}

function buildWellbeingDeltaSummary(deltas = {}, previousMeasurement) {
  const entries = [];
  ["stress", "energy", "focus"].forEach((key) => {
    const value = deltas[key];
    if (!Number.isFinite(value) || value === 0) return;
    const meta = WELLBEING_DELTA_META[key];
    const decimals = typeof meta?.decimals === "number" ? meta.decimals : 1;
    const formatted = decimals === 0 ? Math.round(Math.abs(value)) : Math.abs(value).toFixed(decimals);
    const trend = value > 0 ? "â†‘" : "â†“";
    const unit = meta?.unit ? ` ${meta.unit}` : "";
    entries.push(`${meta?.label || key} ${trend} ${formatted}${unit}`);
  });
  if (Number.isFinite(deltas.measurementCount) && deltas.measurementCount !== 0) {
    const countMeta = WELLBEING_DELTA_META.measurementCount;
    const formatted = Math.abs(Math.round(deltas.measurementCount));
    const trend = deltas.measurementCount > 0 ? "â†‘" : "â†“";
    const unit = countMeta?.unit ? ` ${countMeta.unit}` : "";
    entries.push(`${countMeta?.label || "Measurements"} ${trend} ${formatted}${unit}`);
  }
  if (!entries.length) {
    return previousMeasurement
      ? `Since ${formatDate(previousMeasurement)}: no change detected yet.`
      : "Waiting for previous uploads to compare trends.";
  }
  const intro = previousMeasurement ? `Since ${formatDate(previousMeasurement)}: ` : "Since last import: ";
  return intro + entries.join(", ");
}

function updateWellbeingTrendSummary(summary = {}) {
  if (!wellbeingTrendSummary) return;
  const deltas = summary?.deltas || {};
  const windowLabel = summary?.comparisonWindow || "last upload";
  const parts = [];
  ["stress", "energy", "focus"].forEach((key) => {
    const value = deltas[key];
    const meta = WELLBEING_DELTA_META[key];
    if (!Number.isFinite(value) || value === 0) {
      parts.push(`${meta?.label || key}: steady`);
      return;
    }
    const decimals = typeof meta?.decimals === "number" ? meta.decimals : 1;
    const formatted = decimals === 0 ? Math.round(Math.abs(value)) : Math.abs(value).toFixed(decimals);
    const trend = value > 0 ? "â†‘" : "â†“";
    const unit = meta?.unit ? ` ${meta.unit}` : "";
    parts.push(`${meta?.label || key}: ${trend}${formatted}${unit}`);
  });
  if (Number.isFinite(deltas.measurementCount) && deltas.measurementCount !== 0) {
    const countMeta = WELLBEING_DELTA_META.measurementCount;
    const formatted = Math.abs(Math.round(deltas.measurementCount));
    const trend = deltas.measurementCount > 0 ? "+" : "âˆ’";
    const unit = countMeta?.unit ? ` ${countMeta.unit}` : "";
    parts.push(`${countMeta?.label || "Samples"}: ${trend}${formatted}${unit}`);
  }
  if (!parts.length) {
    wellbeingTrendSummary.textContent = summary.previousMeasurement
      ? `Since ${formatDate(summary.previousMeasurement)}: no change detected yet.`
      : "Waiting for previous uploads to compare trends.";
    return;
  }
  const intro = summary.previousMeasurement
    ? `Vs ${formatDate(summary.previousMeasurement)} (${windowLabel}): `
    : `Vs ${windowLabel}: `;
  wellbeingTrendSummary.textContent = intro + parts.join(" Â· ");
}

function renderInboxHealth(stats = {}) {
  if (!inboxHealthChart) return;
  const trend = Array.isArray(stats.inboxTrend) ? stats.inboxTrend : [];
  if (!trend.length) {
    showMetaMessage(inboxHealthChart, 'No weekly snapshots yet. Run refresh-all over a few weeks to unlock Inbox health.');
    if (inboxHealthSummary) {
      inboxHealthSummary.textContent = "Need additional data points to chart adds vs clears.";
    }
    return;
  }
  const maxValue = Math.max(
    1,
    ...trend.map((item) => Math.max(Number(item.added) || 0, Number(item.cleared) || 0)),
  );
  inboxHealthChart.innerHTML = "";
  let totalAdded = 0;
  let totalCleared = 0;

  const makeBar = (type, value) => {
    const bar = document.createElement("div");
    if (value > 0) {
      bar.className = `inbox-week-bar ${type}`;
      bar.style.height = `${Math.max(18, Math.round((value / maxValue) * 100))}%`;
      bar.textContent = `${type === "added" ? "+" : "-"}${value}`;
    } else {
      bar.className = "inbox-week-bar empty";
      bar.style.height = "12%";
      bar.textContent = "0";
    }
    return bar;
  };

  trend.forEach((item) => {
    const added = Math.max(0, Math.round(Number(item.added) || 0));
    const cleared = Math.max(0, Math.round(Number(item.cleared) || 0));
    totalAdded += added;
    totalCleared += cleared;

    const week = document.createElement("div");
    week.className = "inbox-week";

    const label = document.createElement("div");
    label.className = "inbox-week-label";
    label.textContent = item.weekLabel || "Week";

    const bars = document.createElement("div");
    bars.className = "inbox-week-bars";
    bars.appendChild(makeBar("added", added));
    bars.appendChild(makeBar("cleared", cleared));

    const count = document.createElement("div");
    count.className = "inbox-week-count";
    const countValue = Number(item.count);
    count.textContent = Number.isFinite(countValue)
      ? `Inbox: ${countValue.toLocaleString()}`
      : `Inbox: ${item.count ?? "--"}`;

    week.appendChild(label);
    week.appendChild(bars);
    week.appendChild(count);
    inboxHealthChart.appendChild(week);
  });

  const firstCount = Number(trend[0]?.count);
  const lastCount = Number(trend[trend.length - 1]?.count);
  const net = Number.isFinite(firstCount) && Number.isFinite(lastCount) ? lastCount - firstCount : 0;
  const direction = net < 0 ? "down" : net > 0 ? "up" : "steady";
  if (inboxHealthSummary) {
    inboxHealthSummary.textContent = `Past ${trend.length} week${
      trend.length === 1 ? "" : "s"
    }: cleared ${totalCleared}, added ${totalAdded}. Inbox ${direction} to ${
      Number.isFinite(lastCount) ? lastCount : "?"
    } items.`;
  }
}

async function loadWellbeing() {
  if (!wellbeingFields.stress) return;
  try {
    let summary = null;
    if (isFileProtocol) {
      summary = getInlineData("wellbeing");
    }
    if (!summary) {
      summary = await fetchJsonWithFallback("welltory-summary.json", { cache: "no-store" });
    }
    if (!summary) throw new Error("Wellbeing summary unavailable");
    wellbeingFields.source.textContent = summary.sourceFile || "Latest Welltory export";
    wellbeingFields.latest.textContent = summary.latestMeasurement
      ? formatDate(summary.latestMeasurement)
      : "No data";
    wellbeingFields.stress.textContent = summary.stressAverage ?? "--";
    wellbeingFields.energy.textContent = summary.energyAverage ?? "--";
    wellbeingFields.focus.textContent = summary.focusAverage ?? "--";
    wellbeingFields.count.textContent = summary.measurementCount ?? 0;
    updateWellbeingDeltas(summary);
    updateWellbeingTrendSummary(summary);
    const measurementDate = summary.latestMeasurement ? new Date(summary.latestMeasurement) : null;
    const wellbeingEntry = measurementDate
      ? [
          {
            type: "wellbeing",
            label: "Welltory import",
            meta: `Latest reading ${measurementDate.toLocaleString([], { month: "short", day: "numeric" })}`,
            time: measurementDate,
          },
        ]
      : [];
    updateTimelineSources("wellbeing", wellbeingEntry);
  } catch (error) {
    console.error(error);
    wellbeingFields.latest.textContent = "Summary unavailable";
    updateTimelineSources("wellbeing", []);
    updateWellbeingDeltas({});
  }
}

async function loadRecentFiles({ force = false } = {}) {
  if (!recentGrid) return;
  showMetaMessage(recentGrid, 'Loading recent filesâ€¦');
  const inlinePayload = isFileProtocol ? getInlineData("recentFiles") : null;
  if (isFileProtocol) {
    if (inlinePayload) {
      applyRecentFilesPayload(inlinePayload);
      return;
    }
    showMetaMessage(recentGrid, 'Recent file snapshot missing â€” run scripts/refresh_all.sh to rebuild dashboard-inline-data.js.');
    return;
  }
  try {
    const response = await fetch("recent-files.json", { cache: force ? "no-store" : "default" });
    if (!response.ok) throw new Error(`Failed to load recent files (${response.status})`);
    const payload = await response.json();
    applyRecentFilesPayload(payload);
  } catch (error) {
    console.error(error);
    loadRecentFilesViaXhr();
  }
}

function applyRecentFilesPayload(payload) {
  if (!payload) {
  showMetaMessage(recentGrid, 'Recent file list unavailable â€” run generate_recent_files.py.');
    return;
  }
  recentFilesCache = payload;
  recentFilesFlat = flattenRecentFiles(payload);
  renderRecentFiles(payload);
  updateTimelineSources("files", buildTimelineFromFiles(recentFilesFlat));
  buildTriageCards();
  buildResurfaceEntries();
  handleCopilotQuery(copilotInput?.value || "");
}

function loadRecentFilesViaXhr() {
  try {
    const xhr = new XMLHttpRequest();
    xhr.overrideMimeType("application/json");
    xhr.open("GET", "recent-files.json");
    xhr.onload = () => {
      if (xhr.status === 0 || (xhr.status >= 200 && xhr.status < 300)) {
        try {
          const payload = JSON.parse(xhr.responseText);
          applyRecentFilesPayload(payload);
        } catch (error) {
          console.error(error);
          showMetaMessage(recentGrid, 'Recent files JSON unreadable â€” rerun generate_recent_files.py.');
        }
      } else {
  showMetaMessage(recentGrid, 'Recent files unavailable â€” serve dashboard via http://localhost.');
      }
    };
    xhr.onerror = () => {
  showMetaMessage(recentGrid, 'Recent files unavailable â€” serve dashboard via http://localhost.');
    };
    xhr.send();
  } catch (error) {
    console.error(error);
  showMetaMessage(recentGrid, 'Recent files unavailable â€” serve dashboard via http://localhost.');
  }
}

function renderRecentFiles(payload) {
  const fragment = document.createDocumentFragment();
  const entries = Object.entries(payload || {});
  if (!entries.length) {
    showMetaMessage(recentGrid, 'No recent entries found.');
    return;
  }
  entries.forEach(([area, files]) => {
    const card = document.createElement("article");
    card.className = "recent-card";
    card.innerHTML = `
      <h3>${area}</h3>
      ${
        files.length
          ? `<ul>${files
              .map(
                (file) =>
                  `<li><a href="${encodePath(file.path)}" target="_blank">${file.path}</a><br><small>${formatDate(
                    file.modified
                  )}</small></li>`
              )
              .join("")}</ul>`
          : `<p class="task-meta">No recent changes.</p>`
      }
    `;
    fragment.appendChild(card);
  });
  recentGrid.innerHTML = "";
  recentGrid.appendChild(fragment);
}

async function updateAllRefreshBadges() {
  // Load all data sources and update their refresh badges
  try {
    let stats = null, recentFiles = null, welltory = null, downloads = null;
    
    if (isFileProtocol) {
      stats = getInlineData("stats");
      recentFiles = getInlineData("recentFiles");
      welltory = getInlineData("wellbeing");
      downloads = getInlineData("downloads");
    }
    
    if (!stats) {
      stats = await fetchJsonWithFallback("dashboard-stats.json", { cache: "no-store" }).catch(() => ({}));
    }
    if (!recentFiles) {
      recentFiles = await fetchJsonWithFallback("recent-files.json", { cache: "no-store" }).catch(() => ({}));
    }
    if (!welltory) {
      welltory = await fetchJsonWithFallback("welltory-summary.json", { cache: "no-store" }).catch(() => ({}));
    }
    if (!downloads) {
      downloads = await fetchJsonWithFallback("downloads-feed.json", { cache: "no-store" }).catch(() => ({}));
    }
    
    updateRefreshBadges(stats, recentFiles, welltory, downloads);
  } catch (error) {
    console.debug("Could not load refresh badge data:", error);
  }
}

async function loadAgenda() {
  if (!agendaEventsList || !agendaRemindersList) return;
  const today = new Date();
  agendaDate.textContent = new Intl.DateTimeFormat(undefined, { weekday: "long", month: "short", day: "numeric" }).format(
    today
  );
  try {
    let events = [];
    const override = getAgendaOverride();
    let calendarText = override?.text;
    updateAgendaUploadStatus(override);
    if (override?.events?.length) {
      events = filterEventsForDate(override.events, today);
    }
    if (!events.length) {
      if (!calendarText) {
        if (isFileProtocol) {
          calendarText = getInlineData("calendarIcs");
        }
        if (!calendarText && agendaConfig.icsPath) {
          calendarText = await fetchTextWithFallback(agendaConfig.icsPath, { cache: "no-store" });
        }
      }
      if (isFileProtocol) {
        // inlineData lookup already attempted above
      }
      if (calendarText) {
        events = parseIcsEvents(calendarText, today);
      }
    }
    let reminders = [];
    if (agendaConfig.remindersPath) {
      let reminderPayload = null;
      if (isFileProtocol) {
        reminderPayload = getInlineData("agendaReminders");
      }
      if (!reminderPayload) {
        reminderPayload = await fetchJsonWithFallback(agendaConfig.remindersPath, { cache: "no-store" });
      }
      reminders = reminderPayload?.reminders || [];
    }
    renderAgenda(events, reminders, today);
    const eventEntries = events.map((event) => {
      const start = event.start instanceof Date ? event.start : new Date(event.start);
      const end = event.end instanceof Date ? event.end : new Date(event.end || event.start);
      const timeLabel = event.allDay
        ? "All day"
        : `${start.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })} â€“ ${end.toLocaleTimeString([], {
            hour: "2-digit",
            minute: "2-digit",
          })}`;
      return {
        type: "event",
        label: event.summary || "Calendar event",
        meta: timeLabel,
        time: start,
      };
    });
    const reminderEntries = reminders.map((reminder) => ({
      type: "reminder",
      label: reminder.title || "Reminder",
      meta: reminder.notes || "",
      time: today,
    }));
    updateTimelineSources("events", eventEntries);
    updateTimelineSources("reminders", reminderEntries);
    if (override?.name) {
      const snapshotNote = override.mode === "compact" && !override.text ? " (snapshot)" : "";
      agendaStatus && (agendaStatus.textContent = `Agenda updated from ${override.name}${snapshotNote}`);
    }
  } catch (error) {
    console.error(error);
    agendaStatus && (agendaStatus.textContent = "Agenda unavailable â€” check the ICS path.");
  }
}

function renderAgenda(events, reminders) {
  agendaEventsList.innerHTML = "";
  if (!events.length) {
    safeAppendList(agendaEventsList, ["No calendar events today."]);
  } else {
    events
      .sort((a, b) => a.start - b.start)
      .slice(0, 5)
      .forEach((event) => {
        const li = document.createElement("li");
        const timeLabel = event.allDay
          ? "All day"
          : `${event.start.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })} â€“ ${event.end.toLocaleTimeString(
              [],
              { hour: "2-digit", minute: "2-digit" }
            )}`;
        const strong = document.createElement('strong');
        strong.textContent = event.summary || 'Event';
        const br = document.createElement('br');
        const small = document.createElement('small');
        small.textContent = timeLabel;
        li.appendChild(strong);
        li.appendChild(br);
        li.appendChild(small);
        agendaEventsList.appendChild(li);
      });
  }

  agendaRemindersList.innerHTML = "";
  if (!reminders.length) {
    safeAppendList(agendaRemindersList, ["Nothing queued."]);
  } else {
    reminders.forEach((reminder) => {
      const li = document.createElement("li");
      const strong = document.createElement('strong');
      strong.textContent = reminder.title;
      const br = document.createElement('br');
      const small = document.createElement('small');
      small.textContent = reminder.notes || '';
      li.appendChild(strong);
      li.appendChild(br);
      li.appendChild(small);
      agendaRemindersList.appendChild(li);
    });
  }
  agendaStatus && (agendaStatus.textContent = "Agenda updated");
}

function setAgendaOverride(text, name = "") {
  let mode = "none";
  let eventsStored = 0;
  try {
    localStorage.setItem(ICS_OVERRIDE_NAME_KEY, name);
  } catch (error) {
    console.warn("Failed to store agenda override name", error);
  }
  try {
    const parsedEvents = buildIcsEvents(text)
      .filter((event) => event?.start && !Number.isNaN(event.start.getTime()))
      .sort((a, b) => a.start - b.start);
    const limitedSlice = parsedEvents.slice(-ICS_OVERRIDE_EVENT_LIMIT);
    const events = limitedSlice
      .map((event) => {
        const end = event.end && !Number.isNaN(event.end.getTime()) ? event.end : event.start;
        const dateKey = event.dateKey || formatDateKey(event.start);
        return {
          summary: event.summary || "",
          start: event.start.toISOString(),
          end: end.toISOString(),
          allDay: Boolean(event.allDay),
          dateKey,
        };
      })
      .filter(Boolean);
    localStorage.setItem(ICS_OVERRIDE_EVENTS_KEY, JSON.stringify(events));
    eventsStored = events.length;
    if (events.length) {
      mode = "compact";
    }
  } catch (error) {
    console.warn("Failed to store compact agenda events", error);
    localStorage.removeItem(ICS_OVERRIDE_EVENTS_KEY);
  }
  if (text && text.length <= ICS_OVERRIDE_MAX_TEXT_LENGTH) {
    try {
      localStorage.setItem(ICS_OVERRIDE_KEY, text);
      mode = "full";
    } catch (error) {
      console.warn("Failed to store agenda override text", error);
      localStorage.removeItem(ICS_OVERRIDE_KEY);
    }
  } else {
    localStorage.removeItem(ICS_OVERRIDE_KEY);
  }
  return { mode, eventsStored };
}

function getAgendaOverride() {
  try {
    const text = localStorage.getItem(ICS_OVERRIDE_KEY);
    const name = localStorage.getItem(ICS_OVERRIDE_NAME_KEY) || "Uploaded calendar";
    let events = null;
    const serializedEvents = localStorage.getItem(ICS_OVERRIDE_EVENTS_KEY);
    if (serializedEvents) {
      try {
        const parsed = JSON.parse(serializedEvents);
        if (Array.isArray(parsed)) {
          events = parsed
            .map((event) => {
              if (!event?.start) return null;
              const start = new Date(event.start);
              const end = new Date(event.end || event.start);
              if (Number.isNaN(start.getTime())) return null;
              if (Number.isNaN(end.getTime())) return null;
              const dateKey = event.dateKey || formatDateKey(start);
              return { summary: event.summary, start, end, allDay: Boolean(event.allDay), dateKey };
            })
            .filter(Boolean);
        }
      } catch (error) {
        console.warn("Failed to parse stored agenda events", error);
      }
    }
    if (!text && (!events || !events.length)) return null;
    const mode = text ? "full" : events?.length ? "compact" : "none";
    return { text: text || "", name, events: events || [], mode };
  } catch (error) {
    console.warn("Failed to fetch agenda override", error);
    return null;
  }
}

function clearAgendaOverride() {
  try {
    localStorage.removeItem(ICS_OVERRIDE_KEY);
    localStorage.removeItem(ICS_OVERRIDE_NAME_KEY);
    localStorage.removeItem(ICS_OVERRIDE_EVENTS_KEY);
  } catch (error) {
    console.warn("Failed to clear agenda override", error);
  }
}

function updateAgendaUploadStatus(override) {
  if (!agendaUploadStatus) return;
  if (override?.name) {
    const suffix =
      override.mode === "compact" && !override.text ? " (using compact snapshot)" : override.mode === "full" ? "" : "";
    agendaUploadStatus.textContent = `Using uploaded file${suffix}: ${override.name}`;
  } else if (agendaConfig.icsPath) {
    agendaUploadStatus.textContent = `Using ${agendaConfig.icsPath}`;
  } else {
    agendaUploadStatus.textContent = "Calendar source not configured";
  }
  if (agendaUploadClearButton) {
    agendaUploadClearButton.disabled = !override;
  }
}

function handleAgendaUpload(event) {
  const file = event.target.files?.[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (e) => {
    const text = e.target?.result;
    if (typeof text !== "string") return;
    const result = setAgendaOverride(text, file.name);
    if (result.mode === "none") {
      agendaStatus && (agendaStatus.textContent = "Could not store that calendar â€” try a smaller export or clear browser data.");
      return;
    }
    updateAgendaUploadStatus(getAgendaOverride());
    const snapshotNote = result.mode === "compact" ? " (stored as a compact snapshot)" : "";
    agendaStatus &&
      (agendaStatus.textContent = `Agenda updated from ${file.name}${snapshotNote}${
        result.eventsStored ? ` Â· ${result.eventsStored} events saved` : ""
      }`);
    loadAgenda();
    if (agendaUploadInput) agendaUploadInput.value = "";
  };
  reader.onerror = () => {
    agendaStatus && (agendaStatus.textContent = "Could not read that .ics file â€” please try again.");
  };
  reader.readAsText(file);
}

function formatDateKey(date) {
  if (!(date instanceof Date) || Number.isNaN(date.getTime())) return "";
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, "0");
  const day = String(date.getDate()).padStart(2, "0");
  return `${year}-${month}-${day}`;
}

function parseIcsEvents(text, targetDate) {
  if (!text) return [];
  const events = buildIcsEvents(text);
  return filterEventsForDate(events, targetDate);
}

function buildIcsEvents(text) {
  if (!text) return [];
  const lines = text.split(/\r?\n/);
  const unfolded = [];
  lines.forEach((line) => {
    if (/^[ \t]/.test(line) && unfolded.length) {
      unfolded[unfolded.length - 1] += line.trim();
    } else {
      unfolded.push(line);
    }
  });
  const events = [];
  let current = null;
  unfolded.forEach((line) => {
    if (line === "BEGIN:VEVENT") {
      current = {};
      return;
    }
    if (line === "END:VEVENT") {
      if (current) {
        events.push(current);
        current = null;
      }
      return;
    }
    if (!current) return;
    const [key, value] = line.split(":", 2);
    if (!key || value === undefined) return;
    if (key.startsWith("DTSTART")) {
      current.start = parseIcsDate(value);
      current.startRaw = value;
    } else if (key.startsWith("DTEND")) {
      current.end = parseIcsDate(value);
      current.endRaw = value;
    } else if (key.startsWith("SUMMARY")) {
      current.summary = value;
    }
  });
  return events
    .map((event) => {
      const start = event.start;
      const end = event.end || event.start;
      if (!start) return null;
      const allDay = (event.startRaw || "").length === 8;
      const startDate = start instanceof Date ? start : new Date(start);
      const endDate = end instanceof Date ? end : new Date(end);
      if (!Number.isFinite(startDate?.getTime())) return null;
      if (!Number.isFinite(endDate?.getTime())) return null;
      return { summary: event.summary, start: startDate, end: endDate, allDay, dateKey: formatDateKey(startDate) };
    })
    .filter(Boolean);
}

function filterEventsForDate(events, targetDate) {
  if (!events?.length || !targetDate) return [];
  const dateKey = formatDateKey(targetDate);
  return events.filter((event) => {
    if (!event?.start || Number.isNaN(event.start.getTime())) return false;
    const eventKey = event.dateKey || formatDateKey(event.start);
    return eventKey === dateKey;
  });
}

function parseIcsDate(value) {
  if (!value) return null;
  // Handle all-day dates (YYYYMMDD) and date-times (YYYYMMDDTHHMMSSZ)
  if (value.length === 8) {
    const year = Number(value.slice(0, 4));
    const month = Number(value.slice(4, 6)) - 1;
    const day = Number(value.slice(6, 8));
    const date = new Date(year, month, day);
    return Number.isNaN(date.getTime()) ? null : date;
  }
  const dateTimeMatch = value.match(/^(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})(\d{2})(Z?)$/);
  if (dateTimeMatch) {
    const [, y, m, d, hh, mm, ss, z] = dateTimeMatch;
    if (z) {
      const iso = `${y}-${m}-${d}T${hh}:${mm}:${ss}Z`;
      const parsed = new Date(iso);
      return Number.isNaN(parsed.getTime()) ? null : parsed;
    }
    const parsed = new Date(Number(y), Number(m) - 1, Number(d), Number(hh), Number(mm), Number(ss));
    return Number.isNaN(parsed.getTime()) ? null : parsed;
  }
  const fallback = new Date(value);
  return Number.isNaN(fallback.getTime()) ? null : fallback;
}

function renderSpotlight() {
  if (!spotlightCard) return;
  if (!spotlightResources.length) {
    showMetaMessage(spotlightCard, 'Add spotlight resources in dashboard-data.js.');
    return;
  }
  if (spotlightIndex >= spotlightResources.length) {
    spotlightIndex = 0;
  }
  const resource = spotlightResources[spotlightIndex];
  spotlightCard.innerHTML = `
    <h3>${resource.title}</h3>
    <p>${resource.description}</p>
    <a href="${encodePath(resource.path)}" target="_blank" rel="noopener">Open resource â†’</a>
    ${
      resource.tags?.length
        ? `<div class="spotlight-tags">${resource.tags.map((tag) => `<span>${tag}</span>`).join("")}</div>`
        : ""
    }
  `;
}

function rotateSpotlight(delta = 1) {
  if (!spotlightResources.length) return;
  spotlightIndex = (spotlightIndex + delta + spotlightResources.length) % spotlightResources.length;
  renderSpotlight();
}

function startSpotlightRotation() {
  if (spotlightRotation) {
    clearInterval(spotlightRotation);
  }
  if (spotlightResources.length > 1) {
    spotlightRotation = setInterval(() => rotateSpotlight(1), 12000);
  }
}

function renderAutomations() {
  if (!automationListElement) return;
  if (!automations.length) {
    automationListElement.innerHTML = "<li>No automations defined yet.</li>";
    return;
  }
  automationListElement.innerHTML = automations
    .map(
      (automation) => `
        <li class="automation-item">
          <header>
            <strong>${automation.label}</strong>
            <span>${automation.description || ""}</span>
          </header>
          <code>${automation.command}</code>
          <button type="button" data-automation-command="${encodeURIComponent(automation.command)}">Copy command</button>
        </li>
      `
    )
    .join("");
}

function openAutomationModal() {
  if (!automationModal) return;
  renderAutomations();
  automationModal.setAttribute("aria-hidden", "false");
  automationCloseButton?.focus();
}

function closeAutomationModal() {
  if (!automationModal) return;
  automationModal.setAttribute("aria-hidden", "true");
  openAutomationButton?.focus();
}

function buildCommandItems() {
  commandItems.length = 0;
  commandItemMap.clear();
  const baseCommands = [
    {
      id: "focus-search",
      label: "Focus search",
      description: "Move cursor to dashboard search",
      keywords: ["search", "jump", "focus"],
      action: () => searchInput?.focus(),
    },
    {
      id: "toggle-focus-mode",
      label: focusModeEnabled ? "Disable focus mode" : "Enable focus mode",
      description: "Collapses dashboard to pinned cards",
      keywords: ["focus", "mode", "cards"],
      action: () => toggleFocusMode(),
    },
    {
      id: "refresh-all",
      label: "Refresh all data",
      description: "Reload stats, agenda, downloads, recent files, wellbeing",
      keywords: ["refresh", "stats", "agenda", "downloads", "recent", "wellbeing"],
      action: () => {
        loadStats();
        loadAgenda();
        loadDownloadsWatch({ force: true });
        loadRecentFiles({ force: true });
        loadWellbeing();
        setActionFeedback("Refreshing data sourcesâ€¦");
      },
    },
    {
      id: "open-health-panel",
      label: "Open System Health",
      description: "Jump to the System Health panel and refresh checks",
      keywords: ["health", "status", "freshness"],
      action: () => {
        document.getElementById("health-panel")?.scrollIntoView({ behavior: "smooth" });
        renderHealthPanel();
      },
    },
    {
      id: "export-status-report",
      label: "Export status report",
      description: "Save a markdown snapshot of stats, wellbeing, timeline, and attention items",
      keywords: ["export", "report", "markdown"],
      action: () => exportStatusReport(),
    },
    {
      id: "toggle-kiosk",
      label: kioskModeEnabled ? "Disable kiosk mode" : "Enable kiosk mode",
      description: "Turn kiosk rotation on/off",
      keywords: ["kiosk", "rotation", "auto"],
      action: () => toggleKioskMode(),
    },
    {
      id: "pause-kiosk",
      label: kioskPaused ? "Resume kiosk rotation" : "Pause kiosk rotation",
      description: "Pause or resume kiosk panel rotation",
      keywords: ["kiosk", "pause", "resume"],
      action: () => toggleKioskPause(),
    },
  ];
  baseCommands.forEach((item) => registerCommand(item));
  cards.forEach((card) => {
    registerCommand({
      id: `card-${card.title}`,
      label: `Open ${card.title}`,
      description: card.description,
      keywords: [card.title, ...(card.tags || []), ...(card.keywords || [])],
      action: () => showDetail(card.title),
    });
  });
  Array.from(document.querySelectorAll(".quick-launch-item")).forEach((item) => {
    const label = item.querySelector(".label")?.textContent || item.dataset.id;
    registerCommand({
      id: `quick-${item.dataset.id}`,
      label: `Quick launch: ${label}`,
      description: item.dataset.href || item.getAttribute("href") || "",
      keywords: ["quick", "launch", label],
      action: () => item.click(),
    });
  });
  automations.forEach((automation) => {
    registerCommand({
      id: `automation-${automation.id}`,
      label: `Copy automation: ${automation.label}`,
      description: automation.description,
      keywords: ["automation", "command", automation.label],
      action: () => navigator.clipboard?.writeText(automation.command),
    });
  });
  automationPresets.forEach((preset) => {
    registerCommand({
      id: `automation-preset-${preset.id}`,
      label: `Run automation preset: ${preset.name}`,
      description: `Queue ${preset.automations.length} step${preset.automations.length === 1 ? "" : "s"}`,
      keywords: ["automation", "preset", preset.name],
      action: () => applyAutomationPreset(preset.id),
    });
  });
  [
    { id: "jump-copilot", label: "Jump: Copilot", target: "#copilot-panel" },
    { id: "jump-automation", label: "Jump: Automation", target: "#automation-scheduler-panel" },
    { id: "jump-timeline", label: "Jump: Timeline", target: "#timeline-panel" },
    { id: "jump-wellbeing", label: "Jump: Wellbeing", target: "#wellbeing-widget" },
    { id: "jump-downloads", label: "Jump: Downloads", target: "#downloads-panel" },
    { id: "jump-resurface", label: "Jump: Resurface", target: "#resurface-panel" },
    { id: "jump-health", label: "Jump: System Health", target: "#health-panel" },
  ].forEach((entry) =>
    registerCommand({
      id: entry.id,
      label: entry.label,
      description: "Scroll to section",
      keywords: ["jump", "section", entry.label],
      action: () => document.querySelector(entry.target)?.scrollIntoView({ behavior: "smooth" }),
    }),
  );
}

function registerCommand(item) {
  commandItems.push(item);
  commandItemMap.set(item.id, item);
}

function openCommandPalette() {
  if (!commandPalette) return;
  buildCommandItems();
  commandPalette.setAttribute("aria-hidden", "false");
  renderCommandResults(commandItems);
  commandInput.value = "";
  commandInput.focus();
}

function closeCommandPalette() {
  if (!commandPalette) return;
  commandPalette.setAttribute("aria-hidden", "true");
  commandInput.value = "";
  commandResults.innerHTML = "";
}

function renderCommandResults(items) {
  commandResults.innerHTML = "";
  const limited = items.slice(0, 8);
  if (!limited.length) {
    commandResults.innerHTML = "<li>No commands match that query.</li>";
    return;
  }
  limited.forEach((item, index) => {
    const li = document.createElement("li");
    li.setAttribute("role", "option");
    li.dataset.commandId = item.id;
    li.innerHTML = `<strong>${item.label}</strong><br><small>${item.description || ""}</small>`;
    commandResults.appendChild(li);
  });
}

function filterCommandResults(query) {
  if (!query) {
    renderCommandResults(commandItems);
    return;
  }
  const tokens = query.toLowerCase().split(/\s+/).filter(Boolean);
  const filtered = commandItems.filter((item) =>
    tokens.every((token) => `${item.label} ${item.description || ""} ${(item.keywords || []).join(" ")}`.toLowerCase().includes(token))
  );
  renderCommandResults(filtered);
}

function executeCommandFromEvent(target) {
  if (!target?.dataset.commandId) return;
  const item = commandItemMap.get(target.dataset.commandId);
  if (!item) return;
  try {
    item.action?.();
  } finally {
    closeCommandPalette();
  }
}

function handleCommandInputKeydown(event) {
  const items = Array.from(commandResults.querySelectorAll("li[data-command-id]"));
  if (!items.length) return;
  let activeIndex = items.findIndex((item) => item.classList.contains("active"));
  if (event.key === "ArrowDown") {
    event.preventDefault();
    activeIndex = (activeIndex + 1) % items.length;
    setActiveCommandItem(items, activeIndex);
  } else if (event.key === "ArrowUp") {
    event.preventDefault();
    activeIndex = (activeIndex - 1 + items.length) % items.length;
    setActiveCommandItem(items, activeIndex);
  } else if (event.key === "Enter" && activeIndex > -1) {
    event.preventDefault();
    executeCommandFromEvent(items[activeIndex]);
  }
}

function setActiveCommandItem(items, index) {
  items.forEach((item, idx) => item.classList.toggle("active", idx === index));
  items[index]?.scrollIntoView({ block: "nearest" });
}

function handleCopilotQuery(rawQuery = "") {
  if (!copilotResults) return;
  const query = (rawQuery || "").trim().toLowerCase();
  if (!query) {
    renderCopilotSuggestions(buildCopilotHints());
    return;
  }
  const tokens = query.split(/\s+/).filter(Boolean);
  const matches = [];
  const seenPaths = new Set();

  cards.forEach((card) => {
    const score = scoreCardForCopilot(card, tokens);
    if (score <= 0) return;
    const primaryLink = card.links?.[0]?.href || card.root;
    matches.push({
      type: "card",
      score,
      label: `Go to ${card.title}`,
      description: card.description,
      meta: `Tags: ${(card.tags || []).join(", ") || "none"}`,
      href: encodePath(primaryLink),
    });
  });

  recentFilesFlat.forEach((file) => {
    const loweredPath = file.path.toLowerCase();
    const fileScore = tokens.every((token) => loweredPath.includes(token)) ? 2 : tokens.some((token) => loweredPath.includes(token)) ? 1 : 0;
    if (!fileScore) return;
    matches.push({
      type: "file",
      score: fileScore + (file.ageDays ? Math.max(0, 5 - Math.min(5, file.ageDays / 30)) : 0),
      label: `Open ${file.path.split("/").pop()}`,
      description: file.path,
      meta: `Updated ${formatDate(file.modified)} Â· ${file.area}`,
      href: encodePath(file.path),
    });
    seenPaths.add(loweredPath);
  });

  automations.forEach((automation) => {
    const haystack = `${automation.label} ${automation.description}`.toLowerCase();
    const match = tokens.every((token) => haystack.includes(token));
    if (!match) return;
    matches.push({
      type: "automation",
      score: 5,
      label: `Copy automation: ${automation.label}`,
      description: automation.description,
      meta: automation.command,
      command: automation.command,
    });
  });

  searchIndex.forEach((entry) => {
    if (!entry?.path) return;
    const haystack = `${entry.path} ${entry.snippet || ""}`.toLowerCase();
    const isMatch = tokens.every((token) => haystack.includes(token));
    if (!isMatch) return;
    const pathKey = entry.path.toLowerCase();
    const scoreBoost = seenPaths.has(pathKey) ? 0 : 3;
    matches.push({
      type: "search",
      score: 3 + scoreBoost,
      label: `Search hit: ${entry.path.split("/").pop() || entry.path}`,
      description: entry.snippet || entry.path,
      meta: entry.area ? `${entry.area} Â· text match` : "Text match",
      href: encodePath(entry.path),
    });
  });

  if (!matches.length) {
    renderCopilotSuggestions([
      {
        type: "hint",
        label: "No matches yet.",
        description: "Try folder names (finance), actions (copy downloads command), or file keywords.",
      },
    ]);
    return;
  }

  matches.sort((a, b) => b.score - a.score);
  renderCopilotSuggestions(matches.slice(0, 8));
}

function renderCopilotSuggestions(items) {
  if (!copilotResults) return;
  copilotResults.innerHTML = "";
  const fragment = document.createDocumentFragment();
  items.forEach((item) => {
    const li = document.createElement("li");
    li.dataset.kind = item.type || "hint";
    const parts = [`<strong>${item.label}</strong>`];
    if (item.description) {
      parts.push(`<p>${item.description}</p>`);
    }
    if (item.meta) {
      parts.push(`<small>${item.meta}</small>`);
    }
    if (item.href) {
      parts.push(`<a href="${item.href}" target="_blank" rel="noopener">Open â†’</a>`);
    } else if (item.command) {
      parts.push(
        `<button type="button" class="ghost" data-copilot-command="${encodeURIComponent(item.command)}">Copy command</button>`
      );
    }
    li.innerHTML = parts.join("");
    fragment.appendChild(li);
  });
  copilotResults.appendChild(fragment);
}

function scoreCardForCopilot(card, tokens) {
  if (!tokens.length) return 0;
  const haystack = `${card.title} ${card.description || ""} ${(card.tags || []).join(" ")} ${(card.keywords || []).join(" ")}`.toLowerCase();
  let score = 0;
  tokens.forEach((token) => {
    if (haystack.includes(token)) {
      score += 2;
    }
  });
  return score;
}

function buildCopilotHints() {
  if (!copilotExamples.length) {
    return [
      {
        type: "hint",
        label: "Try: show finance invoices",
        description: "You can also ask for reminders or copying automation commands.",
      },
    ];
  }
  return copilotExamples.map((example) => ({
    type: "hint",
    label: example,
    description: "Example prompt",
  }));
}

function prefetchSearchIndex() {
  if (isFileProtocol || searchIndexRequested) return;
  searchIndexRequested = true;
  fetch("search-index.json", { cache: "no-store" })
    .then((response) => {
      if (!response.ok) throw new Error(`search-index.json returned ${response.status}`);
      return response.json();
    })
    .then((payload) => {
      if (Array.isArray(payload)) {
        searchIndex = payload;
      }
    })
    .catch(() => {
      // Ignore fetch errors; inline data already covers file:// mode.
    });
}

function renderAutomationScheduler() {
  if (automationSchedulerList) {
    if (!automations.length) {
      automationSchedulerList.innerHTML = "<li>No automations defined yet.</li>";
    } else {
      automationSchedulerList.innerHTML = automations
        .map(
          (automation) => `
          <li>
            <strong>${automation.label}</strong>
            <p>${automation.description || ""}</p>
            <button type="button" data-automation-queue="${automation.id}">Queue run</button>
          </li>
        `
        )
        .join("");
    }
  }
  renderAutomationQueue();
  renderAutomationLog();
  updateAutomationControls();
  renderAutomationPresets();
}

function queueAutomation(id) {
  const automation = automations.find((item) => item.id === id);
  if (!automation) return;
  const entry = {
    uid: `${id}-${Date.now()}-${Math.random().toString(16).slice(2, 8)}`,
    automation,
    progress: 0,
    status: "pending",
  };
  automationQueue.push(entry);
  renderAutomationQueue();
}

function removeAutomationFromQueue(uid) {
  if (automationRunning) return;
  automationQueue = automationQueue.filter((item) => item.uid !== uid);
  renderAutomationQueue();
}

function clearAutomationQueue() {
  if (automationRunning) return;
  automationQueue = [];
  renderAutomationQueue();
}

function saveLastAutomationQueue() {
  const ids = automationQueue.map((entry) => entry.automation.id).filter(Boolean);
  if (!ids.length) return;
  try {
    localStorage.setItem(AUTOMATION_LAST_QUEUE_KEY, JSON.stringify(ids));
  } catch (e) {
    console.warn("Unable to save last automation queue", e);
  }
}

function restoreLastAutomationQueueAndRun() {
  let ids = [];
  try {
    ids = JSON.parse(localStorage.getItem(AUTOMATION_LAST_QUEUE_KEY) || "[]");
  } catch (e) {
    ids = [];
  }
  if (!Array.isArray(ids) || !ids.length) {
    automationStatus && (automationStatus.textContent = "No saved queue yet â€” run a batch to save it.");
    return;
  }
  ids.forEach((id) => queueAutomation(id));
  automationStatus && (automationStatus.textContent = "Restored last queue â€” starting now.");
  startAutomationQueue();
}

async function startAutomationQueue() {
  if (!automationQueue.length || automationRunning) return;
  saveLastAutomationQueue();
  automationRunning = true;
  automationStatus && (automationStatus.textContent = "Running queued automationsâ€¦");
  automationStartButton && (automationStartButton.disabled = true);
  const ranViaServer = automationDryRun ? false : await runAutomationQueueViaServer();
  if (!ranViaServer) {
    automationStatus &&
      (automationStatus.textContent =
        "Automation runner unavailable â€” simulating progress (start automation_server.py for real execution).");
    for (const entry of automationQueue) {
      entry.status = "running";
      renderAutomationQueue();
      await runAutomationEntry(entry);
    }
    automationStatus && (automationStatus.textContent = "Batch complete â€” review Terminal output.");
  }
  automationQueue = [];
  automationRunning = false;
  renderAutomationQueue();
}

function runAutomationEntry(entry) {
  return new Promise((resolve) => {
    const duration = Math.max(10, Number(entry.automation.durationSeconds) || 30) * 1000;
    const startedAt = Date.now();
    entry.progress = 0;
    const timer = setInterval(() => {
      const elapsed = Date.now() - startedAt;
      entry.progress = Math.min(100, Math.round((elapsed / duration) * 100));
      renderAutomationQueue();
      if (elapsed >= duration) {
        clearInterval(timer);
        entry.progress = 100;
        entry.status = "done";
        renderAutomationQueue();
        logAutomationResult({
          id: entry.automation.id,
          label: entry.automation.label,
          command: entry.automation.command,
          finishedAt: new Date().toISOString(),
          exitCode: 0,
        });
        resolve();
      }
    }, 200);
  });
}

async function runAutomationQueueViaServer() {
  if (!automationQueue.length) return false;
  automationQueue.forEach((entry) => {
    entry.status = "running";
    entry.progress = 10;
  });
  renderAutomationQueue();
  try {
    const response = await fetch(AUTOMATION_SERVER_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        tasks: automationQueue.map((entry) => ({
          id: entry.uid,
          label: entry.automation.label,
          command: entry.automation.command,
        })),
      }),
    });
    if (!response.ok) throw new Error(`Automation runner returned ${response.status}`);
    const result = await response.json();
    if (!Array.isArray(result?.runs)) throw new Error("Runner response missing runs array.");
    result.runs.forEach((run) => {
      const matched = automationQueue.find((entry) => entry.uid === run.id || entry.automation.command === run.command);
      if (matched) {
        matched.status = run.exitCode === 0 ? "done" : "error";
        matched.progress = 100;
        matched.exitCode = run.exitCode;
      }
      logAutomationResult({
        id: run.id,
        label: run.label,
        command: run.command,
        finishedAt: run.finishedAt,
        exitCode: run.exitCode,
        durationMs: run.durationMs,
      });
    });
    automationStatus && (automationStatus.textContent = "Batch complete via automation runner.");
    refreshAutomationHistoryFromFile();
    return true;
  } catch (error) {
    console.error(error);
    automationStatus &&
      (automationStatus.textContent = "Automation runner offline â€” start automation_server.py to execute scripts automatically.");
    return false;
  }
}

function renderAutomationQueue() {
  if (!automationQueueList) return;
  automationQueueList.innerHTML = "";
  if (!automationQueue.length) {
    automationQueueList.innerHTML = "<li>No automations queued.</li>";
    automationStatus && (automationStatus.textContent = "Pick at least one automation to start a batch.");
    updateAutomationControls();
    updateAutomationPresetControls();
    return;
  }
  const fragment = document.createDocumentFragment();
  automationQueue.forEach((item) => {
    const li = document.createElement("li");
    li.dataset.status = item.status;
    li.innerHTML = `
      <strong>${item.automation.label}</strong>
      <p>${item.automation.description || ""}</p>
      ${typeof item.exitCode === "number" ? `<small>Exit code: ${item.exitCode}</small>` : ""}
      <div class="automation-progress"><span style="width:${item.progress}%"></span></div>
      ${
        !automationRunning
          ? `<button type="button" class="ghost" data-remove-queue="${item.uid}">Remove</button>`
          : `<small>${item.status === "running" ? "Runningâ€¦" : "Queued"}</small>`
      }
    `;
    fragment.appendChild(li);
  });
  automationQueueList.appendChild(fragment);
  updateAutomationControls();
  updateAutomationPresetControls();
}

function updateAutomationControls() {
  if (!automationStartButton) return;
  automationStartButton.disabled = !automationQueue.length || automationRunning;
  automationClearButton && (automationClearButton.disabled = automationRunning || !automationQueue.length);
}

function logAutomationResult(entry) {
  automationLog.unshift({
    id: entry.id || entry.automation?.id,
    label: entry.label || entry.automation?.label,
    command: entry.command || entry.automation?.command,
    finishedAt: entry.finishedAt || new Date().toISOString(),
    exitCode: entry.exitCode,
    durationMs: entry.durationMs,
  });
  automationLog = automationLog.slice(0, 8);
  saveAutomationLog();
  renderAutomationLog();
}

function renderAutomationLog() {
  if (!automationLogList) return;
  if (!automationLog.length) {
    automationLogList.innerHTML = "<li>No runs yet.</li>";
    updateTimelineSources("automations", []);
    return;
  }
  automationLogList.innerHTML = automationLog
    .map(
      (entry) => `
        <li>
          <strong>${entry.label}</strong>
          <small>${formatDate(entry.finishedAt)} Â· ${entry.command}${typeof entry.exitCode === "number" ? ` (exit ${entry.exitCode})` : ""}</small>
        </li>
      `
    )
    .join("");
  updateTimelineSources("automations", buildAutomationTimelineEntries());
}

async function refreshAutomationHistoryFromFile() {
  try {
    let history = null;
    if (isFileProtocol) {
      history = getInlineData("automationHistory");
    }
    if (!history) {
      const response = await fetch("automation/logs/history.json", { cache: "no-store" });
      if (!response.ok) return;
      history = await response.json();
    }
    if (Array.isArray(history)) {
      automationLog = history.slice(0, 8);
      saveAutomationLog();
      renderAutomationLog();
    }
  } catch (error) {
    console.warn("Failed to load automation history file", error);
  }
}

function loadAutomationLog() {
  try {
    const stored = localStorage.getItem(AUTOMATION_LOG_KEY);
    if (!stored) return [];
    const parsed = JSON.parse(stored);
    return Array.isArray(parsed) ? parsed : [];
  } catch (error) {
    console.warn("Failed to parse automation log", error);
    return [];
  }
}

function saveAutomationLog() {
  try {
    localStorage.setItem(AUTOMATION_LOG_KEY, JSON.stringify(automationLog));
  } catch (error) {
    console.warn("Failed to save automation log", error);
  }
}

function buildAutomationTimelineEntries(limit = 5) {
  return automationLog.slice(0, limit).map((entry) => {
    const finishedAt = entry.finishedAt ? new Date(entry.finishedAt) : new Date();
    return {
      type: "automation",
      label: entry.label || "Automation run",
      meta: entry.command ? `Command: ${entry.command}` : "",
      time: finishedAt,
    };
  });
}

function flattenRecentFiles(payload) {
  if (!payload) return [];
  const items = [];
  Object.entries(payload).forEach(([area, files]) => {
    (files || []).forEach((file, index) => {
      items.push({
        id: `${area}-${index}-${file.path}`,
        area,
        path: file.path,
        ageDays: file.ageDays,
        modified: file.modified,
      });
    });
  });
  return items.sort((a, b) => new Date(b.modified) - new Date(a.modified));
}

function buildTimelineFromFiles(files) {
  return (files || []).slice(0, 8).map((file) => ({
    type: "file",
    label: file.path.split("/").pop(),
    meta: `${file.area} Â· ${formatDate(file.modified)}`,
    time: new Date(file.modified),
    href: encodePath(file.path),
  }));
}

function updateTimelineSources(kind, items) {
  timelineSources[kind] = items || [];
  renderTimeline();
}

function renderTimeline() {
  if (!timelineList) return;
  const filters = timelineFilters || {};
  const combined = Object.values(timelineSources)
    .flat()
    .filter((entry) => {
      const time = entry?.time instanceof Date ? entry.time : new Date(entry?.time);
      if (!(time instanceof Date) || Number.isNaN(time.getTime())) return false;
      const kind = entry?.type || "event";
      if (typeof filters[kind] === "boolean" && filters[kind] === false) return false;
      return true;
    })
    .map((entry) => ({
      ...entry,
      time: entry.time instanceof Date ? entry.time : new Date(entry.time),
    }));
  combined.sort((a, b) => b.time - a.time);
  const limited = combined.slice(0, 9);
  timelineList.innerHTML = "";
  if (!limited.length) {
    timelineEmpty && (timelineEmpty.textContent = "No timeline entries yet.");
    return;
  }
  const fragment = document.createDocumentFragment();
  limited.forEach((entry) => {
    const li = document.createElement("li");
    li.className = "activity-item";
    li.dataset.kind = entry.type || "event";
    const when = entry.time instanceof Date ? entry.time : new Date(entry.time);
    const timeLabel = when.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    li.innerHTML = `
      <strong>${entry.label}</strong>
      <p>${entry.meta || ""}</p>
      <small>${timeLabel}</small>
    `;
    if (entry.href) {
      const link = document.createElement("a");
      link.href = entry.href;
      link.target = "_blank";
      link.rel = "noopener";
      link.textContent = "Open";
      li.appendChild(link);
    }
    fragment.appendChild(li);
  });
  timelineList.appendChild(fragment);
  timelineEmpty && (timelineEmpty.textContent = "");
}

function renderHealthPanel() {
  if (!healthList) return;
  const items = [];
  const automationHealthy = automationRunnerStatus?.classList.contains("success");
  items.push({
    label: "Automation runner",
    meta: automationRunnerStatus?.textContent || "",
    ok: !!automationHealthy,
  });
  const downloadsOk = downloadsStatus && !downloadsStatus.textContent?.toLowerCase().includes("unavailable");
  items.push({
    label: "Downloads feed",
    meta: downloadsStatus?.textContent || "",
    ok: !!downloadsOk,
  });
  const wellbeingOk = wellbeingFields.latest && wellbeingFields.latest.textContent && wellbeingFields.latest.textContent !== "Summary unavailable";
  items.push({
    label: "Wellbeing",
    meta: wellbeingFields.latest?.textContent || "",
    ok: !!wellbeingOk,
  });
  const agendaOk = agendaStatus && !agendaStatus.textContent?.toLowerCase().includes("error");
  items.push({
    label: "Calendar",
    meta: agendaStatus?.textContent || "",
    ok: !!agendaOk,
  });
  const statsOk =
    statElements &&
    Array.from(statElements).some((el) => {
      const txt = el.textContent || "";
      return txt && txt !== "--";
    });
  items.push({
    label: "Stats snapshot",
    meta: statsOk ? "Loaded" : "Awaiting refresh",
    ok: !!statsOk,
  });
  healthList.innerHTML = items
    .map(
      (item) => `
      <li>
        <span>${item.label}</span>
        <small>${item.meta || ""}</small>
        <strong style="color:${item.ok ? "#15803d" : "#b91c1c"}">${item.ok ? "OK" : "Check"}</strong>
      </li>
    `,
    )
    .join("");
}

function refreshTimeline() {
  loadAgenda();
  loadRecentFiles({ force: true });
}

function bindTimelineFilters() {
  const filterInputs = document.querySelectorAll("[data-timeline-filter]");
  if (!filterInputs.length) return;
  // initialize
  filterInputs.forEach((input) => {
    const key = input.dataset.timelineFilter;
    const saved = timelineFilters[key];
    if (typeof saved === "boolean") {
      input.checked = saved;
    }
  });
  // apply initial filters
  renderTimeline();
  filterInputs.forEach((input) => {
    input.addEventListener("change", () => {
      const key = input.dataset.timelineFilter;
      timelineFilters = { ...timelineFilters, [key]: !!input.checked };
      saveTimelineFilters(timelineFilters);
      renderTimeline();
    });
  });
}

function openTimelineModal(itemEl) {
  if (!timelineModal || !timelineModalBody) return;
  const type = itemEl.dataset.kind || "event";
  const title = itemEl.querySelector("strong")?.textContent || "Timeline item";
  const meta = itemEl.querySelector("p")?.textContent || "";
  const time = itemEl.querySelector("small")?.textContent || "";
  timelineModal.setAttribute("aria-hidden", "false");
  timelineModalBody.innerHTML = `
    <p><strong>Type:</strong> ${type}</p>
    <p><strong>Details:</strong> ${meta}</p>
    <p><strong>When:</strong> ${time}</p>
  `;
  if (timelineModalMeta) {
    timelineModalMeta.textContent = meta || "";
  }
}

function closeTimelineModal() {
  if (!timelineModal) return;
  timelineModal.setAttribute("aria-hidden", "true");
}

async function loadDownloadsWatch({ force = false } = {}) {
  if (!downloadsList) return;
  downloadsStatus && (downloadsStatus.textContent = "Checking Downloadsâ€¦");
  downloadsList.innerHTML = "";
  if (isFileProtocol) {
    const feed = getInlineData("downloadsFeed");
    if (feed) {
      renderDownloadsFeed(feed);
    } else {
      downloadsStatus &&
        (downloadsStatus.textContent = "Downloads snapshot missing â€” run scripts/refresh_all.sh to rebuild dashboard-inline-data.js.");
      renderDownloadsTriage([], downloadsPathHint);
    }
    return;
  }
  try {
    const response = await fetch("downloads-feed.json", { cache: force ? "no-store" : "default" });
    if (!response.ok) throw new Error(`Failed to load downloads-feed.json (${response.status})`);
    const payload = await response.json();
    renderDownloadsFeed(payload);
  } catch (error) {
    console.error(error);
    downloadsStatus && (downloadsStatus.textContent = "Downloads watcher unavailable â€” run generate_downloads_feed.py.");
    renderDownloadsTriage([], downloadsPathHint);
  }
}

function renderDownloadsFeed(payload) {
  if (!downloadsList) return;
  const files = payload?.files || [];
  downloadsPathHint = payload?.downloadsPath || downloadsPathHint || "";
  renderDownloadsTriage(files, downloadsPathHint);
  const staleFiles = files.filter((file) => Number(file.ageHours) >= DOWNLOAD_STALE_HOURS);
  if (!staleFiles.length) {
    downloadsStatus && (downloadsStatus.textContent = "Downloads are clear â€” nothing older than a day.");
    updateTimelineSources("downloads", [
      {
        type: "downloads",
        label: "Downloads clear",
        meta: "Last check found nothing older than a day.",
        time: new Date(),
      },
    ]);
    return;
  }
  downloadsStatus &&
    (downloadsStatus.textContent = `${staleFiles.length} item${staleFiles.length === 1 ? "" : "s"} older than ${DOWNLOAD_STALE_HOURS}h.`);
  const fragment = document.createDocumentFragment();
  staleFiles
    .sort((a, b) => new Date(b.modified) - new Date(a.modified))
    .slice(0, 6)
    .forEach((file) => {
      const li = document.createElement("li");
      const age = Math.round(file.ageHours);
      const strong = document.createElement('strong');
      strong.textContent = file.name;
      const small = document.createElement('small');
      small.textContent = `${age}h old Â· ${file.modified ? formatDate(file.modified) : 'Unknown date'}`;
      li.appendChild(strong);
      li.appendChild(small);
      fragment.appendChild(li);
    });
  downloadsList.appendChild(fragment);
  const mostRecent = staleFiles
    .map((file) => new Date(file.modified || Date.now()))
    .filter((date) => date instanceof Date && !Number.isNaN(date.getTime()))
    .sort((a, b) => b - a)[0];
  updateTimelineSources("downloads", [
    {
      type: "downloads",
      label: "Downloads sweep",
      meta: `${staleFiles.length} file${staleFiles.length === 1 ? "" : "s"} pending`,
      time: mostRecent || new Date(),
    },
  ]);
}

function loadAutomationPresets() {
  let stored = [];
  try {
    stored = JSON.parse(localStorage.getItem(AUTOMATION_PRESETS_KEY) || "[]");
  } catch {
    stored = [];
  }
  stored = sanitizeAutomationPresets(Array.isArray(stored) ? stored : []);
  if (stored.length) {
    return stored;
  }
  const defaults = sanitizeAutomationPresets(DEFAULT_AUTOMATION_PRESETS);
  try {
    localStorage.setItem(AUTOMATION_PRESETS_KEY, JSON.stringify(defaults));
  } catch (error) {
    console.warn("Failed to seed automation presets", error);
  }
  return defaults;
}

function sanitizeAutomationPresets(presets) {
  const seen = new Set();
  return presets
    .map((preset) => {
      const name = typeof preset.name === "string" ? preset.name.trim() : "";
      const ids = Array.isArray(preset.automations)
        ? preset.automations.map((id) => (typeof id === "string" ? id.trim() : "")).filter(Boolean)
        : [];
      if (!name || !ids.length) return null;
      let presetId = typeof preset.id === "string" && preset.id.trim() ? preset.id.trim() : "";
      if (!presetId || seen.has(presetId)) {
        presetId = `preset-${Date.now()}-${Math.random().toString(16).slice(2, 8)}`;
      }
      seen.add(presetId);
      return { id: presetId, name, automations: Array.from(new Set(ids)) };
    })
    .filter(Boolean);
}

function saveAutomationPresetsToStorage(presets) {
  automationPresets = presets;
  try {
    localStorage.setItem(AUTOMATION_PRESETS_KEY, JSON.stringify(automationPresets));
  } catch (error) {
    console.warn("Failed to save automation presets", error);
  }
}

function handleAutomationPresetImport(event) {
  const file = event.target.files?.[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const parsed = JSON.parse(e.target.result);
      const sanitized = sanitizeAutomationPresets(Array.isArray(parsed) ? parsed : []);
      if (!sanitized.length) {
        automationStatus && (automationStatus.textContent = "Imported file had no valid presets.");
        return;
      }
      saveAutomationPresetsToStorage(sanitized);
      renderAutomationPresets();
      automationStatus &&
        (automationStatus.textContent = `Imported ${sanitized.length} preset${sanitized.length === 1 ? "" : "s"}.`);
    } catch (err) {
      automationStatus && (automationStatus.textContent = "Import failed â€” invalid JSON.");
    }
  };
  reader.readAsText(file);
  // clear input to allow re-importing same file
  event.target.value = "";
}

function handleAutomationPresetExport() {
  if (!automationPresets || !automationPresets.length) {
    automationStatus && (automationStatus.textContent = "No presets to export yet.");
    return;
  }
  const blob = new Blob([JSON.stringify(automationPresets, null, 2)], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "lifehub-automation-presets.json";
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  automationStatus && (automationStatus.textContent = "Exported presets.");
}

function renderAutomationPresets() {
  if (!automationPresetsList) return;
  const availablePresets = automationPresets
    .map((preset) => {
      const matches = preset.automations
        .map((id) => automations.find((automation) => automation.id === id))
        .filter(Boolean);
      return { ...preset, matches, missing: preset.automations.length - matches.length };
    })
    .filter((preset) => preset.matches.length);
  if (!availablePresets.length) {
    automationPresetsList.innerHTML = "<li>No presets yet â€” queue automations, name the routine, and save it.</li>";
    automationPresetsStatus &&
      (automationPresetsStatus.textContent = "Save this weekâ€™s queue so you can rebuild it instantly next time.");
    return;
  }
  automationPresetsStatus &&
    (automationPresetsStatus.textContent = "Apply a preset to append its automations to the queue.");
  automationPresetsList.innerHTML = availablePresets
    .map((preset) => {
      const chain = preset.matches.map((automation) => automation.label).join(" â†’ ");
      const missingLabel = preset.missing > 0 ? ` Â· ${preset.missing} missing step${preset.missing === 1 ? "" : "s"}` : "";
      return `
        <li>
          <div>
            <strong>${preset.name}</strong>
            <small>${preset.matches.length} step${preset.matches.length === 1 ? "" : "s"}${missingLabel}</small>
          </div>
          <p class="task-meta">Includes: ${chain}</p>
          <div class="automation-presets-actions">
            <button type="button" data-preset-run="${preset.id}">Queue preset</button>
            <button type="button" class="ghost" data-preset-delete="${preset.id}">Delete</button>
          </div>
        </li>
      `;
    })
    .join("");
}

function handleAutomationPresetSave() {
  if (!automationQueue.length) {
    automationStatus && (automationStatus.textContent = "Queue at least one automation before saving a preset.");
    return;
  }
  const name = automationPresetNameInput?.value.trim();
  if (!name) {
    automationStatus && (automationStatus.textContent = "Enter a preset name before saving.");
    return;
  }
  const ids = Array.from(new Set(automationQueue.map((entry) => entry.automation.id))).filter(Boolean);
  if (!ids.length) {
    automationStatus && (automationStatus.textContent = "Unable to save an empty preset.");
    return;
  }
  const newPreset = {
    id: `preset-${Date.now()}-${Math.random().toString(16).slice(2, 6)}`,
    name,
    automations: ids,
  };
  saveAutomationPresetsToStorage([...automationPresets, newPreset]);
  renderAutomationPresets();
  automationPresetNameInput && (automationPresetNameInput.value = "");
  updateAutomationPresetControls();
  automationStatus && (automationStatus.textContent = `Saved preset â€œ${name}â€.`);
}

function handleAutomationPresetsClick(event) {
  const runButton = event.target.closest("[data-preset-run]");
  if (runButton) {
    applyAutomationPreset(runButton.dataset.presetRun);
    return;
  }
  const deleteButton = event.target.closest("[data-preset-delete]");
  if (deleteButton) {
    deleteAutomationPreset(deleteButton.dataset.presetDelete);
  }
}

function applyAutomationPreset(presetId) {
  const preset = automationPresets.find((item) => item.id === presetId);
  if (!preset) return;
  const matched = preset.automations
    .map((id) => automations.find((automation) => automation.id === id))
    .filter(Boolean);
  if (!matched.length) {
    automationStatus && (automationStatus.textContent = `Preset â€œ${preset.name}â€ has no available automations.`);
    return;
  }
  matched.forEach((automation) => queueAutomation(automation.id));
  automationStatus &&
    (automationStatus.textContent = `Queued ${matched.length} automation${matched.length === 1 ? "" : "s"} from â€œ${
      preset.name
    }â€.`);
}

function deleteAutomationPreset(presetId) {
  if (!presetId) return;
  const preset = automationPresets.find((item) => item.id === presetId);
  if (!preset) return;
  automationPresets = automationPresets.filter((item) => item.id !== presetId);
  saveAutomationPresetsToStorage(automationPresets);
  renderAutomationPresets();
  automationStatus && (automationStatus.textContent = `Deleted preset â€œ${preset.name}â€.`);
}

function updateAutomationPresetControls() {
  if (!automationSavePresetButton) return;
  const hasQueue = automationQueue.length > 0;
  const nameFilled = !!automationPresetNameInput?.value.trim();
  automationSavePresetButton.disabled = !hasQueue || !nameFilled || automationRunning;
}

function loadTimelineFilters() {
  try {
    const saved = JSON.parse(localStorage.getItem(TIMELINE_FILTER_KEY) || "{}");
    return typeof saved === "object" && saved !== null ? saved : {};
  } catch {
    return {};
  }
}

function saveTimelineFilters(state = {}) {
  try {
    localStorage.setItem(TIMELINE_FILTER_KEY, JSON.stringify(state));
  } catch (e) {}
}

function collectSettingsSnapshot() {
  const get = (key) => {
    try {
      return localStorage.getItem(key);
    } catch (e) {
      return null;
    }
  };
  return {
    savedAt: new Date().toISOString(),
    theme: get("lh_theme_style"),
    compact: get("lh_density_compact"),
    calm: get("lh_mode_calm"),
    readable: get("lh_readable_font"),
    noShadows: get("lh_no_shadows"),
    timelineFilters: (() => {
      try {
        return JSON.parse(get(TIMELINE_FILTER_KEY) || "{}");
      } catch {
        return {};
      }
    })(),
    quickLaunchOrder: get("lh_quicklaunch_order"),
    quickLaunchPinned: get("lh_quicklaunch_pinned"),
    customQuick: get("lh_custom_quick_actions"),
    kiosk: {
      order: get(KIOSK_ORDER_KEY),
      interval: get(KIOSK_INTERVAL_KEY),
      mode: get(KIOSK_MODE_KEY),
    },
    automations: {
      dryRun: get(AUTOMATION_DRY_RUN_KEY),
      presets: get(AUTOMATION_PRESETS_KEY),
      lastQueue: get(AUTOMATION_LAST_QUEUE_KEY),
    },
    xp: get(XP_STORAGE_KEY),
    checklist: {
      state: get("lifehub-checklist-state"),
      history: get("lifehub-checklist-history"),
      cadence: activeCadence,
    },
    focusCards: Array.from(focusCards || []),
  };
}

function exportSettings() {
  const snapshot = collectSettingsSnapshot();
  const blob = new Blob([JSON.stringify(snapshot, null, 2)], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = SETTINGS_EXPORT_FILENAME;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  setActionFeedback("Exported settings.");
}

function handleSettingsImport(event) {
  const file = event.target.files?.[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const payload = JSON.parse(e.target.result);
      if (payload.theme) localStorage.setItem("lh_theme_style", payload.theme);
      if (payload.compact) localStorage.setItem("lh_density_compact", payload.compact);
      if (payload.calm) localStorage.setItem("lh_mode_calm", payload.calm);
      if (payload.readable) localStorage.setItem("lh_readable_font", payload.readable);
      if (payload.noShadows) localStorage.setItem("lh_no_shadows", payload.noShadows);
      if (payload.timelineFilters)
        localStorage.setItem(TIMELINE_FILTER_KEY, JSON.stringify(payload.timelineFilters));
      if (payload.quickLaunchOrder) localStorage.setItem("lh_quicklaunch_order", payload.quickLaunchOrder);
      if (payload.quickLaunchPinned) localStorage.setItem("lh_quicklaunch_pinned", payload.quickLaunchPinned);
      if (payload.customQuick) localStorage.setItem("lh_custom_quick_actions", payload.customQuick);
      if (payload.xp) localStorage.setItem(XP_STORAGE_KEY, payload.xp);
      if (payload.kiosk?.order) localStorage.setItem(KIOSK_ORDER_KEY, payload.kiosk.order);
      if (payload.kiosk?.interval) localStorage.setItem(KIOSK_INTERVAL_KEY, payload.kiosk.interval);
      if (payload.kiosk?.mode) localStorage.setItem(KIOSK_MODE_KEY, payload.kiosk.mode);
      if (payload.automations?.dryRun) localStorage.setItem(AUTOMATION_DRY_RUN_KEY, payload.automations.dryRun);
      if (payload.automations?.presets) localStorage.setItem(AUTOMATION_PRESETS_KEY, payload.automations.presets);
      if (payload.automations?.lastQueue) localStorage.setItem(AUTOMATION_LAST_QUEUE_KEY, payload.automations.lastQueue);
      if (payload.checklist?.state) localStorage.setItem("lifehub-checklist-state", payload.checklist.state);
      if (payload.checklist?.history) localStorage.setItem("lifehub-checklist-history", payload.checklist.history);
      if (Array.isArray(payload.focusCards)) localStorage.setItem("lifehub-focus-cards", JSON.stringify(payload.focusCards));
      setActionFeedback("Imported settings â€” reloading.");
      setTimeout(() => window.location.reload(), 400);
    } catch (err) {
      console.error(err);
      setActionFeedback("Import failed â€” invalid file.");
    }
  };
  reader.readAsText(file);
  event.target.value = "";
}

function exportStatusReport() {
  const now = new Date();
  const lines = [];
  lines.push(`# LifeHub Status Report`);
  lines.push(`Generated: ${now.toLocaleString()}`);
  lines.push("");
  lines.push("## Quick stats");
  const statData = Array.from(statElements || []).map((el) => {
    const label = el.closest("dt")?.textContent || el.parentElement?.querySelector("dt")?.textContent || "Stat";
    return `${label}: ${el.textContent?.trim() || "--"}`;
  });
  lines.push(statData.length ? statData.join("\n") : "Stats unavailable.");
  lines.push("");
  lines.push("## Wellbeing");
  lines.push(`Latest: ${wellbeingFields.latest?.textContent || "--"}`);
  lines.push(`Source: ${wellbeingFields.source?.textContent || "--"}`);
  lines.push(`Stress/Energy/Focus: ${wellbeingFields.stress?.textContent || "--"} / ${wellbeingFields.energy?.textContent || "--"} / ${wellbeingFields.focus?.textContent || "--"}`);
  lines.push(`Measurements: ${wellbeingFields.count?.textContent || "--"}`);
  lines.push(`Trend: ${wellbeingTrendSummary?.textContent || "No trend yet."}`);
  lines.push("");
  lines.push("## Attention items");
  lines.push(getAttentionItemsMarkdown());
  lines.push("");
  lines.push("## Timeline highlights");
  const timelineItems = (timelineSources ? Object.values(timelineSources).flat() : []).slice(0, 8);
  if (timelineItems.length) {
    timelineItems.forEach((item) => {
      const when = item.time ? new Date(item.time).toLocaleString() : "";
      lines.push(`- [${item.type || "event"}] ${item.label} â€” ${item.meta || ""} (${when})`);
    });
  } else {
    lines.push("No timeline entries captured.");
  }
  const blob = new Blob([lines.join("\n")], { type: "text/markdown" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "lifehub-status-report.md";
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  setActionFeedback("Exported status report.");
}

function getAttentionItemsMarkdown() {
  try {
    const arr = JSON.parse(localStorage.getItem("lh_attention_items") || "[]");
    if (!arr.length) return "None.";
    return arr.map((it) => `- ${it.text || it}`).join("\n");
  } catch {
    return "Unable to load attention items.";
  }
}

function renderDownloadsTriage(files, downloadsPath) {
  if (!downloadsTriageList) return;
  downloadsTriageList.innerHTML = "";
  downloadTriageSuggestions = new Map();
  const suggestions = buildDownloadSuggestions(files || []);
  if (!suggestions.length) {
    downloadsTriageStatus &&
      (downloadsTriageStatus.textContent = files && files.length
        ? "No confident moves to suggest right now."
        : "No download data yet â€” refresh to gather suggestions.");
    return;
  }
  downloadsTriageStatus &&
    (downloadsTriageStatus.textContent = `${suggestions.length} smart move${
      suggestions.length === 1 ? "" : "s"
    } ready. Adjust the destination if needed before moving.`);
  const safePath = downloadsPath || downloadsPathHint || "~/Downloads";
  suggestions.forEach((item, index) => {
    const suggestionId = `dltriage-${Date.now()}-${index}-${Math.floor(Math.random() * 1000)}`;
    downloadTriageSuggestions.set(suggestionId, { ...item, downloadsPath: safePath });
    const selectOptions = TRIAGE_MOVE_TARGETS.map(
      (target) =>
        `<option value="${target.id}" ${target.id === item.destination ? "selected" : ""}>${target.label}</option>`,
    ).join("");
    const li = document.createElement("li");
    li.className = "downloads-triage-item";
    li.innerHTML = `
      <header>
        <strong>${item.name}</strong>
        <small>${item.reason} Â· ${formatDownloadAge(item.ageHours)}</small>
        <small>Suggested destination: ${item.destination}</small>
      </header>
      <div class="downloads-triage-actions">
        <label>
          Destination
          <select data-download-select="${suggestionId}">
            ${selectOptions}
          </select>
        </label>
        <button type="button" data-download-move="${suggestionId}">Move file</button>
        <button type="button" class="ghost" data-download-copy="${suggestionId}">Copy open command</button>
      </div>
    `;
    downloadsTriageList.appendChild(li);
  });
}

function buildDownloadSuggestions(files = []) {
  return files
    .filter((file) => file && !file.isDir)
    .map((file) => {
      const suggestion = guessDownloadDestination(file);
      if (!suggestion) return null;
      const ageHours = Number(file.ageHours) || 0;
      if (ageHours < DOWNLOAD_TRIAGE_MIN_AGE_HOURS && suggestion.score < 2) {
        return null;
      }
      return {
        name: file.name,
        destination: suggestion.destination,
        reason: suggestion.reason,
        ageHours,
        modified: file.modified,
        score: suggestion.score,
      };
    })
    .filter(Boolean)
    .sort((a, b) => b.score - a.score || (Number(b.ageHours) || 0) - (Number(a.ageHours) || 0))
    .slice(0, DOWNLOAD_TRIAGE_LIMIT);
}

function guessDownloadDestination(file) {
  const name = (file?.name || "").trim();
  if (!name) return null;
  const lower = name.toLowerCase();
  for (const rule of DOWNLOAD_TRIAGE_RULES) {
    if (rule.test.test(lower)) {
      return { destination: rule.destination, reason: rule.reason, score: 3 };
    }
  }
  const ext = (name.split(".").pop() || "").toLowerCase();
  if (ext && DOWNLOAD_TRIAGE_EXTENSION_MAP[ext]) {
    const match = DOWNLOAD_TRIAGE_EXTENSION_MAP[ext];
    return { destination: match.destination, reason: match.reason, score: 2 };
  }
  if (lower.includes("screenshot") || lower.includes("screen shot")) {
    return { destination: "Media", reason: "Screenshot image", score: 1.5 };
  }
  return null;
}

function handleDownloadsTriageClick(event) {
  const moveBtn = event.target.closest("[data-download-move]");
  if (moveBtn) {
    moveDownloadSuggestion(moveBtn.dataset.downloadMove);
    return;
  }
  const copyBtn = event.target.closest("[data-download-copy]");
  if (copyBtn) {
    copyDownloadOpenCommand(copyBtn.dataset.downloadCopy);
  }
}

async function moveDownloadSuggestion(suggestionId) {
  if (!suggestionId) return;
  const suggestion = downloadTriageSuggestions.get(suggestionId);
  if (!suggestion) {
    setActionFeedback("Suggestion expired. Refresh Downloads to try again.");
    return;
  }
  const select = downloadsTriageList?.querySelector(`select[data-download-select="${suggestionId}"]`);
  const destination = select?.value || suggestion.destination;
  if (!destination) {
    setActionFeedback("Choose a destination before moving.");
    return;
  }
  const command = buildDownloadMoveCommand(suggestion.name, destination);
  const task = {
    id: `download-triage-${Date.now()}`,
    label: `Move ${suggestion.name} â†’ ${destination}`,
    command,
  };
  const run = await triggerImmediateAutomation(task);
  if (run?.exitCode === 0) {
    setActionFeedback(`Moved ${suggestion.name} to ${destination}.`);
    loadDownloadsWatch({ force: true });
    return;
  }
  copyDownloadMoveFallback(command, destination);
}

function buildDownloadMoveCommand(fileName, destination) {
  const encoded = encodeBase64Utf8(fileName);
  return `python3 LifeHub/scripts/move_download_item.py --source-b64 ${encoded} --destination ${destination}`;
}

function copyDownloadMoveFallback(command, destination) {
  if (!navigator.clipboard) {
    setActionFeedback(`Automation runner offline â€” copy this command manually to move into ${destination}.`);
    return;
  }
  navigator.clipboard
    .writeText(command)
    .then(() =>
      setActionFeedback(
        `Automation runner offline â€” move command copied. Paste into Terminal to file under ${destination}.`,
      ),
    )
    .catch(() => setActionFeedback("Clipboard blocked â€” copy the move command manually."));
}

function copyDownloadOpenCommand(suggestionId) {
  if (!suggestionId) return;
  const suggestion = downloadTriageSuggestions.get(suggestionId);
  if (!suggestion) return;
  const downloadsDir = suggestion.downloadsPath || downloadsPathHint || "~/Downloads";
  const command = `open "${downloadsDir.replace(/\/$/, "")}/${suggestion.name}"`;
  if (!navigator.clipboard) {
    setActionFeedback("Clipboard access denied â€” copy the open command manually.");
    return;
  }
  navigator.clipboard
    .writeText(command)
    .then(() => setActionFeedback("Open command copied â€” paste into Terminal to reveal the file."))
    .catch(() => setActionFeedback("Clipboard blocked â€” copy manually."));
}

function buildTriageCards() {
  const inboxFiles = (recentFilesCache && recentFilesCache.Inbox) || [];
  if (inboxFiles.length) {
    triageCards = inboxFiles.slice(0, 12).map((file, index) => ({
      id: file.path || `inbox-${index}`,
      label: file.path?.split("/").pop() || "Inbox item",
      href: encodePath(file.path),
      hint: `Updated ${formatDate(file.modified)}`,
      path: file.path,
    }));
  } else if (triageSeeds.length) {
    triageCards = triageSeeds.map((seed) => ({
      id: seed.id,
      label: seed.label,
      href: encodePath(seed.href || ""),
      hint: seed.hint || "",
      path: seed.path || "",
    }));
  } else {
    triageCards = [];
  }
  renderTriageBoard();
}

function renderTriageBoard() {
  if (!triageGrid) return;
  triageGrid.innerHTML = "";
  if (!triageColumns.length) {
    showMetaMessage(triageGrid, 'No triage columns defined yet.');
    return;
  }
  const columnMap = new Map();
  triageColumns.forEach((column) => columnMap.set(column.id, []));
  triageCards.forEach((card) => {
    const columnId = triageState[card.id] || "inbox";
    if (!columnMap.has(columnId)) {
      columnMap.set(columnId, []);
    }
    columnMap.get(columnId).push(card);
  });
  const fragment = document.createDocumentFragment();
  triageColumns.forEach((column) => {
    const wrapper = document.createElement("div");
    wrapper.className = "triage-column";
    wrapper.dataset.triageColumn = column.id;
  const header = document.createElement('h3');
  header.textContent = column.label + ' ';
  const headerSmall = document.createElement('small');
  headerSmall.textContent = column.description || '';
  header.appendChild(headerSmall);
  wrapper.appendChild(header);
    const columnCards = columnMap.get(column.id) || [];
    columnCards.forEach((card) => {
      const cardEl = document.createElement("article");
      cardEl.className = "triage-card";
      cardEl.draggable = true;
      cardEl.dataset.triageId = card.id;
      const moveControl = card.path
        ? `<div class="triage-move">
            <label>
              Move file
              <select data-triage-move="${card.id}">
                <option value="">Select destinationâ€¦</option>
                ${TRIAGE_MOVE_TARGETS.map((target) => `<option value="${target.id}">${target.label}</option>`).join("")}
              </select>
            </label>
            <small>Copies an mv command for Terminal</small>
          </div>`
        : "";
      cardEl.innerHTML = `
        <header>${card.label}</header>
        <p>${card.hint || ""}</p>
        <footer>
          <div class="triage-routing">
            <label>
              Board column
              <select data-triage-select="${card.id}">
                ${triageColumns
                  .map(
                    (option) => `<option value="${option.id}" ${option.id === column.id ? "selected" : ""}>${option.label}</option>`
                  )
                  .join("")}
              </select>
            </label>
            ${
              card.href
                ? `<a href="${card.href}" target="_blank" rel="noopener">Open</a>`
                : "<span>â€”</span>"
            }
          </div>
          ${moveControl}
        </footer>
      `;
      wrapper.appendChild(cardEl);
    });
    fragment.appendChild(wrapper);
  });
  triageGrid.appendChild(fragment);
}

function handleTriageSelectChange(event) {
  const moveSelect = event.target.closest("select[data-triage-move]");
  if (moveSelect) {
    const destination = moveSelect.value;
    if (destination) {
      moveTriageItem(moveSelect.dataset.triageMove, destination);
    }
    moveSelect.value = "";
    return;
  }
  const select = event.target.closest("select[data-triage-select]");
  if (!select) return;
  setTriageCardColumn(select.dataset.triageSelect, select.value);
}

function setTriageCardColumn(cardId, columnId) {
  if (!cardId) return;
  const validColumn = triageColumns.find((column) => column.id === columnId)?.id || triageColumns[0]?.id;
  if (!validColumn) return;
  triageState[cardId] = validColumn;
  saveTriageState();
  renderTriageBoard();
  markAchievement("triage-run");
}

async function moveTriageItem(cardId, destinationRoot) {
  if (!cardId || !destinationRoot) return;
  const card = triageCards.find((item) => item.id === cardId);
  if (!card?.path) {
    setActionFeedback("No file path available for that card.");
    return;
  }
  const command = buildTriageMoveCommand(card.path, destinationRoot);
  const label = `Move ${card.label || cardId} â†’ ${destinationRoot}`;
  const task = {
    id: `triage-${Date.now()}`,
    label,
    command,
  };
  const run = await triggerImmediateAutomation(task);
  if (run?.exitCode === 0) {
    setActionFeedback(`Moved ${card.label || "Inbox file"} to ${destinationRoot}.`);
    loadRecentFiles({ force: true });
    return;
  }
  copyTriageMoveFallback(command, destinationRoot);
}

function buildTriageMoveCommand(path, destinationRoot) {
  const encoded = encodeBase64Utf8(path);
  return `python3 LifeHub/scripts/move_inbox_item.py --source-b64 ${encoded} --destination ${destinationRoot}`;
}

function copyTriageMoveFallback(command, destinationRoot) {
  navigator.clipboard
    ?.writeText(command)
    .then(() =>
      setActionFeedback(
        `Automation runner offline â€” move command copied. Paste into Terminal to file under ${destinationRoot}.`
      )
    )
    .catch(() => setActionFeedback("Clipboard blocked â€” copy manually."));
}

function handleTriageDragStart(event) {
  const card = event.target.closest("[data-triage-id]");
  if (!card) return;
  draggedTriageId = card.dataset.triageId;
  event.dataTransfer?.setData("text/plain", draggedTriageId);
}

function handleTriageDragEnd() {
  draggedTriageId = null;
  triageGrid
    ?.querySelectorAll(".triage-column.is-hovered")
    .forEach((column) => column.classList.remove("is-hovered"));
}

function handleTriageDragOver(event) {
  if (!draggedTriageId) return;
  if (event.target.closest("[data-triage-column]")) {
    event.preventDefault();
  }
}

function handleTriageDrop(event) {
  if (!draggedTriageId) return;
  const column = event.target.closest("[data-triage-column]");
  if (!column) return;
  event.preventDefault();
  setTriageCardColumn(draggedTriageId, column.dataset.triageColumn);
}

function handleTriageDragEnter(event) {
  const column = event.target.closest("[data-triage-column]");
  if (!column || !draggedTriageId) return;
  column.classList.add("is-hovered");
}

function handleTriageDragLeave(event) {
  const column = event.target.closest("[data-triage-column]");
  if (!column) return;
  column.classList.remove("is-hovered");
}

function resetTriageBoard() {
  triageState = {};
  saveTriageState();
  renderTriageBoard();
}

function loadTriageState() {
  try {
    const stored = localStorage.getItem(TRIAGE_STATE_KEY);
    return stored ? JSON.parse(stored) : {};
  } catch {
    return {};
  }
}

function saveTriageState() {
  try {
    localStorage.setItem(TRIAGE_STATE_KEY, JSON.stringify(triageState));
  } catch (error) {
    console.warn("Failed to persist triage state", error);
  }
}

function buildResurfaceEntries() {
  const dormant = recentFilesFlat
    .filter((file) => Number(file.ageDays) >= RESURFACE_THRESHOLD_DAYS)
    .map((file) => ({
      title: file.path.split("/").pop(),
      description: file.path,
      ageDays: file.ageDays,
      area: file.area,
      href: encodePath(file.path),
    }))
    .sort((a, b) => Number(b.ageDays || 0) - Number(a.ageDays || 0))
    .filter((entry) => !isResurfaceSnoozed(entry));
  if (dormant.length) {
    resurfaceEntries = dormant.slice(0, 12);
  } else {
    resurfaceEntries = cards.slice(0, 6).map((card) => ({
      title: card.title,
      description: card.description,
      area: card.root,
      ageDays: 0,
      href: encodePath(card.links?.[0]?.href || card.root),
    }));
  }
  resurfaceIndex = 0;
  renderResurfaceCard();
}

function renderResurfaceCard() {
  if (!resurfaceCard) return;
  const filter = resurfaceFilter?.value || "all";
  const filtered = resurfaceEntries.filter((entry) => filter === "all" || entry.area === filter);
  if (!filtered.length) {
    showMetaMessage(resurfaceCard, 'All clear â€” add more files to LifeHub to see resurfaced suggestions.');
    return;
  }
  const entry = filtered[resurfaceIndex % filtered.length];
  const ageLabel = entry.ageDays ? `${Math.round(entry.ageDays)} days untouched` : "Recently updated";
  resurfaceCard.innerHTML = `
    <h3>${entry.title}</h3>
    <p>${entry.description || ""}</p>
    <div class="resurface-meta">
      <span>${entry.area || ""}</span>
      <span>${ageLabel}</span>
    </div>
    ${entry.href ? `<a href="${entry.href}" target="_blank" rel="noopener">Open</a>` : ""}
  `;
}

function rotateResurface(delta = 1) {
  const filter = resurfaceFilter?.value || "all";
  const filtered = resurfaceEntries.filter((entry) => filter === "all" || entry.area === filter);
  if (!filtered.length) return;
  resurfaceIndex = (resurfaceIndex + delta + filtered.length) % filtered.length;
  renderResurfaceCard();
}

function loadResurfaceSnoozed() {
  try {
    const raw = localStorage.getItem(RESURFACE_SNOOZE_KEY);
    if (!raw) return {};
    const parsed = JSON.parse(raw);
    if (typeof parsed === "object" && parsed !== null) return parsed;
    return {};
  } catch {
    return {};
  }
}

function saveResurfaceSnoozed() {
  try {
    localStorage.setItem(RESURFACE_SNOOZE_KEY, JSON.stringify(resurfaceSnoozed));
  } catch (e) {
    console.warn("Unable to save resurface snoozes", e);
  }
}

function snoozeResurfaceEntry(days = 30) {
  const filter = resurfaceFilter?.value || "all";
  const filtered = resurfaceEntries.filter((entry) => filter === "all" || entry.area === filter);
  if (!filtered.length) return;
  const entry = filtered[resurfaceIndex % filtered.length];
  const key = `${entry.area || "any"}|${entry.title}`;
  const expires = Date.now() + days * 24 * 60 * 60 * 1000;
  resurfaceSnoozed[key] = expires;
  saveResurfaceSnoozed();
  rotateResurface(1);
}

function isResurfaceSnoozed(entry) {
  if (!entry) return false;
  const key = `${entry.area || "any"}|${entry.title}`;
  const exp = resurfaceSnoozed[key];
  if (!exp) return false;
  if (Date.now() > exp) {
    delete resurfaceSnoozed[key];
    saveResurfaceSnoozed();
    return false;
  }
  return true;
}

function initScratchpad() {
  if (!scratchpadInput) return;
  try {
    scratchpadInput.value = localStorage.getItem(SCRATCHPAD_KEY) || "";
  } catch {
    scratchpadInput.value = "";
  }
  updateScratchpadStatus("Ready");
}

function handleScratchpadInput(event) {
  try {
    localStorage.setItem(SCRATCHPAD_KEY, event.target.value);
    updateScratchpadStatus("Saved");
  } catch (error) {
    console.warn("Scratchpad save failed", error);
  }
}

function copyScratchpad() {
  if (!scratchpadInput) return;
  navigator.clipboard
    ?.writeText(scratchpadInput.value)
    .then(() => updateScratchpadStatus("Copied to clipboard"))
    .catch(() => updateScratchpadStatus("Clipboard blocked"));
}

function downloadScratchpad() {
  if (!scratchpadInput) return;
  const blob = new Blob([scratchpadInput.value], { type: "text/markdown" });
  const url = URL.createObjectURL(blob);
  const link = document.createElement("a");
  link.href = url;
  link.download = `lifehub-scratchpad-${new Date().toISOString().slice(0, 10)}.md`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
  updateScratchpadStatus("Downloaded");
}

function clearScratchpad() {
  if (!scratchpadInput) return;
  scratchpadInput.value = "";
  localStorage.removeItem(SCRATCHPAD_KEY);
  updateScratchpadStatus("Cleared");
}

async function promoteScratchpadToFile() {
  if (!scratchpadInput) return;
  const text = scratchpadInput.value.trim();
  if (!text) {
    updateScratchpadStatus("Nothing to promote");
    return;
  }
  const suggestedName = `LifeHub-note-${new Date().toISOString().slice(0, 10)}.md`;
  if (window.showSaveFilePicker) {
    try {
      const handle = await window.showSaveFilePicker({
        suggestedName,
        types: [{ description: "Markdown", accept: { "text/markdown": [".md"] } }],
      });
      const writable = await handle.createWritable();
      await writable.write(text);
      await writable.close();
      updateScratchpadStatus(`Saved ${handle.name || suggestedName}`);
      return;
    } catch (error) {
      if (error.name === "AbortError") {
        updateScratchpadStatus("Save cancelled");
        return;
      }
      console.warn("Scratchpad promote failed", error);
    }
  }
  downloadScratchpad();
  updateScratchpadStatus("Downloaded â€” move into LifeHub");
}

function updateScratchpadStatus(message) {
  if (!scratchpadStatus) return;
  const timestamp = new Date().toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
  scratchpadStatus.textContent = `${message} Â· ${timestamp}`;
}

function renderBackupStatus() {
  if (!backupList) return;
  if (!backupDestinations.length) {
    backupList.innerHTML = "<li>No backup targets configured yet.</li>";
    updateTimelineSources("backups", []);
    if (backupSummary) {
      backupSummary.textContent = "No backups configured";
      backupSummary.className = "status-chip";
    }
    if (backupNextAction) {
      backupNextAction.textContent = "Add backup targets in dashboard-data.js to start monitoring them here.";
    }
    return;
  }
  const now = Date.now();
  const timelineEntries = [];
  const computed = backupDestinations.map((destination) => describeBackupDestination(destination, now));
  const sorted = computed
    .slice()
    .sort(
      (a, b) =>
        BACKUP_SEVERITY_ORDER[b.state] - BACKUP_SEVERITY_ORDER[a.state] ||
        (Number.isFinite(b.ageHours) && Number.isFinite(a.ageHours) ? b.ageHours - a.ageHours : 0)
    );
  const dangerCount = computed.filter((item) => item.state === "danger").length;
  const warningCount = computed.filter((item) => item.state === "warning").length;
  const okCount = computed.filter((item) => item.state === "ok").length;
  const summaryState = dangerCount ? "danger" : warningCount ? "warning" : "ok";
  if (backupSummary) {
    backupSummary.textContent = `${computed.length} targets Â· ${dangerCount} overdue Â· ${warningCount} due soon Â· ${okCount} healthy`;
    backupSummary.className = `status-chip ${summaryState}`;
  }
  if (backupNextAction) {
    const top = sorted[0];
    if (top) {
      const target = top.destination.label || "Backup";
      backupNextAction.textContent =
        top.state === "ok"
          ? `Next check: ${target} (${top.dueLabel})`
          : `Next action: Run ${target} (${top.dueLabel})`;
    } else {
      backupNextAction.textContent = "Backups loaded.";
    }
  }
  backupList.innerHTML = sorted
    .map(({ destination, last, state, stateLabel, ageLabel, dueLabel, progress }) => {
      if (last instanceof Date && !Number.isNaN(last)) {
        timelineEntries.push({
          type: "backup",
          label: destination.label || "Backup",
          meta: `${stateLabel} Â· ${dueLabel}`,
          time: last,
        });
      }
      const location = destination.location ? `<p class="backup-location">${destination.location}</p>` : "";
      const notes = destination.notes ? `<p class="backup-notes">${destination.notes}</p>` : "";
      const cadence = destination.frequency ? `<span class="backup-cadence">${destination.frequency}</span>` : "";
      return `
        <li class="backup-card" data-status="${state}">
          <div class="backup-card-header">
            <div class="backup-card-title">
              ${cadence}
              <strong>${destination.label || "Backup target"}</strong>
              ${location}
            </div>
            <span class="status-chip ${state}"><span class="status-dot"></span>${stateLabel}</span>
          </div>
          <div class="backup-meta">
            <div class="backup-meter" role="img" aria-label="${destination.label || "Backup"} freshness ${dueLabel}">
              <div class="backup-meter-fill" style="--backup-progress:${progress};"></div>
            </div>
            <div class="backup-age">
              <span>${ageLabel}</span>
              <small>${dueLabel}</small>
            </div>
          </div>
          ${notes}
          <footer>
            <span>${destination.command || ""}</span>
            ${
              destination.command
                ? `<button type="button" data-backup-command="${encodeURIComponent(destination.command)}">Copy verify command</button>`
                : ""
            }
          </footer>
        </li>
      `;
    })
    .join("");
  updateTimelineSources("backups", timelineEntries);
}

function handleBackupListClick(event) {
  const button = event.target.closest("[data-backup-command]");
  if (!button) return;
  const command = decodeURIComponent(button.dataset.backupCommand || "");
  const originalLabel = button.textContent;
  const revert = () => setTimeout(() => (button.textContent = originalLabel), 1200);
  navigator.clipboard
    ?.writeText(command)
    .then(() => {
      button.textContent = "Copied!";
      revert();
    })
    .catch(() => {
      button.textContent = "Clipboard blocked";
      revert();
    });
}

function toggleKioskMode() {
  kioskModeEnabled = !kioskModeEnabled;
  localStorage.setItem(KIOSK_MODE_KEY, kioskModeEnabled ? "true" : "false");
  applyKioskModeState();
}

function applyKioskModeState() {
  kioskToggle?.setAttribute("aria-pressed", kioskModeEnabled ? "true" : "false");
  if (kioskToggle) {
    kioskToggle.textContent = kioskModeEnabled ? "Kiosk mode: On" : "Kiosk mode: Off";
  }
  if (kioskPauseButton) {
    kioskPauseButton.disabled = !kioskModeEnabled;
    kioskPauseButton.textContent = kioskPaused ? "Resume rotation" : "Pause rotation";
    kioskPauseButton.setAttribute("aria-pressed", kioskPaused ? "true" : "false");
  }
  document.body.classList.toggle("kiosk-mode", kioskModeEnabled);
  if (kioskModeEnabled) {
    startKioskRotation();
  } else {
    stopKioskRotation();
    kioskPaused = false;
  }
}

function startKioskRotation() {
  if (kioskPaused) return;
  const metadata = getKioskPanelMetadata();
  const panelMap = new Map(metadata.map((item) => [item.id, item.element]));
  const config = loadKioskConfig();
  let order = Array.isArray(config.order) ? config.order : [];
  if (!order.length) {
    order = metadata.map((item) => item.id);
  }
  const disabledSet = new Set(config.disabled || []);
  const rotationIds = order.filter((id) => panelMap.has(id) && !disabledSet.has(id));
  const fallbackIds = metadata.map((item) => item.id).filter((id) => !disabledSet.has(id));
  const finalIds = rotationIds.length ? rotationIds : fallbackIds.length ? fallbackIds : metadata.map((item) => item.id);
  kioskPanels = finalIds.map((id) => panelMap.get(id)).filter(Boolean);
  kioskActiveIndex = 0;
  highlightKioskPanel();
  if (kioskRotationTimer) {
    clearInterval(kioskRotationTimer);
  }
  kioskRotationTimer = setInterval(() => {
    kioskActiveIndex = (kioskActiveIndex + 1) % Math.max(kioskPanels.length, 1);
    highlightKioskPanel();
  }, kioskRotationInterval);
}

function stopKioskRotation() {
  if (kioskRotationTimer) {
    clearInterval(kioskRotationTimer);
    kioskRotationTimer = null;
  }
  kioskPanels.forEach((panel) => panel.classList.remove("kiosk-active"));
}

function highlightKioskPanel() {
  kioskPanels.forEach((panel, index) => {
    panel.classList.toggle("kiosk-active", index === kioskActiveIndex);
  });
}

function getKioskPanelMetadata() {
  const panels = Array.from(document.querySelectorAll("[data-kiosk-highlight]")).filter(
    (panel) => panel && typeof panel.querySelector === "function"
  );
  return panels.map((panel, index) => ({
    id: panel.dataset.kioskHighlight || panel.id || `panel-${index}`,
    label: panel.querySelector("h2")?.textContent?.trim() || `Panel ${index + 1}`,
    element: panel,
  }));
}

function loadKioskConfig() {
  try {
    const storedValue = localStorage.getItem(KIOSK_ORDER_KEY);
    if (!storedValue) return { order: [], disabled: [] };
    const parsed = JSON.parse(storedValue);
    if (Array.isArray(parsed)) {
      return { order: parsed, disabled: [] };
    }
    return {
      order: Array.isArray(parsed.order) ? parsed.order : [],
      disabled: Array.isArray(parsed.disabled) ? parsed.disabled : [],
    };
  } catch {
    return { order: [], disabled: [] };
  }
}

function saveKioskConfig(config) {
  try {
    localStorage.setItem(KIOSK_ORDER_KEY, JSON.stringify(config));
  } catch (error) {
    console.warn("Failed to save kiosk order", error);
  }
}

function renderKioskSettingsForm() {
  if (!kioskOrderList) return;
  const metadata = getKioskPanelMetadata();
  const metadataMap = new Map(metadata.map((item) => [item.id, item]));
  const config = loadKioskConfig();
  const order = Array.isArray(config.order) ? config.order : [];
  const disabledSet = new Set(config.disabled || []);
  const combined = [];
  order.forEach((id) => {
    if (metadataMap.has(id)) {
      combined.push(id);
    }
  });
  metadata.forEach((item) => {
    if (!combined.includes(item.id)) {
      combined.push(item.id);
    }
  });
  kioskOrderList.innerHTML = combined
    .map((id) => {
      const meta = metadataMap.get(id);
      const checked = !disabledSet.has(id);
      return `
        <li data-panel-id="${id}">
          <label><input type="checkbox" data-kiosk-enabled ${checked ? "checked" : ""} /> ${meta?.label || id}</label>
          <div class="kiosk-order-buttons">
            <button type="button" data-kiosk-move="up" aria-label="Move ${meta?.label || id} up">â†‘</button>
            <button type="button" data-kiosk-move="down" aria-label="Move ${meta?.label || id} down">â†“</button>
          </div>
        </li>
      `;
    })
    .join("");
  if (kioskIntervalInput) {
    kioskIntervalInput.value = Math.round(kioskRotationInterval / 1000);
  }
}

function handleKioskOrderListClick(event) {
  if (!kioskOrderList) return;
  const moveButton = event.target.closest("[data-kiosk-move]");
  if (!moveButton) return;
  const item = moveButton.closest("li[data-panel-id]");
  if (!item) return;
  const direction = moveButton.dataset.kioskMove;
  if (direction === "up") {
    const previous = item.previousElementSibling;
    if (previous) {
      kioskOrderList.insertBefore(item, previous);
    }
  } else if (direction === "down") {
    const next = item.nextElementSibling;
    const insertionPoint = next?.nextElementSibling || null;
    kioskOrderList.insertBefore(item, insertionPoint);
  }
}

function saveKioskSettings() {
  if (!kioskOrderList) return;
  const items = Array.from(kioskOrderList.querySelectorAll("li[data-panel-id]"));
  const selectedIds = [];
  const disabled = [];
  items.forEach((item) => {
    const checkbox = item.querySelector("input[data-kiosk-enabled]");
    const id = item.dataset.panelId;
    if (!id) return;
    if (checkbox?.checked !== false) {
      selectedIds.push(id);
    } else {
      disabled.push(id);
    }
  });
  saveKioskConfig({ order: selectedIds, disabled });
  if (kioskIntervalInput) {
    const seconds = Math.max(5, Number(kioskIntervalInput.value) || Math.round(kioskRotationInterval / 1000));
    kioskRotationInterval = seconds * 1000;
    localStorage.setItem(KIOSK_INTERVAL_KEY, String(kioskRotationInterval));
  }
  if (kioskModeEnabled) {
    stopKioskRotation();
    startKioskRotation();
  }
  setActionFeedback("Kiosk settings updated");
}

function toggleKioskPause() {
  kioskPaused = !kioskPaused;
  kioskPauseButton?.setAttribute("aria-pressed", kioskPaused ? "true" : "false");
  kioskPauseButton && (kioskPauseButton.textContent = kioskPaused ? "Resume rotation" : "Pause rotation");
  if (kioskPaused) {
    stopKioskRotation();
  } else if (kioskModeEnabled) {
    startKioskRotation();
  }
}

function applyKioskPreset(key) {
  const preset = KIOSK_PRESETS[key];
  if (!preset) return;
  saveKioskConfig({ order: preset.order || [], disabled: preset.disabled || [] });
  renderKioskSettingsForm();
  if (kioskModeEnabled) {
    stopKioskRotation();
    startKioskRotation();
  }
  setActionFeedback(`Applied kiosk preset: ${preset.label || key}`);
}

async function triggerImmediateAutomation(task) {
  if (!task?.command) return null;
  try {
    const response = await fetch(AUTOMATION_SERVER_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ tasks: [task] }),
    });
    if (!response.ok) {
      throw new Error(`Automation runner responded with ${response.status}`);
    }
    const payload = await response.json();
    return payload?.runs?.[0] || null;
  } catch (error) {
    console.warn("Immediate automation failed", error);
    return null;
  }
}

async function checkAutomationRunnerStatus() {
  if (!automationRunnerStatus) return false;
  automationRunnerStatus.textContent = "Runner: checkingâ€¦";
  automationRunnerStatus.classList.remove("success", "danger");
  try {
    const res = await fetch(AUTOMATION_SERVER_URL, { method: "OPTIONS" });
    if (res?.ok || res?.status === 405 || res?.status === 204) {
      automationRunnerStatus.textContent = "Runner: reachable";
      automationRunnerStatus.classList.add("success");
      renderHealthPanel();
      return true;
    }
  } catch (error) {
    console.warn("Automation runner check failed", error);
  }
  automationRunnerStatus.textContent = "Runner: offline";
  automationRunnerStatus.classList.add("danger");
  renderHealthPanel();
  return false;
}

// Ensure there is a visible Character button in the header so users can open the character modal
(function(){
  try {
    // don't create duplicate
    if (document.querySelector('#character-edit')) return;
    const host = document.querySelector('#main-header') || document.querySelector('header') || document.querySelector('.topbar') || document.body;
    if (!host) return;
    const btn = document.createElement('button');
    btn.id = 'character-edit';
    btn.type = 'button';
    btn.className = 'lifehub-btn lifehub-character-button';
    btn.textContent = 'Character';
    btn.title = 'Open character sheet';
    // minimal inline styling to make it visible without CSS changes
    btn.style.padding = '6px 10px';
    btn.style.marginLeft = '8px';
    btn.style.fontSize = '13px';
    btn.style.cursor = 'pointer';
    // insert at start of host for visibility
    host.insertBefore(btn, host.firstChild);
  } catch (e) {
    console.warn('Could not inject Character button', e);
  }
})();

renderCards();
updateFocusToggle();
renderTasks();
renderPlayables();
renderXpBadge();
renderCustomQuickActions();
renderEncounterTracker();
renderInventory();
bindEvents();
bindTimelineFilters();
loadStats();
loadWellbeing();
handleHashNavigation();
loadRecentFiles();
loadAgenda();
renderSpotlight();
startSpotlightRotation();
renderAutomationScheduler();
if (window.location.protocol !== 'file:') {
  checkAutomationRunnerStatus();
  refreshAutomationHistoryFromFile();
} else {
  // running from file:// - skip automation server checks to avoid console errors
  if (typeof automationRunnerStatus !== 'undefined' && automationRunnerStatus) {
    try { automationRunnerStatus.textContent = 'Runner: skipped (file://)'; automationRunnerStatus.classList.remove('success'); automationRunnerStatus.classList.remove('danger'); } catch(e){}
  }
}
renderKioskSettingsForm();
prefetchSearchIndex();
handleCopilotQuery("");
renderBackupStatus();
initScratchpad();
buildTriageCards();
buildResurfaceEntries();
applyKioskModeState();
applyPixelModeState();
loadDownloadsWatch();
renderTimeline();
renderHealthPanel();
achievementState = loadAchievementState();
renderAchievements();
questState = loadQuestState();
renderQuestBoard();
startTavernRotation();
renderTextGameEventBanner();
renderMiniNode("start");
// Update refresh badges after all data is loaded
setTimeout(updateAllRefreshBadges, 500);
// Start auto-refresh every 5 minutes
setupAutoRefresh(5);
